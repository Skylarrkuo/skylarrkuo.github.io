[{"title":"C语言编程小细节(1)","url":"/2025/10/12/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%BB%86%E8%8A%82%EF%BC%881%EF%BC%89/","content":"C语言中关于”0”的细节‘\\0’ ，‘0’， “0” 之间的区别‘\\0’‘\\0’对应ASCII码是0，字符是（Null），即空字符。判断一个字符串是否结束的标志就是看是否遇到‘\\0’，如果遇到‘\\0’，则表示字符串结束。\n‘0’‘0’是字符常量，对应的ASCII码是48，对应的十六进制数就是0x30，通常我们在编程的时候，用字符转化为数字的时候经常要用到，比如要将‘8’转换为数字8，在语句中这样写：  8+‘0’。这里的8就是数字。\n字符‘0’和数字0的区别：前者是字符常量，后者是整形常量，它们的含义和在计算机中的存储方式截然不同。但是字符常量可以像整数一样在程序中参与相关运算。例如：‘9’-3；\n“0”“0”是字符串常量，字符串常量是由一对双引号括起的字符序列。例如：“CHINA”，“I LOVE YOU”，“123”等都是合法的字符串常量。\n注意：\n1，字符常量由单引号括起来；字符串常量由双引号括起来。\n2：字符常量只能是单个字符；字符串常量则可以含一个或多个字符。\n","categories":["编程"],"tags":["C","编程"]},{"title":"MathJax-LaTeX公式","url":"/2025/10/16/MathJax-LaTeX%E5%85%AC%E5%BC%8F/","content":"希腊字母小写字母：\n大写字母：\n常见变体：\n上下标\n分式与根式\n\n普通运算符\n\n\n\n\n大型运算符\n单重积分二重积分三重积分曲线积分∯曲面积分∰三重曲面积分\n\n\n标注符号\n箭头\n括号与定界符\n多行公式\n大括号其他\n矩阵\n\n\n\n实战演练\n\n\n\n源代码(MathJax)## 希腊字母小写字母：$$\\alpha,\\ \\beta,\\ \\gamma,\\ \\delta,\\ \\epsilon,\\ \\zeta,\\ \\eta,\\ \\theta,\\ \\iota,\\ \\kappa,\\ \\lambda,\\ \\mu,\\ \\nu,\\ \\xi,\\ \\omicron,\\ \\pi,\\ \\rho,\\ \\sigma,\\ \\tau,\\ \\upsilon,\\ \\phi,\\ \\chi,\\ \\psi,\\ \\omega$$大写字母：$$\\Gamma,\\ \\Delta,\\ \\Theta,\\ \\Lambda,\\ \\Xi,\\ \\Pi,\\ \\Sigma,\\ \\Upsilon,\\ \\Phi,\\ \\Psi,\\ \\Omega$$常见变体：$$\\varepsilon,\\ \\vartheta,\\ \\varpi,\\ \\varrho,\\ \\varsigma,\\ \\varphi$$## 上下标$$\\begin{array}{cl}a^2,a_1\\\\\\\\x^{y+z},p_{ij},p_ij\\\\\\\\x_i,x_{\\text i}\\\\\\\\\\text{A B},\\rm{A B}\\\\\\\\\\text A B,\\rm A B\\\\\\\\{\\rm A} B\\\\\\\\\\text{e},\\text{i}\\end{array}$$## 分式与根式$$\\frac{1}{2},\\frac 1 2,\\\\\\frac 1 {x+y}\\\\\\frac {\\dfrac 1 x + 1}{y + 1}$$$$\\sqrt 2,\\sqrt{x+y},\\sqrt[3]x$$## 普通运算符$$\\begin{array}{cl}+-\\\\\\\\\\times,\\cdot,\\div\\\\\\\\\\pm,\\mp\\\\\\\\\\ge,\\le,\\gg,\\ll,\\ne,\\approx,\\equiv\\\\\\\\\\cap,\\cup,\\in,\\notin,\\subseteq,\\subsetneqq,\\varnothing\\\\\\\\\\forall,\\exists,\\nexists\\\\\\\\\\because,\\therefore\\\\\\\\\\mathbb R,\\mathbb R,\\mathbb Q,\\mathbb N,\\mathbb Z_+\\\\\\\\\\mathcal F,\\mathscr F\\end{array}$$$$\\cdots,\\vdots,\\ddots$$$$\\infty,\\partial,∂,\\nabla,\\propto,\\degree$$$$\\begin{array}{cl}\\sin x,\\sec x,\\cosh x\\\\\\\\\\log_2 x, \\ln x,\\lg x\\\\\\\\\\lim\\limits_{x \\to 0} \\frac { x}{\\sin x}\\\\\\\\\\max x\\end{array}$$$$\\text{MSE}(x)$$## 大型运算符$$\\sum,\\prod\\\\\\sum_i,\\sum_{i=0}^N\\\\\\frac{\\sum\\limits_{i=1}^n x_i}{\\prod\\limits_{i=1}^n x_i}$$$$\\begin{array}{cl}\\int &amp; \\verb|\\int| \\text{ 单重积分} \\\\\\\\\\iint &amp; \\verb|\\iint| \\text{ 二重积分} \\\\\\\\\\iiint &amp; \\verb|\\iiint| \\text{ 三重积分} \\\\\\\\\\oint &amp; \\verb|\\oint| \\text{ 曲线积分} \\\\\\\\\\unicode{x222F} &amp; \\verb|\\unicode{x222F}| \\text{ 曲面积分 (oiint)} \\\\\\\\\\unicode{x2230} &amp; \\verb|\\unicode{x2230}| \\text{ 三重曲面积分 (oiiint)}\\end{array}$$$$\\int_{-\\infty}^0 f(x)\\,\\text d x\\\\$$$$\\begin{array}{cl}a\\, a \\\\\\\\a\\ a \\\\\\\\a\\quad a \\\\\\\\a\\qquad a\\end{array}$$## 标注符号$$\\vec x,\\overrightarrow {AB}\\\\\\bar x,\\overline{AB}$$## 箭头$$\\leftarrow,\\Rightarrow,\\Leftrightarrow,\\longleftarrow$$## 括号与定界符$$\\begin{array}{cl}([])\\{ \\}\\\\\\\\\\lceil,\\rceil,\\lfloor,\\rfloor,||\\\\\\\\\\left(0,\\frac 1 a\\right]\\\\\\\\\\left.\\frac {∂f}{∂x}\\right|_{x=0}\\end{array}$$## 多行公式$$\\begin{align} a&amp;=b+c+d\\\\\\\\\\&amp;=e+f \\end{align}$$## 大括号$$f(x)=\\begin{cases}\\sin x, &amp; -π\\le x \\le π\\\\\\\\0,&amp; \\text{其他}\\end{cases}$$## 矩阵$$\\begin{matrix}a &amp; b &amp; \\cdots &amp; c \\\\\\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\e &amp; f &amp; \\cdots &amp; g\\end{matrix}$$$$\\begin{bmatrix}a &amp; b &amp; \\cdots &amp; c \\\\\\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\e &amp; f &amp; \\cdots &amp; g\\end{bmatrix}\\quad\\begin{pmatrix}a &amp; b &amp; \\cdots &amp; c \\\\\\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\e &amp; f &amp; \\cdots &amp; g\\end{pmatrix}\\quad\\begin{vmatrix}a &amp; b &amp; \\cdots &amp; c \\\\\\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\e &amp; f &amp; \\cdots &amp; g\\end{vmatrix}$$$$\\begin{Bmatrix}a &amp; b &amp; \\cdots &amp; c \\\\\\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\e &amp; f &amp; \\cdots &amp; g\\end{Bmatrix}\\quad\\begin{Vmatrix}a &amp; b &amp; \\cdots &amp; c \\\\\\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\e &amp; f &amp; \\cdots &amp; g\\end{Vmatrix}$$$$\\bf A,\\bf B^{\\rm T}$$## 实战演练$$f(x) = \\frac 1 {\\sqrt{2\\pi} \\sigma} {\\rm e} ^ {-\\frac {(x-\\mu)^2}{2\\sigma ^ 2}}\\\\\\\\f(x) = \\frac 1 {\\sqrt{2\\pi} \\sigma} \\exp \\left[ {-\\frac {(x-\\mu)^2}{2\\sigma ^ 2}}\\right]$$$$\\\\lim_{N\\\\to\\\\infty} P\\\\left\\\\{\\\\left|\\\\frac{I(\\\\alpha_i)}{N} - H(s)\\\\right| &lt; \\\\varepsilon\\\\right\\\\} = 1$$$$x(n) = \\frac 1 {2\\pi} \\int _{-π} ^ π X\\left( {\\rm e} ^ {{\\rm j} \\omega } \\right) {\\rm e} ^ {{\\rm j} \\omega n} \\, {\\rm d}\\omega\\\\$$$$\\begin{align}\\vec B \\left( \\vec r \\right) &amp;= \\frac {\\mu_0}{4\\pi}\\oint_C \\frac {I \\, {\\rm d} \\vec l \\times \\vec R}{R^3}\\\\\\\\&amp;= \\frac {\\mu_0}{4\\pi} \\int_V \\frac{\\vec J_V \\times \\vec R}{R^3}\\, {\\rm d} V'\\end{align}$$\n\n\n\n\n\n","categories":["LaTeX"],"tags":["MathJax","LaTeX"]},{"title":"Java编程初学记录","url":"/2025/10/12/Java%E7%BC%96%E7%A8%8B%E5%88%9D%E5%AD%A6%E8%AE%B0%E5%BD%95/","content":"记录初学Java时练习过的题目~1、1!+2!+…+10!的值//1.编写一个Java程序，求1!+2!+…+10!的值，程序文件命名为“FactoriesSum.java”。public class FactoriesSum &#123;    public static void main(String[] args) &#123;        int sum=0;        for(int i=1,a=1;i&lt;=10;i++,a=1)&#123;            for(int j=1;j&lt;=i;j++)&#123;                a*=j;            &#125;            sum+=a;        &#125;        System.out.println(&quot;1!+2!+…+10!=&quot;+sum);    &#125;&#125;\n\n\n\n2、 输出从100-200 之间（包括100和200）的所有质数//2.编写一个Java程序，输出从100-200 之间（包括100和200）的所有质数，以空格分隔方式输出这些数字，程序文件命名为“PrimeNumer.java”。//提示：质数为大于1的自然数中，除了1和它本身以外不能被其他数整除的自然数。例如2,3,5,7……public class PrimeNumer &#123;    public static void main(String[] args) &#123;        for(int i =100,t=0;i&lt;=200;i++,t=0)&#123;            int j;            for(j=2;j&lt;(int)(i/2);j++)&#123;                if(i%j!=0)                    t++;                else                    break;            &#125;            if(j==(int)(i/2))                System.out.printf(&quot;%d &quot;,i);        &#125;    &#125;&#125;\n\n\n\n3 求100-999之间的水仙花数//3.编写一个Java程序，求100-999之间的水仙花数，程序文件命名为“Narcissus.java”。// 提示：水仙花数为一个数的每一位数字的立方之和等于这个数，如数字153，1^3+5^3+3^3=153，以空格分隔输出这些数字。public class Narcissus &#123;    public static void main(String[] args) &#123;        for(int i=100;i&lt;=999;i++)&#123;            int a=i%10;            int b=i/10%10;            int c=i/100;            if(Math.pow(a,3)+Math.pow(b,3)+Math.pow(c,3)==i)                System.out.printf(&quot;%d &quot;,i);        &#125;    &#125;&#125;\n\n\n\n4 、输出1949年-2023年内的闰年//4.编写一个Java程序，输出1949年-2023年内的闰年，要求按行输出，一行5个年份，用空格分隔，程序文件命名为“LeapYear.java”。public class LeapYear &#123;    public static void main(String[] args) &#123;        for (int i = 1949,a=0; i &lt;= 2023; i++) &#123;            if ((i % 4 == 0 &amp;&amp; i % 100 != 0) || i % 400 == 0) &#123;                System.out.printf(&quot;%d\\t&quot;, i);                a++;                if(a%5==0)&#123;                    System.out.print(&quot;\\n&quot;);                &#125;            &#125;        &#125;    &#125;&#125;\n\n5、“动物”类//1.编写Java程序实现如下功能//（1）设计一个“动物”类：Animal，包括：//①两个公有属性：name（字符串类型）和age（整形）；//②两个公有方法：eat（void类型，方法参数为：一个字符串类型）和move（void类型，方法参数为空），方法内部各自打印一行语句。//（2）接下来设计“猫”类：Cat，继承“Animal”类，新增一个公有属性：color（字符串类型）。//在“猫”类请实现以下方法：//①构造方法：参数列表为：name、age、color，通过构造方法可以设置猫的这三个属性。//②公有方法catchAnimal (void类型，方法参数为：一个Animal类型)，方法内部打印：[猫的名字]捉住了[动物的名字]。例如：小花猫捉住了老鼠。public class demo &#123;    public static void main(String[] args) &#123;        Animal mouse=new Animal(&quot;老鼠&quot;,999);        Cat cat =new Cat(&quot;汤姆猫&quot;,3,&quot;蓝色&quot;);        cat.catchAnimal(mouse);    &#125;&#125;  class Animal&#123;    public String name;    public int age;    public Animal(String name1, int age1) &#123;        this.name = name1;        this.age = age1;    &#125;    void eat(String s)&#123;        System.out.println(s);    &#125;    void move()&#123;        System.out.println(&quot;呼..呼..&quot;);    &#125;&#125;class Cat extends Animal&#123;    public String color;    public Cat(String name, int age,String color) &#123;        super(name, age);        this.color=color;    &#125;    public void catchAnimal(Animal A)&#123;        System.out.println(this.name+&quot;捉住了&quot;+A.name);    &#125;&#125;\n\n\n\n6、形状的抽象类//2.编写程序，实现以下功能：//（1）定义一个形状的抽象类：Shape，包含两个抽象方法：//①getArea：获取形状的面积；//② getPerimeter：获取形状的周长；//（2）再定义两个子类-圆形类和矩形类：Circle和Rectangle，分别继承自Shape类。//① Circle类中需要包含一个私有变量-半径radius和一个构造方法，// 构造方法带有一个参数radius，通过构造方法可以设置矩形的半径；并且需要实现getArea和getPerimeter方法分别获取圆形的面积和周长。//② Rectangle类中需要包含两个私有变量-长度length和宽度width；// 以及构造方法，构造方法带有两个参数length和width，通过构造方法可以设置矩形的长和宽；并且需要实现getArea和getPerimeter方法分别获取矩形的面积和周长。//3.最后，编写一个测试类Test，在main方法中创建一个Circle和一个Rectangle对象，并分别调用它们的getArea和getPerimeter方法，打印它们的面积和周长。public class Test &#123;    public static void main(String[] args) &#123;    Circle Y=new Circle(5);        System.out.println(&quot;圆的面积为&quot;+Y.getArea()+&quot;,周长为&quot;+Y.getPerimeter());    Rectangle J=new Rectangle(4,3);        System.out.println(&quot;矩形的面积为:&quot;+J.getArea()+&quot;,周长为:&quot;+J.getPerimeter());    &#125;&#125;abstract class Shape&#123;    public abstract double getArea();    public abstract double getPerimeter();&#125;class Circle extends Shape&#123;    private double radius;    final public  double PI=3.1415926;    Circle(double radius)&#123;        this.radius=radius;    &#125;    public double getArea() &#123;        return Math.pow(this.radius,2)*PI;    &#125;    public double getPerimeter() &#123;        return 2*radius*PI;    &#125;&#125;class Rectangle extends Shape&#123;    private double length,width;    Rectangle(double length,double width)&#123;        this.length=length;        this.width=width;    &#125;    public double getArea() &#123;        return this.length*this.width;    &#125;    public double getPerimeter() &#123;        return (this.length+this.width)*2;    &#125;&#125;\n\n\n\n7 、声音模拟器import java.lang.*;//3.编写Java程序，完成如下功能：//设计一个声音模拟器，希望模拟器可以模拟出喜多动物的叫声，要求如下：//编写接口Animal。Animal接口有两个抽象方法cry()和getAnimalName()，即要求，实现该接口的各种具体动物类给出自己的叫声和种类名称。//设计一个动物声音模拟器,希望模拟器可以模拟许多动物的叫声,要求如下://(1)编写接口Animal。Animal接口有两个抽象方法cry()和 getAnimalName(),即要求实现该接口的各种具体动物类给出自己的叫声和种类名称。//(2)编写模拟器类Simulator。该类有一个 playSound(Animal animal)方法,该方法的参数是 Animal类型,// 即参数animal可以调用实现Animal接口类重写的cry()方法播放具体动物的声音,调用重写的getAnimalName()方法显示动物种类的名称。//(3)编写实现Animal接口的 Dog类和Cat类。public class demo &#123;    public static void main(String[] args) &#123;        Cat mao=new Cat();        Dog dog=new Dog();        Simulator s=new Simulator();        s.playSound(mao);        s.playSound(dog);    &#125;&#125;interface Animal&#123;    public abstract void cry();    public abstract String getAnimalName();&#125;class Simulator&#123;    void playSound(Animal animal)&#123;        System.out.printf(animal.getAnimalName()+&quot;的叫声是&quot;);        animal.cry();    &#125;&#125;class Dog implements Animal&#123;    public void cry() &#123;        System.out.println(&quot;汪汪！&quot;);    &#125;    public String getAnimalName() &#123;        return (String)&quot;狗&quot;;    &#125;&#125;class Cat implements Animal&#123;    public void cry() &#123;        System.out.println(&quot;喵呜~&quot;);    &#125;    public String getAnimalName() &#123;        return (String)&quot;猫&quot;;    &#125;&#125;\n\n\n\n8、银行Bank//4.假设银行Bank已有了按整年计算利息的一般方法，其中year只能取整数，利率计算规则为：存款数*年数*利率。//建设银行（ConstructionBank）和中国银行（ChinaBank）都是银行的子类，准备隐藏继承的成员变量year// 并重写计算利息的方法，即自己声明一个double类型的year变量，比如当year取值为5.216时，表示要计算5年零216天的利息// 但希望首先按照银行Bank的方法computerInterest()计算出5整年的利息，然后再自己计算216天的利息，// 那么，建设银行就必须把5.216的整数部分赋给隐藏的year，并让super调用隐藏的，按整年计算利息的方法。//分别创建ConstructionBank类和ChinaBank类继承Bank类，子类重写父类的computerInterest()方法，// 创建主类SaveMoney，在主类中创建ConstructionBank和ChinaBa=nk对象，初始化存款数为10000// 存款时间为3.216年（3年零216天）、建设银行年利率为2.8%，日利率为0.002%，// 中国银行年利率为2.9%，日利率为0.0015%，输出两家银行的利息，输出格式为：//%d元存在建设银行%d年零%d天的利息为%f元\\n//%d元存在中国银行%d年零%d天的利息为%f元\\n//如：//10000元存在建设银行3年零216天的利息为883.2元//10000元存在中国银行3年零216天的利息为902.4元public class SaveMoney &#123;    public static void main(String[] args) &#123;        ConstructionBank JS = new ConstructionBank(10000,3.216,0.028,0.00002);        ChinaBank ZH = new ChinaBank(10000,3.216,0.029,0.000015);        System.out.printf(&quot;%d元存在建设银行%d年零%d天的利息为%f元\\n&quot;,JS.saveMoney,(int)Math.floor(JS.year),(int)(1000*(JS.year-Math.floor(JS.year))),JS.computerInterest());        System.out.printf(&quot;%d元存在中国银行%d年零%d天的利息为%f元\\n&quot;,ZH.saveMoney,(int)Math.floor(ZH.year),(int)(1000*(ZH.year-Math.floor(ZH.year))),ZH.computerInterest());    &#125;&#125;class Bank&#123;    int saveMoney;    int year;    double Interest;    double InterestRate;    double ComputerInterest()&#123;        return saveMoney*year*Interest;    &#125;    void SetInterestRate(double interest) &#123;        this.Interest=interest;    &#125;&#125;class ConstructionBank extends Bank&#123;    double year;    public ConstructionBank(int saveMoney,double year,double interest, double interestRate) &#123;        this.saveMoney=saveMoney;        this.Interest=interest;        this.InterestRate=interestRate;        this.year = year;    &#125;    double computerInterest()&#123;        super.year=(int)Math.floor(year);        return super.ComputerInterest()+saveMoney*1000*(year-Math.floor(year))*InterestRate;    &#125;&#125;class ChinaBank extends Bank&#123;    double year;    public ChinaBank(int saveMoney, double year, double interest, double interestRate) &#123;        this.saveMoney=saveMoney;        this.Interest=interest;        this.InterestRate=interestRate;        this.year = year;    &#125;    double computerInterest()&#123;        super.year=(int)Math.floor(year);        return super.ComputerInterest()+saveMoney*1000*(year-Math.floor(year))*InterestRate;    &#125;&#125;\n\n9、公司的雇员//1. 某公司的雇员分为以下若干类：//(1) Employee：这是所有员工总的父类。//① 属性：员工的姓名,员工的生日月份//② 方法：getSalary(int month) 根据参数月份来确定工资，如果该月员工过生日，则公司会额外奖励100 元。//(2) SalariedEmployee：Employee 的子类，拿固定工资的员工。//① 属性：月薪。//(3)HourlyEmployee：Employee 的子类，按小时拿工资的员工，每月工作超出160小时的部分按照1.5 倍工资发放。//① 属性：每小时的工资、每月工作的小时数。//(4) SalesEmployee：Employee 的子类，销售，工资由月销售额和提成率决定。//① 属性：月销售额、提成率。//(5) BasePlusSalesEmployee：SalesEmployee 的子类，有固定底薪的销售人员，工资由底薪加上销售提成部分。//① 属性：底薪、提成。//要求：//创建一个Employee 数组，分别创建若干不同的Employee对象放入Employee 数组中，初始化// 张三为SalariedEmployee类型员工月薪为4000元，生日为5月份；// 李四为HourlyEmployee类型员工，生日为6月份，每小时工资25元，当月工作了200小时；// 王五为SalesEmployee类型员工，生日为7月份，底薪为2500，提成为3000，当前要发的是6月份工资，要求打印结果为：//张三6月份的工资为4000元//李四6月份的工资为5600元//王五6月份的工资为5500元。public class demo &#123;    public static void main(String[] args) &#123;        Employee[] employees=new Employee[3];        employees[0]=new SalariedEmployee(&quot;张三&quot;,5,4000);        employees[1]=new HourlyEmployee(&quot;李四&quot;,6,25,200);        employees[2]=new BasePlusSalesEmployee(&quot;王五&quot;,7,2500,3000);        for(int i=0;i&lt;3;i++)&#123;            System.out.printf(&quot;%s6月份的工资为%.0f元\\n&quot;,employees[i].name,employees[i].getSalary(6));        &#125;    &#125;&#125;abstract class Employee&#123;    String name;    int birth;    public abstract double getSalary(int month);&#125;class SalariedEmployee extends Employee&#123;    double Monthly;    public SalariedEmployee(String name,int birth,double monthly) &#123;        this.name=name;        this.birth=birth;        Monthly = monthly;    &#125;    public double getSalary(int month) &#123;        if (month==birth)            return Monthly+100;        else            return Monthly;    &#125;&#125;class HourlyEmployee extends Employee &#123;    double Hourly,hour;    public HourlyEmployee(String name,int birth,double hourly, double hour) &#123;        this.name=name;        this.birth=birth;        Hourly = hourly;        this.hour = hour;    &#125;    public double getSalary(int month) &#123;        if(hour&lt;=160)&#123;            if(month==birth)                return hour*Hourly+100;            else return hour*Hourly;        &#125;        else&#123;            if(month==birth)                return (hour-160)*1.5*Hourly+160*Hourly+100;            else                return (hour-160)*1.5*Hourly+160*Hourly;        &#125;    &#125;&#125;class SalesEmployee extends Employee&#123;    double MonthlySales,RoyaltyRate;    public double getSalary(int month) &#123;        return MonthlySales*RoyaltyRate;    &#125;&#125;class BasePlusSalesEmployee extends SalesEmployee&#123;    double Monthly,Commission;    public BasePlusSalesEmployee(String name,int birth,double monthly,double commission) &#123;        this.name=name;        this.birth=birth;        Monthly=monthly;        Commission=commission;    &#125;    public double getSalary(int month) &#123;        if (month==birth)            return Monthly+Commission+100;        else            return Monthly+Commission;    &#125;&#125;\n\n\n\n10、控制台输入一个字符串s，请你反转字符串中单词的顺序import java.util.Scanner;public class  ReverseStr &#123;    public static void main(String[] args) &#123;        String s;        String regex = &quot;\\s+&quot;;        String[] a;        Scanner read=new Scanner(System.in);        s=read.nextLine();        a=s.split(regex);        for(int i=a.length-1;i&gt;=0;i--)&#123;            System.out.printf(&quot;%s &quot;,a[i]);        &#125;    &#125;&#125;\n\n\n\n11、产生10个1-100之间的随机整数输出import java.util.*;//1. 产生10个1-100之间的随机整数输出，// 并把这10个数按从小到大的顺序输出，程序文件命名为“RandomSort.java”。public class RandomSort &#123;    public static void main(String[] args) &#123;        Random random = new Random();        int[] a = new int[10];        for(int i=0;i&lt;10;i++)&#123;            a[i]= random.nextInt(90)+10;        &#125;        Arrays.sort(a);        for(int i=0;i&lt;10;i++)&#123;            System.out.printf(&quot;%d &quot;,a[i]);        &#125;    &#125;&#125;\n\n\n\n12、使用for循环语句计算5+55+555+5555+..//2. 编写应用程序，使用for循环语句// 计算5+55+555+5555+...的前10项之和,程序文件命名为“SequenceSum.java”。public class SequenceSum &#123;    public static void main(String[] args) &#123;        long sum=0;        for(int i=1;i&lt;=10;i++)&#123;            sum+=(long)((5.0/9.0)*Math.pow(10,i));        &#125;        System.out.println(&quot;5+55+555+5555+...的前10项之和为&quot;+sum);    &#125;&#125;\n\n\n\n13、输出满足1+2+3+…+n&gt;10000//3. 编写程序，输出// 满足1+2+3+...+n&gt;10000的最小正整数n,程序文件命名为“IntegerMin.java”。public class IntegerMin &#123;    public static void main(String[] args) &#123;        int sum=0;        int i=0;        while (sum&lt;10000)&#123;            sum+=++i;        &#125;        System.out.println(i);    &#125;&#125;\n\n\n\n14、创建一个桌子（Table）类package t14;//4.编写程序，实现以下功能：//创建一个桌子（Table）类，该类中有桌子名称（name）// 重量（weight）、桌面宽度（width）、长度（length）// 和桌子高度（height）属性以及以下几个方法：//（1）无参构造方法：默认值初始化所有成员变量；//（2）有参构造方法：根据参数初始化成员变量；//（3）area():计算桌面的面积；//（4）display():在屏幕上输出所有成员变量的值；//在测试（Test）类的main()方法中实现创建一个桌子对象，// 计算桌面的面积，改变桌子重量，并在屏幕上输出所有桌子属性的值。public class Test &#123;    public static void main(String[] args) &#123;        Table table=new Table();        System.out.println(table.name+&quot;的桌面面积为&quot;+table.area());        table.weight=6;        table.display();    &#125;&#125;class Table&#123;    String name;    double weight,width,lengeh,height;    public Table()&#123;        name = &quot;办公桌&quot;;        weight = 5;        width = 1.5;        lengeh =1.7;        height = 1.2;    &#125;    public Table(String name, double weight, double width, double lengeh, double height) &#123;        this.name = name;        this.weight = weight;        this.width = width;        this.lengeh = lengeh;        this.height = height;    &#125;    double area()&#123;        return width*lengeh;    &#125;    void display()&#123;        System.out.println(&quot;桌子名：&quot;+name);        System.out.println(&quot;桌子的重量：&quot;+weight);        System.out.println(&quot;桌面宽：&quot;+width);        System.out.println(&quot;桌面长：&quot;+lengeh);        System.out.println(&quot;桌子高：&quot;+height);    &#125;&#125;\n\n\n\n15、假定根据学生的3门学位课程的分数决定其是否可以拿到学位//编写程序，实现以下功能：//假定根据学生的3门学位课程的分数决定其是否可以拿到学位，// 对于本科生，如果3门课程的平均分数超过60分即表示通过，// 而对于研究生，则需要平均超过80分才能够通过。根据上述要求，// 请完成以下Java类的设计：//（1）设计一个基类Student描述学生的共同特征。//（2）设计一个描述本科生的类Undergraduate，该类继承并扩展Student类。//（3）设计一个描述研究生的类Graduate，该类继承并扩展Student类。//（4）设计一个测试类StudentText，分别创建本科生和研究生这两个类的对象，// 并输出相关信息(对应学生的姓名、平均分、是否可以拿到学位)，要求平均分保留2位小数。public class StudentText &#123;    public static void main(String[] args) &#123;        UnderGraduate A =new UnderGraduate(&quot;小明&quot;,99,80,55);        Graduate B =new Graduate(&quot;李华&quot;,60,99,86);        System.out.printf(&quot;本科生%s的平均分为%.2f,他&quot;,A.name,A.getAverage());        A.isPass();        System.out.printf(&quot;研究生%s的平均分为%.2f,他&quot;,B.name,B.getAverage());        B.isPass();    &#125;&#125;class Student&#123;    String name;    double courseA,courseB,courseC;    public Student(String name, double courseA, double courseB, double courseC) &#123;        this.name = name;        this.courseA = courseA;        this.courseB = courseB;        this.courseC = courseC;    &#125;    public String getName()&#123;        return name;    &#125;    public double getAverage()&#123;        return (courseA+courseB+courseC) /3;    &#125;&#125;class UnderGraduate extends Student&#123;    public UnderGraduate(String name, double courseA, double courseB, double courseC) &#123;        super(name, courseA, courseB, courseC);    &#125;    void isPass()&#123;        if(this.getAverage()&gt;=60)            System.out.print(&quot;可以拿到学位\\n&quot;);        else            System.out.print(&quot;不可以拿到学位\\n&quot;);    &#125;&#125;class Graduate extends Student&#123;    public Graduate(String name, double courseA, double courseB, double courseC) &#123;        super(name, courseA, courseB, courseC);    &#125;    void isPass()&#123;        if(this.getAverage()&gt;=80)            System.out.print(&quot;可以拿到学位\\n&quot;);        else            System.out.print(&quot;不可以拿到学位\\n&quot;);    &#125;&#125;\n\n\n\n16、设计一个计算柱体应用程序，希望该应用程序可以计算不同柱体的体积//6.编写程序，实现以下功能：//设计一个计算柱体应用程序，希望该应用程序可以计算不同柱体的体积，要求如下：//(1)  首先设计一个抽象类Geometry（几何图形）类，// 在该抽象类中定义一个抽象getArea()方法.//(2)  然后设计PillarL（柱体）类，// 该类的对象调用getVolume()方法计算柱体的体积，//(3)  分别设计Circle（圆）类和Rectangle（矩形）类// 和Triangle（三角形）类作为Geometry类的子类。//(4)  最后设计Application测试类分别求出圆柱的体积，// 四棱柱的体积，三棱柱的体积。//提示：三角形的面积可以由海伦公式计算。//海伦公式：如果一个三角形的三边长为a，b，c，设p=（a+b+c）/2public class Application &#123;    public static void main(String[] args) &#123;        Circle circle = new Circle(5);        Rectangle rectangle = new Rectangle(4,3);        Triangle triangle =new Triangle(3,4,5);        Pillar A = new Pillar(circle,5);        System.out.println(&quot;圆柱的体积为：&quot;+A.getVolmume());        A.bottom=rectangle;        System.out.println(&quot;四棱柱的体积为：&quot;+A.getVolmume());        A.bottom=triangle;        System.out.println(&quot;三棱柱的体积为：&quot;+A.getVolmume());    &#125;&#125;class Pillar&#123;    Geometry bottom;    double height;    public Pillar(Geometry bottom, double height) &#123;        this.bottom = bottom;        this.height = height;    &#125;    double getVolmume()&#123;        return bottom.getArea()*height;    &#125;&#125;abstract class Geometry&#123;    abstract double getArea();&#125;class Circle extends Geometry&#123;    double r;    final double PI = 3.1415926;    public Circle(double r) &#123;        this.r = r;    &#125;    double getArea() &#123;        return PI*Math.pow(r,2);    &#125;&#125;class Rectangle extends Geometry &#123;    double a,b;    public Rectangle(double a, double b) &#123;        this.a = a;        this.b = b;    &#125;    double getArea() &#123;        return a*b;    &#125;&#125;class Triangle extends Geometry&#123;    double a,b,c;    public Triangle(double a, double b, double c) &#123;        this.a = a;        this.b = b;        this.c = c;    &#125;    double getArea() &#123;        double p=(a+b+c)/2;        return Math.sqrt(p*(p-a)*(p-b)*(p-c));    &#125;&#125;\n\n\n\n17、设计一个应用程序，该应用程序用接口实现计算三个数的算术平均数和几何平均数//7.编写程序，实现以下功能：//设计一个应用程序，该应用程序用接口实现计算三个数的算术平均数和几何平均数，// 例如有两个数a,b,c其算术平均数为：（a+b+c）/3;// 其几何平均数为：\\sqrt[3]&#123;a\\ast b\\ast c&#125;。要求如下：// 设计一个接口（CompurerAverage），该接口有一个抽象方法average（）// 要求实现该接口的类完成平均数的计算。// 设计一个ArithmeticAverage类实现算术平均数的运算。// 设计一个GeometryAverage类实现几何平均数的运算。// 设计一个TestAverage测试类完成测试。public class TestAverage &#123;    public static void main(String[] args) &#123;        ArithmeticAverage A =new ArithmeticAverage(3.0,4.0,5.0);        GeometryAverage B =new GeometryAverage(3.0,4.0,5.0);        System.out.println(&quot;3,4,5的算数平均数为&quot;+A.average());        System.out.println(&quot;3,4,5的几何平均数为&quot;+B.average());    &#125;&#125;interface CompurerAverage&#123;    double average();&#125;class ArithmeticAverage implements CompurerAverage&#123;    double a,b,c;    public ArithmeticAverage(double a, double b, double c) &#123;        this.a = a;        this.b = b;        this.c = c;    &#125;    public double average() &#123;        return (a+b+c)/3;    &#125;&#125;class GeometryAverage implements CompurerAverage&#123;    double a,b,c;    public GeometryAverage(double a, double b, double c) &#123;        this.a = a;        this.b = b;        this.c = c;    &#125;    public double average() &#123;        return Math.pow(a*b*c,1.0/3.0);    &#125;&#125;   &#125;&#125;\n\n\n\n18、使用Scanner类的实例解析字符串import java.util.*;//8. 编写程序，实现以下功能：//使用Scanner类的实例解析字符串// “欢迎光临美好生活超市,你所买的苹果20.5元，梨20元,铅笔5.8元，香蕉30.5元，矿泉水20.8元。”// 中的金额，并计算出此次在超市中花费的总额。要求如下：//（1）设计一个givePriceSum类用于解析字符串中的金额。//（2）设计一个PriceSumTest测试类测试结果。public class PriceSumTest &#123;    public static void main(String[] args) &#123;        String cost = &quot;欢迎光临美好生活超市,你所买的苹果20.5元，梨20元,铅笔5.8元，香蕉30.5元，矿泉水20.8元。&quot;;        double priceSum = GetPrice.givePriceSum(cost);        System.out.printf(&quot;%s\\n你此次花费的金额为:%.2f元\\n&quot;,cost,priceSum);    &#125;&#125;class GetPrice &#123;    public static double givePriceSum(String cost) &#123;        Scanner scanner = new Scanner(cost);        scanner.useDelimiter(&quot;[^0-9.]+&quot;); //scanner设置分隔标记        double sum=0;        while(scanner.hasNext())&#123;            try&#123;  double price = scanner.nextDouble();                sum = sum+price;            &#125;            catch(InputMismatchException exp)&#123;                String t = scanner.next();            &#125;        &#125;        return sum;    &#125;&#125;\n\n\n\n19、使用文件字符输入和输出流将文件source File中的内容加到文件target File中public class Test &#123;    public static void main(String args[]) &#123;      File sourceFile = new File(&quot;D:\\\\myjavafile\\\\myProject\\\\myfile\\\\a.txt&quot;);  //读取的文件      File targetFile = new File(&quot;D:\\\\myjavafile\\\\myProject\\\\myfile\\\\b.txt&quot;);  //写入的文件      char c[] =new char[19];               //char型数组       try&#123;           Writer out = new FileWriter(targetFile,true); //指向目的地的输出流         Reader in  = new FileReader(sourceFile);   //指向源的输入流           int n = -1;         while((n=in.read(c))!=-1) &#123;             out.write(c,0,n);         &#125;         out.flush();         out.close();      &#125;      catch(IOException e) &#123;          System.out.println(&quot;Error &quot;+e);      &#125;  &#125;&#125;\n\n\n\n20、输入一行字符串，分别统计出其中英文字母、空格、数import java.util.*;//编程实现输入一行字符串，分别统计出其中// 英文字母、空格、数字和其它字符的个数。程序文件命名为“Counter.java”。public class Counter &#123;    public static void main(String[] args) &#123;        int zm=0,kg=0,sz=0,qt=0;        Scanner read=new Scanner(System.in);        String s = read.nextLine();        char[] a =s.toCharArray();        for(int i=0;i&lt;a.length;i++)&#123;            if ((a[i]&gt;=&#x27;a&#x27;&amp;&amp;a[i]&lt;=&#x27;z&#x27;)||(a[i]&gt;=&#x27;A&#x27; &amp;&amp; a[i]&lt;=&#x27;Z&#x27;))    zm++;            else if (a[i]&gt;=&#x27;0&#x27; &amp;&amp; a[i]&lt;=&#x27;9&#x27;)   sz++;            else if (a[i]==&#x27; &#x27;)  kg++;            else  qt++;        &#125;        System.out.println(&quot;字符串[&quot;+s+&quot;]中&quot;);        System.out.println(&quot;字母有&quot;+zm+&quot;个&quot;);        System.out.println(&quot;数字有&quot;+sz+&quot;个&quot;);        System.out.println(&quot;空格有&quot;+kg+&quot;个&quot;);        System.out.println(&quot;其他字符有&quot;+qt+&quot;个&quot;);    &#125;&#125;","categories":["编程"],"tags":["编程","JAVA"]},{"title":"YOLOv10初见","url":"/2025/10/09/YOLOv10%E5%88%9D%E8%A7%81/","content":"概述YOLOv10是清华大学研究人员在Ultralytics软件包基础上推出的最新一代实时目标检测算法。作为YOLO系列的重要革新，YOLOv10通过消除NMS后处理和全面优化模型架构，在保持实时性的同时实现了最先进的检测性能3,7。\n本文将深入解析YOLOv10的核心创新、架构设计和训练策略，帮助读者全面了解这一突破性技术的原理与优势。\n核心创新亮点1. 无NMS端到端检测传统YOLO版本依赖非极大值抑制（NMS）后处理来消除重复检测框，但这增加了计算开销和推理延迟。YOLOv10通过一致的双重标签分配策略，彻底摆脱了对NMS的依赖4,9。\n双重检测头设计：\n\n一对多头（One-to-Many Head）：训练时为每个真实框分配多个正样本，提供丰富的监督信号\n一对一头（One-to-One Head）：推理时为每个目标生成唯一预测框，实现端到端检测\n\n通过一致匹配度量（$ \\mathcal{M} &#x3D; p \\cdot \\text{IoU} \\cdot s $）协调两种策略，确保分类置信度、定位精度与空间先验的深度对齐9。\n2. 效率-精度驱动的模型设计YOLOv10从整体架构层面优化了计算效率与精度的平衡：\n轻量级组件设计：\n\n轻量级分类头：采用深度可分离卷积减少计算冗余\n空间-通道解耦下采样（SC-Down）：将空间缩减与通道调制解耦，最小化信息损失\n秩引导块设计：根据阶段冗余调整模块结构，优化参数利用4,7\n\n特征提取增强：\n\n大核卷积（7×7）：扩大感受野，增强上下文信息捕捉能力，尤其在轻量级变体中效果显著\n部分自注意力模块（PSA）：以最小开销改进全局表征学习2,3\n\n网络架构详解骨干网络（Backbone）YOLOv10采用增强版CSPNet作为骨干网络，引入动态稀疏卷积机制，通过动态激活区域选择减少冗余计算。结合大核深度卷积，在深层阶段扩大感受野，显著提升复杂场景下的特征捕捉能力9。\n颈部网络（Neck）传统的PANet被分阶段特征融合机制替代，通过可学习权重动态调整深浅特征的融合比例。在浅层侧重细节信息（如边缘），深层侧重语义信息（如类别），实现更高效的多尺度特征融合9。\n检测头（Head）双头设计是YOLOv10的核心创新：\n\n训练阶段：同时使用一对多头和一对一头，通过双重监督提高学习准确性\n推理阶段：仅使用一对一头，直接输出最终检测结果，无需NMS后处理4\n\n性能表现下表展示了YOLOv10各版本在COCO数据集上的性能对比7：\n\n\n\n模型变体\n输入尺寸\nAPval\n参数量\nFLOPs\n延迟\n\n\n\nYOLOv10-N\n640×640\n38.5%\n2.3M\n6.7G\n1.84ms\n\n\nYOLOv10-S\n640×640\n46.3%\n7.2M\n21.6G\n2.49ms\n\n\nYOLOv10-M\n640×640\n51.1%\n15.4M\n59.1G\n4.74ms\n\n\nYOLOv10-B\n640×640\n52.5%\n19.1M\n92.0G\n5.74ms\n\n\nYOLOv10-L\n640×640\n53.2%\n24.4M\n120.3G\n7.28ms\n\n\nYOLOv10-X\n640×640\n54.4%\n29.5M\n160.4G\n10.70ms\n\n\n性能优势：\n\n与YOLOv9相比，YOLOv10-B在相同性能下延迟减少46%，参数量减少25%9\nYOLOv10-S的速度是RT-DETR-R18的1.8倍，参数量和FLOPs减少2.8倍7\n\n训练策略与优化双重标签分配策略YOLOv10采用动态软匹配机制，根据训练阶段动态调整正负样本匹配策略：初期放宽IoU阈值加速收敛，后期收紧以提升精度。与YOLOv9的SimOTA相比，收敛速度加快20%，小目标漏检率降低15%9。\n损失函数设计复合损失函数融合了：\n\nPowerful-IoU：改进版CIoU，强化定位精度\nSlideLoss：动态平衡样本分布\n\n在COCO数据集上，该组合使定位误差降低12%，正负样本分类置信度方差缩小18%9。\n实际应用与部署边缘设备优化轻量化版本YOLOv10-N仅2.3M参数，在树莓派4B上实现45 FPS检测速度，mAP达39.5%。与YOLOv5-N相比，参数量减少60%，速度提升30%9。\n多任务支持YOLOv10支持目标检测、实例分割与关键点检测的多任务联合学习。在Cityscapes数据集上，多任务联合训练使mAP（检测）与mIoU（分割）分别达到68.2%和63.5%，较独立训练提升5.7%和4.1%9。\n总结与展望YOLOv10通过无NMS端到端检测、双重标签分配策略和全局效率-精度优化，重新定义了实时目标检测的性能边界。其在COCO数据集上的mAP突破54.4%，同时保持120 FPS的推理速度，实现了精度与效率的双重超越9。\n随着自动驾驶、工业质检和智能监控等应用对实时性要求的不断提高，YOLOv10的创新设计为边缘计算场景下的高效目标检测提供了新的解决方案。其端到端的架构不仅简化了部署流程，更为未来实时视觉系统的发展指明了方向。\n\n参考资料：YOLOv10论文源码及预训练模型可在官方GitHub仓库获取：https://github.com/THU-MIG/yolov10\n\n","categories":["深度学习"],"tags":["目标检测","YOLO"]},{"title":"YOLOv10原理浅学","url":"/2025/10/09/YOLOv10%E5%8E%9F%E7%90%86%E6%B5%85%E5%AD%A6/","content":"神经网络常用\nYOLO（You Only Look Once）：\nYOLO 是一种实时目标检测系统，通过单个神经网络预测目标边界框和类别。\n网络结构借鉴了 GoogLeNet，包含 24 个卷积层和 2 个全连接层。\nYOLO 将输入图片分割成 S×S 网格，每个单元格负责检测中心点落在该格子内的目标。\n预测过程是 end-to-end 的，将图片 resize 到 448x448 大小，送入 CNN 网络，最后进行非极大值抑制处理得到结果12。\n\n\n其他神经网络\n多层感知器 (MLP)：拥有一个或多个隐藏层，可以学习非线性函数。\n前馈神经网络：信息从输入层传递到输出层，只有前向传播，没有反向传播或循环。\n反馈神经网络：具有循环连接，例如循环神经网络 (RNN) 和长短时记忆网络 (LSTM)3456.\n\n\n\n制作神经网路：\n从零开始手写神经网络\n如果你想深入了解神经网络的底层原理，可以从零开始手写一个简单的多层感知机（Multilayer Perceptron，MLP）。\n这个过程涉及到定义神经网络的结构、实现前向传播和反向传播，以及使用梯度下降算法进行训练。\n你可以使用Python和NumPy库来实现这个过程，从而更好地理解神经网络的工作原理1.\n\n\n使用深度学习框架：\n如果你想更快地构建神经网络，可以使用流行的深度学习框架，例如TensorFlow或PyTorch。\n这些框架提供了高级API，可以简化神经网络的搭建、训练和评估过程。\n例如，你可以使用TensorFlow的tf.keras模块来加载MNIST手写数字数据集，并构建一个数字识别神经网络2.\n\n\n\n全向神经网路全连接神经网络（Fully Connected Neural Network，简称FCNN）是一种基础的人工神经网络结构，其中每个神经元与前一层和后一层的所有神经元相连接。本文将详细介绍全连接神经网络的基本原理、网络结构以及实际应用场景，帮助读者深入理解全连接神经网络。\n一、什么是全连接神经网络（FCNN）全连接神经网络（Fully Connected Neural Network，简称FCNN）是一种最基础的人工神经网络结构，也称为多层感知器（Multilayer Perceptron，MLP）。在全连接神经网络中，每个神经元都与前一层和后一层的所有神经元相连接，形成一个密集的连接结构。全连接神经网络能够学习输入数据的复杂特征，并进行分类、回归等任务。\n二、全连接神经网络的结构\n输入层：输入层负责接收原始数据，并将其传递给下一层。输入层的神经元数量取决于输入数据的维度。\n隐藏层：隐藏层是全连接神经网络中的中间层，可以有多个。隐藏层的神经元数量可以自由设定，每个神经元都与前一层和后一层的所有神经元相连接。\n输出层：输出层是全连接神经网络的最后一层，负责输出网络的预测结果。输出层的神经元数量取决于任务的类型，例如二分类任务的输出层通常有一个神经元，多分类任务的输出层有多个神经元。\n激活函数：激活函数用于引入非线性因素，使得神经网络能够拟合复杂的非线性关系。常见的激活函数有ReLU、Sigmoid、Tanh等。\n\n三、全连接神经网络的应用场景\n图像分类：全连接神经网络可以用于图像分类任务，通过学习图像的特征进行类别判断。\n文本分类：全连接神经网络也可以应用于自然语言处理任务，例如文本分类、情感分析等。\n回归预测：全连接神经网络可以用于回归任务，例如房价预测、股票价格预测等。\n\n四、总结全连接神经网络是人工神经网络中的一种基础结构，具有灵活的网络结构和广泛的应用场景。虽然全连接神经网络在某些复杂数字信号处理任务上可能不如卷积神经网络（CNN）和循环神经网络（RNN）表现出色，但它仍然是深度学习领域的基础知识之一，值得深入学习和掌握。\n​      \nYolo概述1. YOLOv10项目:\n论文：YOLOv10\n代码：GitHub - THU-MIG&#x2F;yolov10\n\n2. 改进和优化:\n无NMS训练：YOLOv10采用了持续双重分配，避免了后处理的非最大抑制（NMS），从而降低了推理延迟。\n效率驱动的模型设计：YOLOv10对组件进行了全面优化，包括轻量级分类头、空间-通道解耦下采样和基于rank引导的模块设计。\n基于精度的模型设计：使用大核卷积和部分自注意力（PSA）来提高感受野和模型能力。\n\n3. 性能和效率:\n在COCO数据集上，YOLOv10在各种模型规模上实现了最先进的性能和效率。\n例如，YOLOV10-S相比RT-DETR-R18快1.8倍，同时具有2.8倍更少的参数和FLOPS。\n\nYolo原理1. 网络结构：\nYOLOv10 的网络结构与 YOLOv8 相似，但在一些细节模块上有所改进。它包括以下部分：\nBackbone：用于特征提取的骨干网络。\nHead：负责预测目标框和类别得分。\n\n\nYOLOv10m 模型的结构稍有不同，不同尺度的模型在结构上也有所区别。\n\n2. 预测后处理：\nYOLOv10 在预测阶段不需要使用非极大值抑制（NMS）来去除重叠的框。这一功能是通过训练来实现的。\n网络实际上包含两个 Head：One-to-many Head 和 One-to-one Head。在训练时，两个 Head 同时参与，而在推理预测时只需要 One-to-one Head。\n后处理流程如下：\n首先，根据每个 Anchor 最高的分类得分，对 Anchor 进行排序，取前 max_det&#x3D;300 个 Anchor。\n然后，对这 300 个 Anchor 的 80 类分类得分再做一次排序，取前 max_det&#x3D;300 个。\n这个过程相当于直接将所有得分较高的 300 个结果作为检测结果，但由于使用 Sigmoid 而非 Softmax 计算得分，可能会得到两个 Anchor 相同位置大小但类别不同的框。\n\n\n\n3. 训练策略：\nYOLOv10 在训练中对 One-to-many Head 和 One-to-one Head 两个头的输出都计算损失，损失函数与 YOLOv8 相同。\n通过消除 NMS 并优化模型组件，YOLOv10 在降低计算开销的同时实现了最先进的性能12。\n\nYolo简易理论理解YOLO（You Only Look Once）是一种用于实时物体检测的算法，它可以在单次前向传播中完成物体检测任务。为了通俗易懂地解释YOLO的算法原理，可以将其分解为以下几个关键步骤：\n1. 输入图像YOLO从一张输入图像开始，假设这是一张包含多个物体的图片。\n2. 划分网格YOLO将输入图像划分为一个SxS的网格。例如，如果S&#x3D;7，那么图像会被划分成49个小方格。\n3. 每个网格预测对于每个网格单元，YOLO会预测：\n\nB个边界框（Bounding Boxes），每个边界框包含：\n位置（x, y）：框的中心相对于网格单元的位置\n宽度和高度（w, h）：框的尺寸，相对于整张图像的比例\n置信度（Confidence）：表示该框中是否包含物体以及框的准确程度\n\n\nC个类别概率（Class Probabilities），表示该网格单元包含的物体属于每个类别的概率。\n\n4. 计算最终预测每个网格单元的预测结果组合起来，形成最终的物体检测结果。YOLO会根据置信度和类别概率，筛选出最可能的物体边界框。\n5. 非极大值抑制（NMS）为了避免多个边界框重叠检测同一个物体，YOLO使用非极大值抑制来过滤掉置信度较低的重复检测框，只保留最有可能的边界框。\n6. 输出结果最终，YOLO输出的是图像中所有检测到的物体的边界框及其类别标签。\n例子：假设有一张图片，其中有一只猫和一只狗。YOLO会将这张图片划分成多个小网格。每个网格会预测多个边界框以及这些边界框中是否包含物体和物体的类别。经过置信度筛选和非极大值抑制，YOLO最终可能会输出两个边界框，一个框住猫并标记为“猫”，另一个框住狗并标记为“狗”。\n通过这种方式，YOLO能够高效地进行实时物体检测。由于它只需要一次前向传播就能完成整个检测过程，所以被称为“只看一次”（You Only Look Once）。\n","categories":["深度学习"],"tags":["目标检测","YOLO"]},{"title":"Python的100个代码示例","url":"/2025/10/12/Python%E7%9A%84100%E4%B8%AA%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/","content":"1. 生成6位数字随机验证码import randomimport stringdef num_code(length=6):    &quot;&quot;&quot;    生成长度为length的数字随机验证码    :param length: 验证码长度    :return: 验证码    &quot;&quot;&quot;        return &#x27;&#x27;.join(random.choice(string.digits) for i in range(0, length))\n\n2.md5加密import  hashlib# md5加密def md5_encrypt(en_str):    &quot;&quot;&quot;    使用md5二次加密生成32位的字符串    :param en_str: 需要加密的字符串    :return: 加密后的字符串    &quot;&quot;&quot;       md5 = hashlib.md5()  # 使用MD5加密模式    md5.update(en_str.encode(&#x27;utf-8&#x27;))  # 将参数字符串传入    md5.update(md5.hexdigest().encode(&#x27;utf-8&#x27;))  # md5二次加密    return md5.hexdigest()\n\n3. 生成唯一tokenimport uuid\nimport  hashlib\n\ndef only_token():\n    &quot;&quot;&quot;\n    使用md5加密uuid生成唯一的32位token\n    :return: 加密后的字符串\n    &quot;&quot;&quot;\nmd5 = hashlib.md5()  # 使用MD5加密模式\nmd5.update(str(uuid.uuid1()).encode(&#39;utf-8&#39;))  \nreturn md5.hexdigest()\n\n4、发送手机验证码#验证码管理表class AuthCode(models.Model):    name = models.CharField(max_length=10,default=None, null=True, blank=True,verbose_name=&#x27;姓名&#x27;)    phone = models.CharField(max_length=11, unique=True, verbose_name=&#x27;手机号&#x27;)    code = models.CharField(max_length=6,verbose_name=&#x27;验证码&#x27;)    purpose = models.IntegerField(default=0,verbose_name=&#x27;用途:0-&gt;注册验证 1-&gt;找回密码 2-&gt;其它&#x27;)    sendNum = models.IntegerField(default=0,verbose_name=&#x27;发送次数&#x27;)    isCanGet = models.BooleanField(default=0,verbose_name=&#x27;0-&gt;可以获取,1-&gt;不可以获取&#x27;)    recentlySendTime = models.DateTimeField(auto_now_add=True,verbose_name=&#x27;最近一次发送时间&#x27;)    creation_time = models.DateTimeField(auto_now=True, verbose_name=&#x27;创建时间&#x27;)    class Meta:        verbose_name = &#x27;手机验证码&#x27;        verbose_name_plural = verbose_name\n\n实现逻辑import http.clientimport urllib# 使用互亿无线host = &quot;106.ihuyi.com&quot;sms_send_uri = &quot;/webservice/sms.php?method=Submit&quot;# 查看用户名 登录用户中心-&gt;验证码通知短信&gt;产品总览-&gt;API接口信息-&gt;APIIDaccount = &quot;你的用户名&quot;# 查看密码 登录用户中心-&gt;验证码通知短信&gt;产品总览-&gt;API接口信息-&gt;APIKEYpassword = &quot;你的密码&quot;def send_sms(text, mobile):    text = f&quot;您的验证码是：&#123;text&#125;。请不要把验证码泄露给其他人。&quot;    params = urllib.parse.urlencode(        &#123;&#x27;account&#x27;: account, &#x27;password&#x27;: password, &#x27;content&#x27;: text, &#x27;mobile&#x27;: mobile, &#x27;format&#x27;: &#x27;json&#x27;&#125;)    headers = &#123;&quot;Content-type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;Accept&quot;: &quot;text/plain&quot;&#125;    conn = http.client.HTTPConnection(host, port=80, timeout=30)    conn.request(&quot;POST&quot;, sms_send_uri, params, headers)    response = conn.getresponse()    response_str = response.read()    conn.close()    return response_strif __name__ == &#x27;__main__&#x27;:    mobile = &quot;手机号&quot;    text = &#x27;123122&#x27;    print(json.loads(send_sms(text, mobile).decode(&#x27;utf-8&#x27;)))\n\n5、生成二维码import qrcodeimport iodef maker_qrcode(url):    &quot;&quot;&quot;    生成二维码    :param url: 需要生成二维码的url    :return: 返回图片字节流    &quot;&quot;&quot;    image = qrcode.make(url)  # 创建二维码片    buffer = io.BytesIO()    # 将图片内容丢入容器    image.save(buffer, &#x27;png&#x27;)    # 返回容器内的字节    return buffer.getvalue()    或者from .settings import BASE_DIRdef create_qrcode(name, url):    &quot;&quot;&quot;    生成机器扫码支付二维码    :param name: 图片名称    :param url: 支付路由    :return:    &quot;&quot;&quot;    img = qrcode.make(url, border=0)  # 创建二维码片    save_path = BASE_DIR + &#x27;/&#x27; + name + &#x27;.png&#x27;    print(save_path)    img.save(save_path)    return img\n\n6.微信群发# coding=utf8import itchat, timeitchat.auto_login(True)SINCERE_WISH = u&#x27;祝%s新年快乐！&#x27;friendList = itchat.get_friends(update=True)[35:]count = 0for  index,friend in enumerate(friendList):    print(index,friend[&#x27;DisplayName&#x27;],friend[&#x27;NickName&#x27;])    itchat.send(SINCERE_WISH % (friend[&#x27;DisplayName&#x27;]                                or friend[&#x27;NickName&#x27;]), friend[&#x27;UserName&#x27;])    time.sleep(2)    print(&#x27;备注名称&#x27;,friend[&#x27;DisplayName&#x27;],&#x27;昵称&#x27;,friend[&#x27;NickName&#x27;],&#x27;用户名&#x27;,friend[&#x27;UserName&#x27;])print(&quot;----end----&quot;)&quot;&quot;&quot;# 发送文本itchat.send(&#x27;Hello, WeChat!&#x27;)# 发送图片itchat.send_image(&#x27;my_picture.png&#x27;)# 发送视频itchat.send_video(&#x27;my_video.mov&#x27;)# 发送文件itchat.send_file(&#x27;my_file.zip&#x27;)&quot;&quot;&quot;\n\n7、微信自动回复# -*- coding=utf-8 -*-import requestsimport itchatimport random#图灵机器人#http://www.tuling123.com/member/robot/1380138/center/frame.jhtml?page=0&amp;child=0获取apikeyKEY = &#x27;你的KEY&#x27;def get_response(msg):    apiUrl = &#x27;http://www.tuling123.com/openapi/api&#x27;    data = &#123;        &#x27;key&#x27;    : KEY,        &#x27;info&#x27;   : msg,        &#x27;userid&#x27; : &#x27;wechat-robot&#x27;,    &#125;    try:        r = requests.post(apiUrl, data=data).json()        return r.get(&#x27;text&#x27;)    except:        return@itchat.msg_register(itchat.content.TEXT)def tuling_reply(msg):    defaultReply = &#x27;I received: &#x27; + msg[&#x27;Text&#x27;]    robots=[&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;]    reply = get_response(msg[&#x27;Text&#x27;])+random.choice(robots)    return reply or defaultReplyitchat.auto_login(enableCmdQR=False)itchat.run()\n\n8、提取Django中model中的字段名变成字典、列表import ret = &quot;&quot;&quot;    goods_id = models.IntegerField(verbose_name=&#x27;商品编号&#x27;)    label_code = models.CharField(max_length=20, verbose_name=&#x27;商品标签&#x27;)&quot;&quot;&quot;# 字典print(&#123;k:None for k in re.findall(&#x27;([a-z_A-Z]+)\\s=\\s&#x27;,t)&#125;)# 列表# print([k for k in re.findall(&#x27;([a-z_A-Z]+)\\s=\\s&#x27;,t)])输出&#123;&#x27;goods_id&#x27;: None, &#x27;lable_code&#x27;: None&#125;\n\n9、数据库中给表创建数据import pymysqldef createData(dataDict,tableName):    &quot;&quot;&quot;    给数据表创建数据    :param dataDict: 字典    :param tableName: 表名    :return:     &quot;&quot;&quot;    #连接数据库    conn = pymysql.connect(        host=&#x27;192.168.0.188&#x27;, #数据库所在地址URL        user=&#x27;root&#x27;, #用户名        password=&#x27;123456&#x27;, #密码        database=&#x27;名称&#x27;, #数据库名称        port=3306,  #端口号        charset=&#x27;utf8&#x27;    )    #拿到查询游标    cursor = conn.cursor()    clos,value = zip(*dataDict.items())    sql = &quot;INSERT INTO `%s`(%s) VALUES (%s)&quot; % (tableName,                                                &#x27;,&#x27;.join(clos),                                                &#x27;,&#x27;.join([&#x27;%s&#x27;] * len(value))                                                )    print(sql)    cursor.execute(sql, value)    conn.commit()    cursor.close()    conn.close()    print(&#x27;Done&#x27;)\n\n10.捕捉异常try:    passexcept 异常类型 as e:    passfinally:    pass        异常类型Exception  全部异常AttributeError 试图访问一个对象没有的属性，比如foo.x，但是foo没有属性xIOError 输入/输出异常；基本上是无法打开文件ImportError 无法引入模块或包；基本上是路径问题或名称错误IndentationError 语法错误（的子类） ；代码没有正确对齐IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5]KeyError 试图访问字典里不存在的键KeyboardInterrupt Ctrl+C被按下NameError 使用一个还未被赋予对象的变量SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）TypeError 传入对象类型与要求的不符合UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，导致你以为正在访问它ValueError 传入一个调用者不期望的值，即使值的类型是正确的\n\n11、获取当前时间import datetimecurrent_time = str(datetime.datetime.now())[:19]print(current_time)输出格式如：2018-10-20 10:01:43local_time = time.strftime(&#x27;%Y%m%d%H%M%S&#x27;, time.localtime(time.time()))print(local_time)\n\n12、订单编号from random import Randomimport timedef random_str(randomlength=8):    str = &#x27;&#x27;    chars = &#x27;AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0123456789&#x27;    length = len(chars) - 1    random = Random()    for i in range(randomlength):        str+=chars[random.randint(0, length)]    return strdef order_num():    &quot;&quot;&quot;    生成付款订单号    :return:    &quot;&quot;&quot;    local_time = time.strftime(&#x27;%Y%m%d%H%M%S&#x27;, time.localtime(time.time()))    result = local_time + random_str(5)    return resultprint(order_num())\n\n13、mysql自动填写当前时间CURRENT_TIMESTAMP\n\n\n为表添加索引ALTER table tableName ADD INDEX indexName(columnName)\n\n14、drf动态过滤查询# page.pyfrom rest_framework.pagination import PageNumberPaginationclass UserPagination(PageNumberPagination):    &quot;&quot;&quot;用户分页器&quot;&quot;&quot;    page_size = 10  # 默认的页面数据数量    page_query_param = &#x27;page&#x27;  # 定制取数据页码key     page_size_query_param = &#x27;page_size&#x27;  # 默认取数据页码key     max_page_size = 15   # 数据每页取值的最大上限# serializers.pyfrom rest_framework import serializersfrom user.models import UserInfoclass UserSerializers(serializers.ModelSerializer):    &quot;&quot;&quot;用户收货地址&quot;&quot;&quot;    class Meta:        model = UserInfo\t    # 所有字段        #fields = &#x27;__all__&#x27;        fields = [&#x27;name&#x27;, &#x27;code&#x27;, &#x27;title&#x27;,  &#x27;province&#x27;, &#x27;city&#x27;,                    &#x27;quxian&#x27;, &#x27;address&#x27;, &#x27;code__gte&#x27;, &#x27;code__lte&#x27;]        # 显示外键        depth = 2# views.pyclass MachineViews(APIView):    def get(self, request, *args, **kwargs):        # 从前端获取出来的过滤参数，解析成字典传进filter()函数中        # 动态过滤，        kwargs = &#123;&#125;        # 表中的字段名        columns = [&#x27;name&#x27;, &#x27;code&#x27;, &#x27;title&#x27;,  &#x27;province&#x27;, &#x27;city&#x27;,                    &#x27;quxian&#x27;, &#x27;address&#x27;, &#x27;code__gte&#x27;, &#x27;code__lte&#x27;]        for k, v in request.query_params.items():            if k not in columns:                return Response(&#x27;参数不对&#x27;, status=status.HTTP_400_BAD_REQUEST)\t\t\tif v:            \tkwargs[k] = v        users = UserInfo.objects.filter(**kwargs)        page = UserPagination()        page_goods_list = page.paginate_queryset(users, self.request, self)        ser = UserSerializers(page_goods_list, many=True)        return page.get_paginated_response(ser.data)        \n\n15、linux后台运行python程序nohup /home/project_venv/user/bin/python3 -u /home/user/user_server.py &gt;&gt; /home/user/user.log 2&gt;&amp;1 &amp;   \n\n16、追加外键ALTER TABLE tb_commentPhoto ADD CONSTRAINT FK_comment_phoneFOREIGN KEY tb_goodsComment(id) REFERENCES tb_commentPhoto(comment_id);\n\n17、写&#x2F;读CSV文件，查看是否存在，若存在就从csv中删除import csvimport randomimport stringdef create_invite_code(random_code_pool=None, length=6, num=10, is_append=False):    &quot;&quot;&quot;    创建随机邀请码,并写入txt文件    :param: random_code_pool 随机邀请码    :param: length 邀请码长度    :param: num 邀请码个数    :param: is_append True追加,False 覆盖    :return:    &quot;&quot;&quot;    if not random_code_pool:        code_pool = string.ascii_uppercase + string.digits        random_code_pool = []        for i in range(num):            s = &#x27;&#x27;            for _ in range(length):                s += random.choice(code_pool)            if s and s not in random_code_pool:                random_code_pool.append(s)    # 写入方法。是追加还是覆盖    write_method = &#x27;a+&#x27; if is_append else &#x27;w&#x27;    # 写入文件    with open(&#x27;./invite_code.csv&#x27;, write_method, newline=&#x27;&#x27;) as f:        writer = csv.writer(f)        for rowData in random_code_pool:            # 按行写入            writer.writerow((rowData,))def check_invite_code(code):    &quot;&quot;&quot;    查看邀请码是否存在txt文件中，    若存在就返回True，并在txt文件中删除    若不存在就返回False    :param code:    :return:    &quot;&quot;&quot;    code_pool = []    with open(&#x27;./invite_code.csv&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;,errors=&#x27;ignore&#x27;) as f:        allFileInfo = csv.reader(f)        for row in allFileInfo:            code_pool.append(row[0])    if code in code_pool:        # 删除查询的code        code_pool.pop(code_pool.index(code))        # 重新写入文件        create_invite_code(code_pool,is_append=False)        return True    return Falseif __name__ == &#x27;__main__&#x27;:    # create_invite_code(length=9,num=100)    print(check_invite_code(&#x27;WJ4PSTJG2&#x27;))\n\n18、django中从request获取访问路径print(&#x27;获取相对路径&#x27;, request.get_full_path())print(&#x27;获取绝对路径&#x27;, request.build_absolute_uri())print(request.build_absolute_uri(&#x27;?&#x27;))print(request.build_absolute_uri(&#x27;/&#x27;)[:-1].strip(&quot;/&quot;))print(request.build_absolute_uri(&#x27;/&#x27;).strip(&quot;/&quot;))print(request.build_absolute_uri(&#x27;/&#x27;))print(&#x27;----------&#x27;)print(request.META[&#x27;HTTP_HOST&#x27;])print(request.META[&#x27;PATH_INFO&#x27;])print(request.META[&#x27;QUERY_STRING&#x27;])iphost = request.META.get(&#x27;REMOTE_ADDR&#x27;, &#x27;&#x27;)  # 获取访问来源IP# 输出如：获取相对路径 /QRcode/?d=1获取绝对路径 http://127.0.0.1:8000/QRcode/?d=1http://127.0.0.1:8000/QRcode/http://127.0.0.1:8000http://127.0.0.1:8000http://127.0.0.1:8000/----------127.0.0.1:8000/QRcode/d=1\n\n19、Django收集静态文件先在项目根目录下创建一个static文件夹然后在settings.py中设置STATIC_ROOT = os.path.join(BASE_DIR, &#x27;static&#x27;)最后执行下面的命令：python manage.py collectstatic\n\n20、xadmin插件https://www.cnblogs.com/lanqie/p/8340215.html\n21、uwsgi自动重启[uwsgi]# 使用nginx连接时 使用socket=0.0.0.0:2019# 直接作为web服务器使用#http=0.0.0.1:8000# 配置工程目录chdir=/home/user# 配置项目的wsgi目录。相对于工程目录wsgi-file=user/wsgi.pyvirtualenv=/home/project_venv/user#配置进程，线程信息processes=1threads=1enable-threads=Truemaster=Truepidfile=uwsgi.piddaemonize=uwsgi.log#启动uwsgi的用户名和用户组uid=rootgid=root#uwsgi自动重启py-autoreload=1\n\n22、谷歌浏览器快捷键浏览器缓存Ctrl+Shift+Del  清除Google浏览器缓存的快捷键Ctrl+Shift+R  重新加载当前网页而不使用缓存内容\n\n23、git克隆分支git clone -b dev 地址 \n\n24、mysql更新语句、新增列、删除列update user set name=&#x27;张三&#x27; where id=111# 删除DELETE FROM table_name [WHERE Clause]# 增加字段alter table 表名 add column 列名 类型;# 删除字段alter table 表名 dropcolumn 列名 ;\n\n25、删除指定格式的文件import osimport redef remove_specified_format_file(file_dir, format_name):    &quot;&quot;&quot;    删除指定格式的文件    :param file_dir: 文件根目录    :param format_name: 格式    :return:    &quot;&quot;&quot;    for root, dirs, files in os.walk(file_dir):        # print(root) #当前目录路径        # print(dirs) #当前路径下所有子目录        # print(files) #当前路径下所有非目录子文件        for file in files:            if re.match(format_name, file):                print(os.path.join(root, file))                os.remove(os.path.join(root, file))remove_specified_format_file(r&#x27;D:\\学习\\LDC\\java&#x27;, r&#x27;\\._*&#x27;)\n\n26、计算文件总数import osdef file_count(file_dir):    &quot;&quot;&quot;        :param file_dir: 文件根目录    :return:    &quot;&quot;&quot;    count = 0    for root, dirs, files in os.walk(file_dir):        # print(root) #当前目录路径        # print(dirs) #当前路径下所有子目录        # print(files) #当前路径下所有非目录子文件        count += len(files)    return countprint(file_count(r&#x27;D:\\学习\\LDC\\java\\Java学习\\newEstore\\estore\\js&#x27;))\n\n27、计算文件夹大小import osdef file_size(file_dir):    &quot;&quot;&quot;    删除指定格式的文件    :param file_dir: 文件根目录    :return:    &quot;&quot;&quot;    size = 0    for root, dirs, files in os.walk(file_dir):        # print(root) #当前目录路径        # print(dirs) #当前路径下所有子目录        # print(files) #当前路径下所有非目录子文件        for file in files:            size += os.path.getsize(os.path.join(root, file))\t# M为单位    return size / 1024 / 1024file_name = r&#x27;D:\\学习&#x27;print(file_size(file_name))\n\n28、Django实现jsonp跨域# html$.ajax(&#123;                    url: &#x27;请求路由&#x27;,                    type: &#x27;GET&#x27;,                    dataType: &#x27;JSONP&#x27;,                    data:&#123;                      code: &#x27;yes&#x27;,                    &#125;,                    jsonp: &#x27;callback&#x27;,                    success: function(res) &#123;                       var selectData = $.parseJSON(res);                       alert(selectData);                    &#125;,                    error: function(err) &#123;                    &#125;                &#125;)# views.pydef get(self, request, *args, **kwargs):        code = request.GET.get(&#x27;code&#x27;, &#x27;&#x27;)        # 跨域请求        callback = request.GET.get(&#x27;callback&#x27;, &#x27;&#x27;)        return HttpResponse(&quot;%s(&#x27;%s&#x27;)&quot; % (callback, json.dumps(&#123;&#x27;code&#x27;: code&#125;)), status=status.HTTP_200_OK)                    cors解决跨域https://www.cnblogs.com/wxiaoyu/p/9578848.html\n\n29、微信获取用户信息参考：https://blog.csdn.net/weixin_39735923/article/details/79202563\n30、uwsgi初始配置问题https://blog.csdn.net/weixin_39735923/article/details/79202563\n31、django中drf序列化# 序列化器class MsgSerializers(serializers.ModelSerializer):    addtime = serializers.DateTimeField(read_only=True, format=&quot;%Y-%m-%d %H:%M:%S&quot;)    hasread = serializers.CharField(source=&#x27;get_hasread_display&#x27;)    msgtype = serializers.CharField(source=&#x27;get_msgtype_display&#x27;)    class Meta:        model = MallMsg        # 可以混合使用        fields = &#x27;__all__&#x27;  # &#x27;__all__&#x27; 所有字段        # 数据库层级控制（序列化链表操作）        # depth = 1  # 外键层级#分页器from rest_framework.pagination import PageNumberPaginationclass MyLimitOffsetPagination(PageNumberPagination):    page_size = 3  # 默认的页面数据数量    page_query_param = &#x27;page&#x27;  # 定制取数据页码key ？    page_size_query_param = &#x27;page_size&#x27;  # 默认取数据页码key &amp;    max_page_size = 15  # 数据每页取值的最大上限\n\n32、第三方库安装openssl pip3 install pyOpenSSL\n\n33、requests请求https携带CA证书import OpenSSLimport requestsimport urllib3.contrib.pyopensslurllib3.contrib.pyopenssl.inject_into_urllib3()def p12_to_pem(certname, pwd):    &quot;&quot;&quot;    从.p12文件中提取pem    :param certname:    :param pwd:    :return:    &quot;&quot;&quot;    pem_name = certname + &quot;.pem&quot;    f_pem = open(pem_name, &#x27;wb&#x27;)    p12file = certname + &quot;.p12&quot;    p12 = OpenSSL.crypto.load_pkcs12(open(p12file, &#x27;rb&#x27;).read(), pwd)    f_pem.write(OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, p12.get_privatekey()))    f_pem.write(OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, p12.get_certificate()))    ca = p12.get_ca_certificates()    if ca is not None:        for cert in ca:            f_pem.write(OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert))    f_pem.close()    return pem_namedef post_cert_request(url, data,header, certname, pwd):    &quot;&quot;&quot;    使用证书发起https请求    :param url:    :param data:    :param certname:    :param pwd:    :return:    &quot;&quot;&quot;    if (certname != &quot;&quot;):        cert = p12_to_pem(certname, pwd)    else:        cert = None    r = requests.post(url, header=header, data=data, cert=cert)    return r\n\n34、django创建缓存命令python manage.py createcachetable 缓存表名\n\n35、Django 更改超级用户密码在工程文件目录下敲入：python manage.py shell再在python交互界面输入：from django.contrib.auth.models import Useruser = User.objects.get(username = &#x27;用户名&#x27;)user.set_password(&#x27;密码&#x27;)user.save()\n\n36、restframe使用缓存https://blog.csdn.net/Odyssues_lee/article/details/80872586\n37、数据库select * from user  where ISNULL(code)update user set code=&#x27;111&#x27;,info=&#x27;微信&#x27; where ISNULL(code)\n\n38、linux常用命令tail -f 日志名  实时监控日志tail -f 80_v10.lognetstat -na|grep 80  查看端口tcp连接数netstat -na|grep 80 | wc -l 计算端口tcp连接数ps -ef|grep python  查看有多少python程序在运行gunzip 2015.csv.gz   # 解压unzip 19.zip # 解压zipwc -l 2015.csv   # 查看行数apt install lrzsz  # 安装sz 文件名  # 下载文件查找文件find / -name 文件名匹配执行过的以find为开头的命令history | grep find\n\n39、xadmin禁止增加、删除# models.py# 用户管理class UserManage(models.Model):    name = models.CharField(max_length=20, verbose_name=&#x27;用户名&#x27;)    phone = models.CharField(max_length=11, unique=True, verbose_name=&#x27;手机号&#x27;)    code = models.CharField(max_length=11, unique=True, verbose_name=&#x27;编号&#x27;)        user = models.ForeignKey(User, on_delete=models.CASCADE, editable=False, null=True, verbose_name=&#x27;管理员&#x27;)# adminx.py# 用户列表class UserAdmin(object):    list_display = [ &#x27;code&#x27;, &#x27;phone&#x27;, &#x27;name&#x27;,]    search_fields = [&#x27;code&#x27;, &#x27;phone&#x27;]    list_filter = [&#x27;code&#x27;, &#x27;phone&#x27;]    list_editable = [&#x27;name&#x27;]  # 数据即时编辑    readonly_fields = [&#x27;code&#x27;, &#x27;phone&#x27;, &#x27;name&#x27;]  # 只读字段，不能编辑    model_icon = &#x27;fa fa-square&#x27;    model = UserInfo        def has_delete_permission(self, *args, **kwargs):    \t# 禁止删除        if args:            return True        return False    \tdef has_add_permission(self,*args,**kwargs):\t\t# 禁止增加        return False            def save_models(self):    \t# 用户级别设置        self.new_obj.user = self.request.user        flag = self.org_obj is None and &#x27;create&#x27; or &#x27;change&#x27;        if flag == &#x27;create&#x27;:        \t# 对密码字段进行加密            self.new_obj.password = encrypt_oracle(self.new_obj.password)        elif flag == &#x27;change&#x27;:            if &#x27;password&#x27; in self.change_message():                self.new_obj.password = encrypt_oracle(self.new_obj.password)        else:        \tpass        super().save_models()xadmin.site.register(UserInfo, UserAdmin)\n\n40、时间格式字符串相减import datetimeimport timestart = str(datetime.datetime.now())[:19]time.sleep(60)end = str(datetime.datetime.now())[:19]print(start,end)link_start = datetime.datetime.strptime(start, &#x27;%Y-%m-%d %H:%M:%S&#x27;)link_end = datetime.datetime.strptime(end, &#x27;%Y-%m-%d %H:%M:%S&#x27;)link_min = round((link_end - link_start).seconds / 60, 2)print(link_min,&#x27;分钟&#x27;)\n\n41、显示循环进度条参考：https://blog.csdn.net/zejianli/article/details/77915751\nfrom tqdm import tqdm,trangefrom time import sleeptext = &quot;&quot;for char in tqdm([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]):    text = text + char    sleep(1)        # 方式二import timedef process_bar(percent, index, total,start_time, start_str=&#x27;&#x27;, end_str=&#x27;&#x27;, total_length=100):    # 进度条    percent_length = int(percent)    bar = &#x27;\\r&#x27; + start_str + (&#x27;\\033[1;31;41m \\033[0m&#x27; * percent_length + &#x27;\\033[1;37;47m \\033[0m&#x27; * (                total_length - percent_length)) + f&#x27;  &#123;round(index / total * 100, 2)&#125;%  &#x27; + f&#x27; &#123;index&#125;|&#123;end_str&#125;&#x27;+ f&#x27;   |已进行时间: &#123;round(time.time() - start_time, 2)&#125;秒&#x27;    print(bar, end=&#x27;&#x27;, flush=True)if __name__ == &#x27;__main__&#x27;:    data_set = [i for i in range(23)]    i = 0    start_time = time.time()    total = len(data_set)    end_str = &#x27;&#123;&#125;&#x27;.format(total)    for data in data_set:        time.sleep(1)        i += 1        process_bar(i * 100 / total, i, total, start_time, start_str=&#x27;&#x27;, end_str=end_str, total_length=100)# 方式三import sysimport timed = [i for i in range(100)]for i in range(len(d)):    time.sleep(1)    sys.stdout.write(&#x27;\\r&gt;&gt; Downloading  %.2f%%&#x27; % (float(i) / float(len(d)) * 100.0))sys.stdout.flush()\n\n42、把列表中的字典转成csv文件import pandas as pdlists = [&#123;&#x27;a&#x27;:1,&#x27;b&#x27;:2&#125;,&#123;&#x27;a&#x27;:2,&#x27;b&#x27;:3&#125;]df = pd.DataFrame(lists)print(df)df.to_csv(&#x27;result2.csv&#x27;)\n\n43、windows添加右键新建MarkDown文件在网上下载Typora软件安装后1、在桌面上新建一个txt文件，输入以下内容：\nWindows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\.md\\ShellNew]&quot;NullFile&quot;=&quot;&quot;&quot;FileName&quot;=&quot;template.md&quot;\n\n2、另存为，改后缀为.reg，保存类型为.txt，编码为Unicode\n\n3、双击运行，确定，重启电脑，此时在桌面右键就有了新建md文件\n44、redis设置值定时过期import datetimeimport redisredis_client = redis.Redis(    host=&#x27;127.0.0.1&#x27;,    port=6379,    db=0,    password=&#x27;123456&#x27;)def redis_set():    &quot;&quot;&quot;    redis设置值定时过期    :return:    &quot;&quot;&quot;    global redis_client    redis_client.set(&#x27;name&#x27;,&#x27;ldc&#x27;)    now = datetime.datetime.now()    # 设置‘name’50秒过期    expire_time = now + datetime.timedelta(hours=0, minutes=0, seconds=50)    redis_client.expireat(&#x27;name&#x27;, expire_time)if __name__ == &#x27;__main__&#x27;:    redis_set()\n\n45、linux根据端口杀进程import osdef killport(port):    command = &#x27;&#x27;&#x27;kill -9 $(netstat -nlp | grep :&#x27;&#x27;&#x27; + str(port) + &#x27;&#x27;&#x27; | awk &#x27;&#123;print $7&#125;&#x27; | awk -F&quot;/&quot; &#x27;&#123; print $1 &#125;&#x27;)&#x27;&#x27;&#x27;    os.system(command)# 开始执行if __name__ == &#x27;__main__&#x27;:    port = 4237    killport(port)\n\n46、监控linux网络流量iftop -n -N -i eth0nethogs eth0vim +/字符串 文件\n\n47、win10添加右键打开cmd通过添加注册表项实现\nwin + r 输入 regedit\n找到注册表位置：HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\\n右键“shel”l,新建“项”，命名为“以管理员身份打开cmd”，\n右键“以管理员身份打开cmd”，新建“DWORD(32位)值”，命名为”ShowBasedOnVelocityId”,值为“639bc8”\n右键“以管理员身份打开cmd”，新建“项”，命名为“command”\n右键“command”，点击“默认”，点击“修改”，填写数值为 cmd.exe &#x2F;s &#x2F;k pushd “%V”\n48、xadmin后台无法显示下拉框完整内容解决方案 在根目录中找到&#x2F;static&#x2F;xadmin&#x2F;vendor&#x2F;selectize&#x2F;selectize.bootstrap3.css在331行后加入 position: static;\n\n49、xadmin单点登录使用中间件实现。\n新建一个utils.py文件，存放以下代码：\nfrom django.contrib.sessions.models import Sessionfrom django.db.models import Qfrom django.utils import timezonefrom django.utils.deprecation import MiddlewareMixinclass XadminMiddleware(MiddlewareMixin):    def process_request(self, request):        &quot;&quot;&quot;xadmin后台单点登录&quot;&quot;&quot;        PATH_INFO = request.META.get(&#x27;PATH_INFO&#x27;, &#x27;&#x27;)        if PATH_INFO and &#x27;xadmin&#x27; in PATH_INFO:            request.session.clear_expired()   # 清除过期的key            session_key = request.session.session_key            for session in Session.objects.filter(~Q(session_key=session_key), expire_date__gte=timezone.now()):                data = session.get_decoded()                if data.get(&#x27;_auth_user_id&#x27;, None) == str(request.user.id):                    session.delete()\n\n然后在urls.py中设置：\nurlpatterns = [...re_path(&#x27;^xadmin/&#x27;, xadmin.site.urls),...]\n\n然后在settings.py中注册中间件\n   MIDDLEWARE = [   ...      &#x27;utils.xadminauth.XadminMiddleware&#x27;,   ...   ]SESSION_COOKIE_AGE = 1209600  # 设置过期时间   SESSION_SAVE_EVERY_REQUEST = Ture  # 每次请求都更新\n\n【参考】 https://blog.csdn.net/Python_anning\n50、Django restful 多个models数据表序列化合并返回（一次请求返回多个序列化器数据）# 导入第三方包pip install django-crispy-forms==1.7.2# 在settings.py中添加应用INSTALLED_APPS = [...&#x27;drf_multiple_model&#x27;,&#x27;rest_framework&#x27;,...]# 在views.py中使用    from drf_multiple_model.pagination import MultipleModelLimitOffsetPagination    from drf_multiple_model.views import ObjectMultipleModelAPIView            class LimitPagination(MultipleModelLimitOffsetPagination):        # 多个models数据表联合查询，分页，每页限制数据10条        default_limit = 10            class StudentSerializers(serializers.ModelSerializer):        &quot;&quot;&quot;学生表序列化器&quot;&quot;&quot;        # merchant = MerchantSerializers()                register_time = serializers.DateTimeField(read_only=True, format=&quot;%Y-%m-%d %H:%M:%S&quot;)               class Meta:            model = Student            fields = &#x27;__all__&#x27;    class ClassesSerializers(serializers.ModelSerializer):        &quot;&quot;&quot;班级表序列化器&quot;&quot;&quot;        # merchant = MerchantSerializers()                add_time = serializers.DateTimeField(read_only=True, format=&quot;%Y-%m-%d %H:%M:%S&quot;)               class Meta:            model = Classes            fields = &#x27;__all__&#x27;        class SchoolSerializers(serializers.ModelSerializer):        &quot;&quot;&quot;学校表序列化器&quot;&quot;&quot;        # merchant = MerchantSerializers()                add_time = serializers.DateTimeField(read_only=True, format=&quot;%Y-%m-%d %H:%M:%S&quot;)               class Meta:            model = School            fields = &#x27;__all__&#x27;                          class StudentInfo(ObjectMultipleModelAPIView):        # 获取学生信息，班级信息，学校信息            def get(self, request, *args, **kwargs):            uid = request.GET.get(&#x27;uid&#x27;, &#x27;&#x27;)  # 学生id            cid = request.GET.get(&#x27;cid&#x27;, &#x27;&#x27;)  # 班级id            sid = request.GET.get(&#x27;sid&#x27;, &#x27;&#x27;)  # 学校id                        self.querylist = [                &#123;&#x27;queryset&#x27;: Student.objects.filter(id=uid).order_by(&#x27;-id&#x27;),                    &#x27;serializer_class&#x27;:  StudentSerializers, &#x27;label&#x27;: &#x27;student&#x27;, &#125;,                &#123;&#x27;queryset&#x27;: Classes.objects.filter(id=cid).order_by(&#x27;-id&#x27;),                    &#x27;serializer_class&#x27;:  ClassesSerializers, &#x27;label&#x27;: &#x27;classes&#x27;, &#125;,                &#123;&#x27;queryset&#x27;: School.objects.filter(id=sid).order_by(&#x27;-id&#x27;),                    &#x27;serializer_class&#x27;:  SchoolSerializers, &#x27;label&#x27;: &#x27;school&#x27;, &#125;,            ]                return self.list(request, *args, **kwargs)            pagination_class = LimitPagination\n\n51、 Django序列化器返回外键关联数据通过 related_name&#x3D;’goods_price’把两个表关联起来，当返回Goods的信息时也会返回相应的GoodsPrice信息\nclass GoodsPriceSerializers(serializers.ModelSerializer):    &quot;&quot;&quot;商品价格表序列化器&quot;&quot;&quot;        class Meta:        model = GoodsPrice        fields = [&#x27;price&#x27;]class GoodsSerializers(serializers.ModelSerializer):    &quot;&quot;&quot;商品表序列化器&quot;&quot;&quot;        goods_price = GoodsPriceSerializers(many=True, read_only=True)    class Meta:        model = Goods        fields = [&#x27;title&#x27;,&#x27;goods_price&#x27;]        depth = 2class Goods(models.Model):    &quot;&quot;&quot;商品表&quot;&quot;&quot;    title = models.CharField(max_length=50, verbose_name=&#x27;商品名称&#x27;)    class Meta:        db_table = &#x27;goods&#x27;        verbose_name = &#x27;商品信息表&#x27;        verbose_name_plural = verbose_name    def __str__(self):        return self.titleclass GoodsPrice(models.Model):    &quot;&quot;&quot;商品价格表,通过外键关联商品信息表&quot;&quot;&quot;    price = models.DecimalField(max_digits=10, decimal_places=2, default=0, verbose_name=&#x27;售价&#x27;)    goods = models.ForeignKey(to=&#x27;Goods&#x27;, related_name=&#x27;goods_price&#x27;, on_delete=models.SET_NULL, blank=True, null=True,verbose_name=&#x27;商品&#x27;)    def __str__(self):        return str(self.price)    class Meta:        managed = True        db_table = &#x27;goodsPrice&#x27;        verbose_name = &#x27;商品售价&#x27;        verbose_name_plural = verbose_name\n\n52、python Django通过User Agent判断请求来源是微信扫一扫或者是支付宝扫一扫class Footest(APIView): def get(self, request, *args, **kwargs):     # print(request.META)     if &#x27;MicroMessenger&#x27; in request.META[&#x27;HTTP_USER_AGENT&#x27;]:         return Response(data=&#123;&#x27;msg&#x27;: &#x27;访问来源是微信&#x27;&#125;)     elif &#x27;AlipayClient&#x27; in request.META[&#x27;HTTP_USER_AGENT&#x27;]:         return Response(data=&#123;&#x27;msg&#x27;: &#x27;访问来源是支付宝&#x27;&#125;)     else:         return Response(data=&#123;&#x27;msg&#x27;: &#x27;访问来源是其他&#x27;&#125;)\n\nUser Agent中文名为用户代理，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。\n浏览器的 UA 字串\n标准格式为： 浏览器标识 (操作系统标识; 加密等级标识; 浏览器语言) 渲染引擎标识 版本信息\n获取user-Agent 之后，通过识别MicroMessenger或者AlipayClient这样的关键字应该就可以判断是微信还是支付宝【参考文章】 https://blog.csdn.net/fly910905/article/details/82498813?utm_source=blogxgwz4\n53、xadmin后台集成’导入‘插件，导入excel文件效果图：\n\n1、添加\n在虚拟环境根目录\\Lib\\site-packages\\xadmin\\plugins中添加excel.py文件\n\nfrom xadmin.views import BaseAdminPlugin, ListAdminView\nfrom django.template import loader\nimport xadmin\n\nclass ListExcelImportPlugin(BaseAdminPlugin):\n    # 重写init_request\n    import_excel = False\n    def init_request(self, *args, **kwargs):\n        return self.import_excel\n\n    def block_top_toolbar(self, context, nodes):\n        # 这里 xadmin/excel/model_list.top_toolbar.import.html 是自己写的html文件\n      nodes.append(loader.render_to_string(&quot;xadmin/excel/model_list.top_toolbar.import.html&quot;))\n\nxadmin.site.register_plugin(ListExcelImportPlugin, ListAdminView)\n\n在虚拟环境根目录\\Lib\\site-packages\\xadmin\\plugins__init__.py中\nPLUGINS = (\n...\n    &#39;excel&#39;,\n...\n)\n\n2、添加html文件\n\n在虚拟环境根目录\\Lib\\site-packages\\xadmin\\templates\\xadmin\\中增加文件夹excel,在文件夹中添加model_list.top_toolbar.import.html文件\n    &#123;% load i18n %&#125;\n&lt;div class=&quot;btn-group export&quot;&gt;\n    &lt;a class=&quot;dropdown-toggle btn btn-default btn-sm&quot; data-toggle=&quot;dropdown&quot; href=&quot;#&quot;&gt;\n        &lt;i class=&quot;icon-share&quot;&gt;&lt;/i&gt; 导入数据 &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;\n    &lt;/a&gt;\n    &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;dLabel&quot;&gt;\n        &lt;li&gt;&lt;a data-toggle=&quot;modal&quot; data-target=&quot;#export-modal-import-excel&quot;&gt;&lt;i class=&quot;icon-circle-arrow-down&quot;&gt;&lt;/i&gt; 导入\n            Excel&lt;/a&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n\n    &lt;div id=&quot;export-modal-import-excel&quot; class=&quot;modal fade&quot;&gt;\n        &lt;div class=&quot;modal-dialog&quot;&gt;\n            &lt;div class=&quot;modal-content&quot;&gt;\n                &lt;form method=&quot;post&quot; action=&quot;&quot; enctype=&quot;multipart/form-data&quot;&gt;\n                    &lt;!--&#123;% csrf_token %&#125;--&gt;\n                    &lt;div class=&quot;modal-header&quot;&gt;\n                        &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-hidden=&quot;true&quot;&gt;×&lt;/button&gt;\n                        &lt;h4 class=&quot;modal-title&quot;&gt;导入 Excel&lt;/h4&gt;\n                    &lt;/div&gt;\n                    &lt;div class=&quot;modal-body&quot;&gt;\n                        &lt;input type=&quot;file&quot; onchange=&quot;fileChange(this)&quot; name=&quot;excel&quot; id=&quot;submit_upload&quot;&gt;\n                    &lt;/div&gt;\n                    &lt;div class=&quot;modal-footer&quot;&gt;\n                        &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;&#123;% trans \"Close\" %&#125;&lt;/button&gt;\n                        &lt;button class=&quot;btn btn-success&quot; type=&quot;button&quot; id=&quot;submit_upload_b&quot;&gt;&lt;i class=&quot;icon-share&quot;&gt;&lt;/i&gt; 导入\n                        &lt;/button&gt;\n                    &lt;/div&gt;\n                &lt;/form&gt;\n            &lt;/div&gt;&lt;!-- /.modal-content --&gt;\n        &lt;/div&gt;&lt;!-- /.modal-dalog --&gt;\n    &lt;/div&gt;&lt;!-- /.modal --&gt;\n\n&lt;/div&gt;\n\n&lt;script type=&quot;text/javascript&quot;&gt;\n    function fileChange(target) &#123;\n        //检测上传文件的类型\n        var imgName = document.all.submit_upload.value;\n        var ext, idx;\n        if (imgName == &#39;&#39;) &#123;\n            document.all.submit_upload_b.disabled = true;\n            alert(&quot;请选择需要上传的 xls 文件!&quot;);\n            return;\n        &#125; else &#123;\n            idx = imgName.lastIndexOf(&quot;.&quot;);\n            if (idx != -1) &#123;\n                ext = imgName.substr(idx + 1).toUpperCase();\n                ext = ext.toLowerCase();\n\n                if (ext != &#39;xls&#39; &amp;&amp; ext != &#39;xlsx&#39;) &#123;\n                    document.all.submit_upload_b.disabled = true;\n                    alert(&quot;只能上传 .xls 类型的文件!&quot;);\n                    return;\n                &#125;\n            &#125; else &#123;\n                document.all.submit_upload_b.disabled = true;\n                alert(&quot;只能上传 .xls 类型的文件!&quot;);\n                return;\n            &#125;\n        &#125;\n    &#125;\n\n    $(document).ready(function () &#123;\n\n        $(&#39;#submit_upload_b&#39;).click(function () &#123;\n            var form_data = new FormData();\n            var file_info = $(&#39;#submit_upload&#39;)[0].files[0];\n            form_data.append(&#39;file&#39;, file_info);\n            form_data.append(&#39;file_source&#39;, $(&#39;.breadcrumb li&#39;).eq(1).text().trim());\n            var url = window.location.protocol + &#39;//&#39; + window.location.host + &#39;/importkdorderno/&#39;\n            $.ajax(&#123;\n                url: url,\n                type: &#39;POST&#39;,\n                data: form_data,\n                dataType: &quot;json&quot;,\n                beforeSend: function (xhr) &#123;\n                    xhr.setRequestHeader(&quot;X-CSRFToken&quot;, $.getCookie(&quot;csrftoken&quot;))\n                &#125;,\n                processData: false,  // tell jquery not to process the data\n                contentType: false, // tell jquery not to set contentType\n                success: function (res) &#123;\n\n                    alert(res.msg);\n                    window.location.reload();\n                &#125;,\n                error: function (err) &#123;\n                &#125;\n            &#125;);\n        &#125;);\n    &#125;)\n&lt;/script&gt;\n\n​3、在views.py处理上传的excel文件\nimport pandas as pd\nfrom rest_framework.views import APIView\n\nclass ImportKDOrderNo(APIView):\n\n    def post(self, request, *args, **kwargs):\n        file = request.FILES.get(&#39;file&#39;)\n        # read = InMemoryUploadedFile().open()\n        data = pd.read_excel(file)  # 使用pandas处理excel文件\n\t\tfile_source = request.POST.get(&#39;file_source&#39;, &#39;&#39;)  # 文件来源\n\t\t\n        if &#39;订单号&#39; and &#39;物流单号&#39; not in data:\n            return Response(data=&#123;&#39;msg&#39;: &#39;文件格式有误，第一行第一列应该为【订单号】，第一行第二列应该为【物流单号】&#39;&#125;)\n        ordernos = data[&#39;订单号&#39;]\n        logistics = data[&#39;物流单号&#39;]\n        for i in range(len(ordernos)):\n            print(&#39;订单号&#39;, ordernos[i], &#39;物流单号&#39;, logistics[i])\n          \n        return Response(data=&#123;&#39;msg&#39;: &#39;上传成功&#39;&#125;)\n\n4、在urls.py中添加访问路由\nfrom django.urls import pathfrom 你的应用名称 import viewsapp_name = &#x27;你的应用名称&#x27;urlpatterns = [    # 其他路由    ...    # 导入物流单号    path(&#x27;importkdorderno/&#x27;, views.ImportKDOrderNo.as_view(), name=&#x27;importkdorderno&#x27;),]\n\n54、Django中查找今天进账金额views.py\nfrom datetime import datetime\nclass CountFee(APIView):\n\tdef get(self, request, *args, **kwargs):\n\t\t# 获取当前时间的年月日，然后使用聚合函数添加fee字段的值\n    \tyear = datetime.now().year\n        month = datetime.now().month\n        day = datetime.now().day\n        count_fees = FeeDetail.objects.filter(addtime__year=year, addtime__month=month, addtime__day=day).aggregate(Sum(&#39;fee&#39;))\n        all_fee = count_fees[&#39;fee__sum&#39;] if count_fees[&#39;fee__sum&#39;] else 0\n        print(all_fee)\n        return Response(&#123;&#39;code&#39;: 1, &#39;msg&#39;: &#39;success&#39;, &#39;data&#39;: &#123;&#39;all_fee&#39;: all_fee&#125;&#125;)\n\n55、判断是什么系统import platformPlATFORM = platform.system()if PlATFORM == &quot;Linux&quot;:    print(&#x27;linux&#x27;)else:    print(&#x27;其他&#x27;) \n\n56、sql查询# 联合更新update malluser set master_master_id=3 where master_id in (select a.id from (select id from  malluser where id like &#x27;15%&#x27;)a) # 统计某字段重复数据SELECT phone, COUNT(*) AS sumCount FROM malluser GROUP BY phone HAVING sumCount &gt; 1;\n\n57、 xadmin后台删除数据出现错误`get_deleted_objects() takes 3 positional arguments but 5 were given`\n\n这是由于Django2.1版本和xadmin不兼容导致的\n知道虚拟环境\\Lib\\site-packages\\xadmin\\plugins\\actions.py\n修改93行，\n把\ndeletable_objects, model_count, perms_needed, protected = get_deleted_objects(\n            queryset, self.opts, self.user, self.admin_site, using)\n\n改为\ndeletable_objects, model_count, perms_needed, protected = get_deleted_objects(\n            queryset, self.user, self.admin_site)\n\n然后在adminx.py文件中对应的模型类中允许删除\nclass MaterialAdmin(object):\n    &quot;&quot;&quot;素材库分类&quot;&quot;&quot;\n    list_display = [&#39;id&#39;, &#39;name&#39;, &#39;class_id&#39;, &#39;is_delete&#39;, &#39;addtime&#39;]\n  \n    def has_delete_permission(self, *args, **kwargs):\n        return True\n\n58、xdamin限制用户点击//如果登录z=xadmin后台的账号不是【root】的就不能点击更新操作    var master_name = $(&#x27;#top-nav&#x27;).find(&#x27;strong&#x27;).text();        master_name =  master_name.substring(4);    if(master_name != &#x27;root&#x27;)&#123;            $(&quot;.grid-item a&quot;).each(function(index, element) &#123;                $(this).attr(&#x27;href&#x27;,&#x27;#&#x27;);            &#125;);        &#125;\n\n59、获取公众号关注url在微信网页版，打开公众号，点击右上角“…”，在弹框中选择右下角中间的“查看历史记录”，然后在弹框中选择左上角倒数第一个，“用默认浏览器打开”，就可以在打开的浏览器中获取该公众号的关注url，当把这个url发给好友时，好友点开的就是去关注公众号的页面。\n60、xadmin后台用户操作表权限虚拟环境根目录\\Lib\\site-packages\\xadmin\\views\\base.py\n可以找到：\n\n在项目子应用下的adminx.py中使用\nimport xadminfrom machine.models import Machineclass MachineAdmin(object):    list_display = [&#x27;code&#x27;,]  # 显示的字段    search_fields = [&#x27;code&#x27;]  # 搜索的字段    list_filter = [&#x27;code&#x27;, &#x27;is_delete&#x27;] # 过滤的字段    ordering = (&#x27;-id&#x27;,) # 按id降序排序    list_editable = [&#x27;is_delete&#x27;, ]  # 数据即时编辑    list_per_page = 30  # 每页显示数据数量    model_icon = &#x27;fa fa-cog fa-spin&#x27;  # 左侧显示的小图标    def has_delete_permission(self, *args, **kwargs):         # 删除权限        if self.request.user.is_superuser:  # 管理员才能增加            return True        return False    def has_add_permission(self, *args, **kwargs):        if self.request.user.is_superuser:  # 管理员才能增加            return True        return False    def has_change_permission(self, *args, **kwargs):        if self.request.user.is_superuser: # 管理员才能修改            return True        return False    def queryset(self):        qs = super(MachineAdmin, self).queryset()        if self.request.user.is_superuser:  # 管理员可以查看所有            return qs        else:            # 登录用户只能看到自己修改的数据            return qs.filter(master_id=self.request.user.last_name)xadmin.site.register(MallMachine, MallMachineAdmin)\n\n61、使用nginx部署项目先在&#x2F;etc&#x2F;nginx&#x2F;sites-available中创建一个配置文件，文件名为test(注意没有后缀):\n#设定虚拟主机配置    server &#123;        #侦听80端口        listen 80;        listen 443 ssl;        #定义使用 www.nginx.cn访问\t\t#ssl on;        server_name  xxx.xxx.com;        #定义服务器的默认网站根目录位置        root /root/项目名称;\t\tssl_session_timeout 5m;         ssl_certificate   /etc/nginx/cert/xxx.pem;        ssl_certificate_key  /etc/nginx/cert/xxx.key;        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;        ssl_prefer_server_ciphers on;        #设定本虚拟主机的访问日志        #access_log  logs/nginx.access.log  main;         #默认请求        location / &#123;            #倒入了uwsgi的配置            include uwsgi_params; \t\t    client_max_body_size\t50m;            #连接uwsgi的超时时间           # uwsgi_connect_timeout 30;  \t    #设定了uwsig服务器位置 \t    \tuwsgi_pass 127.0.0.1:8002;        &#125;                location /static&#123;      \talias /root/项目名称/static;        &#125;\tlocation /media &#123;\talias /root/项目名称/media;\t&#125; &#125;\n\n其中xxx.xxx.com表示域名.如果没有https，就使用#把ssl注释掉就可以了。\n然后把test映射到&#x2F;etc&#x2F;nginx&#x2F;sites-enabled\n命令\nln -s /etc/nginx/sites-available/test /etc/nginx/sites-enabled/test\n\n即可注意：uwsgi中配置listen&#x3D;1024时，启动uwsgi时可能会报错：\ndjango + uwsgi + nginx 日志Listen queue size is greater than the system max net.core.somaxconn (128).\n\n解决方法:\n修改系统参数/proc/sys/net/ipv4/tcp_max_syn_backlog  原来2048    改为8192/proc/sys/net/core/somaxconn\t原来128     改为262144\n\n重启nginx\nnginx -s reload\n\n62、xadmin后台发送邮件找回密码\n输入你用户绑定的邮箱\n\n想要发送邮件，需要在settings.py中设置邮件发送器\nsettings.py最下面增加\n# ------------------------邮箱配置-----------------------------------------EMAIL_BACKEND = &#x27;django.core.mail.backends.smtp.EmailBackend&#x27; #把要发送的邮件显示再控制台上，方便调试EMAIL_USE_SSL = TrueEMAIL_HOST = &#x27;smtp.qq.com&#x27;  # 如果是 163 改成 smtp.163.comEMAIL_PORT = 465EMAIL_HOST_USER = &#x27;邮箱账号&#x27; # 帐号EMAIL_HOST_PASSWORD = &#x27;授权码&#x27;  # 到邮箱里开通DEFAULT_FROM_EMAIL = EMAIL_HOST_USER\n\n由于django2与xadmin有些地方不兼容，需要修改源码：\n找到虚拟环境根目录\\Lib\\site-packages\\xadmin\\plugins\\passwords.py\n在passwords.py文件中大概79行，修改为\nreturn password_reset_confirm(request=request, uidb36=uidb36, token=token,                                      template_name=self.password_reset_confirm_template,                                      token_generator=self.password_reset_token_generator,                                      set_password_form=self.password_reset_set_form,                                      post_reset_redirect=self.get_admin_url(&#x27;xadmin_password_reset_complete&#x27;),                                      current_app=self.admin_site.name, extra_context=context).dispatch(request=request,                                                                                                        uidb64=uidb36,token=token)             \n\n找到虚拟环境根目录Lib\\site-packages\\django\\contrib\\auth\\views.py\n在views.py文件中大概258行，增加：\n# 成功后跳转路由,根据自己实际来定self.success_url = self.request.build_absolute_uri(&#x27;/&#x27;) + &#x27;xadmin/&#x27;\n\n\n63、xadmin外键下拉框添加过滤class MallGoodsAdmin(object):    &quot;&quot;&quot;商品管理&quot;&quot;&quot;    list_display = [&#x27;id&#x27;, &#x27;show_photo&#x27;, &#x27;nickname&#x27;, &#x27;merchant&#x27;, &#x27;goods_class&#x27;, &#x27;label&#x27;,]    search_fields = [&#x27;nickname&#x27;]    list_filter = [&#x27;goods_class&#x27;, &#x27;label&#x27;,]    model_icon = &#x27;fa fa-bars&#x27;    list_editable = [&#x27;goods_class&#x27;, ]    #,重写虚拟环境根目录下\\Lib\\site-packages\\xadmin\\views\\edit.py中的formfield_for_dbfield    def formfield_for_dbfield(self, db_field, **kwargs):        # 对MallGoodsClass这个表项的下拉框选择进行过滤        # MallGoods中有一个goods_class商品分类外键MallGoodsClass，过滤掉外键MallGoodsClass中         # master_class为空的值        if db_field.name == &quot;goods_class&quot;:            kwargs[&quot;queryset&quot;] = MallGoodsClass.objects.filter(master_class__isnull=False)            # 对assigned_recipient这个表项的下拉选择进行过滤        \treturn db_field.formfield(**dict(**kwargs))        return super().formfield_for_dbfield(db_field, **kwargs)xadmin.site.register(models.MallGoods, MallGoodsAdmin)\n\n64、xadmin即时编辑器去掉空标签\n虚拟环境根目录下\\Lib\\site-packages\\xadmin\\plugins\\editable.py，在大概\n129行增加：\nform.fields[fields[0]].empty_label = None\n\n\n65、用户增加的小组件，让其他用户可见找到虚拟环境根目录\\Lib\\site-packages\\xadmin\\views\\dashboard.py\n在548行、554行\n\n改为：\n@filter_hook    def get_widgets(self):        if self.widget_customiz:            portal_pos = UserSettings.objects.filter(               key=self.get_portal_key())            if len(portal_pos):                portal_pos = portal_pos[0].value                widgets = []                if portal_pos:                    user_widgets = dict([(uw.id, uw) for uw in UserWidget.objects.filter(page_id=self.get_page_id())])                    for col in portal_pos.split(&#x27;|&#x27;):                        ws = []                        for wid in col.split(&#x27;,&#x27;):                            try:                                widget = user_widgets.get(int(wid))                                if widget:                                    ws.append(self.get_widget(widget))                            except Exception as e:                                import logging                                logging.error(e, exc_info=True)                        widgets.append(ws)                return widgets        return self.get_init_widget()\n\n66、pip install uwsgi出错plugins/python/uwsgi_python.h:2:20: fatal error: Python.h: No such file or directory\n\n首先安装python3环境\napt install python3-dev\n\n然后再虚拟环境中\npip install uwsgi\n\n66、xadmin后台加载数据慢，解决方案list_filter: 过滤器要慎用，不要使用类似id这些数据量大的字段\nclass MallUserAdmin(object):    &quot;&quot;&quot;用户管理&quot;&quot;&quot;    list_display = [&#x27;id&#x27;, &#x27;tp_icon&#x27;, &#x27;nickname&#x27;, &#x27;phone&#x27;, &#x27;level&#x27;, &#x27;balance&#x27;, &#x27;province&#x27;, &#x27;city&#x27;, &#x27;quxian&#x27;]  # 显示字段    search_fields = [&#x27;id&#x27;, &#x27;nickname&#x27;, &#x27;phone&#x27;]  # 搜索    list_filter = [&#x27;level&#x27;, &#x27;province&#x27;, &#x27;city&#x27;, &#x27;quxian&#x27;]  # 过滤器    # list_filter = [&#x27;id&#x27;, &#x27;level&#x27;, &#x27;province&#x27;, &#x27;city&#x27;, &#x27;quxian&#x27;]  # 如果加id，xadmin加载回来的数据就会很慢，所以不要在过滤器上使用id    list_per_page = 30  # 默认每页数量    model_icon = &#x27;fa fa-users&#x27;  # 左侧图标    ordering = [&#x27;-id&#x27;]  # 排序    readonly_fields = [&#x27;subscribe&#x27;, &#x27;wx_openid&#x27;, &#x27;phone&#x27;]  # 只读字段    is_addbalance = True   # 加载自定义的插件    relfield_style = &#x27;fk-ajax&#x27;  # 其他表如果外键到用户表就做ajax搜索查询，不一次性加载数据\n\n67 、xadmin导出插件处理，增加导出勾选数据项常规的导出只有两个选择【导出表头】、【导出全部数据】\n\n现在想要做的是增加一个选择，即【导出表头】、【导出全部数据】、【导出勾选数据】，如下图：\n\n需要修改xadmin源代码，具体如下\n1、加载js文件找到虚拟环境\\Lib\\site-packages\\xadmin\\views\\list.py，在607行增加’xadmin.plugin.importexport.js’，如下图所示\n\n2、修改export.py，后端处理下载文件找到虚拟环境\\Lib\\site-packages\\xadmin\\plugins\\export.py\n在84行把rows &#x3D; context[‘results’]修改成如下函数\n# 新增导出所选数据# rows = context[&#x27;results&#x27;]  rows = []select_across = self.request.GET.get(&#x27;_select_across&#x27;, False) == &#x27;1&#x27;selected = self.request.GET.get(&#x27;_selected_actions&#x27;, &#x27;&#x27;)if self.request.GET.get(&#x27;selected&#x27;, &#x27;off&#x27;) == &#x27;on&#x27;:    if not select_across:        selected_pk = selected.split(&#x27;,&#x27;)        for i in context[&#x27;results&#x27;]:            if str(i[&#x27;object&#x27;].id) in selected_pk:                rows.append(i)    else:        rows = context[&#x27;results&#x27;]else:    rows = context[&#x27;results&#x27;]\n\n\n3、 修改model_list.top_toolbar.exports.html找到虚拟环境\\Lib\\site-packages\\xadmin\\templates\\xadmin\\blocks\\model_list.top_toolbar.exports.html\n使用以下代码覆盖原文件\n&#123;% load i18n %&#125;&lt;div class=&quot;btn-group export&quot;&gt;    &lt;a id=&quot;export-menu&quot; class=&quot;dropdown-toggle btn btn-default btn-sm&quot; data-toggle=&quot;dropdown&quot; href=&quot;#&quot;&gt;        &lt;i class=&quot;fa fa-share&quot;&gt;&lt;/i&gt; &#123;% trans &quot;Export&quot; %&#125; &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;    &lt;/a&gt;    &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;dLabel&quot;&gt;        &#123;% for et in export_types %&#125;        &lt;li&gt;&lt;a data-toggle=&quot;modal&quot; data-target=&quot;#export-modal-&#123;&#123;et.type&#125;&#125;&quot;&gt;&lt;i class=&quot;fa fa-arrow-circle-down&quot;&gt;        &lt;/i&gt; &#123;% trans &quot;Export&quot; %&#125; &#123;&#123;et.name&#125;&#125;&lt;/a&gt;&lt;/li&gt;        &#123;% endfor %&#125;    &lt;/ul&gt;    &#123;% for et in export_types %&#125;    &lt;div id=&quot;export-modal-&#123;&#123;et.type&#125;&#125;&quot; class=&quot;modal fade&quot;&gt;        &lt;div class=&quot;modal-dialog&quot;&gt;            &lt;div class=&quot;modal-content&quot;&gt;                &lt;form method=&quot;get&quot; action=&quot;&quot;&gt;                    &lt;div class=&quot;modal-header&quot;&gt;                        &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/button&gt;                        &lt;h4 class=&quot;modal-title&quot;&gt;&#123;% trans &quot;Export&quot; %&#125; &#123;&#123;et.name&#125;&#125;&lt;/h4&gt;                    &lt;/div&gt;                    &lt;div class=&quot;modal-body&quot;&gt;                        &#123;&#123; form_params|safe &#125;&#125;                        &lt;input type=&quot;hidden&quot; name=&quot;export_type&quot; value=&quot;&#123;&#123;et.type&#125;&#125;&quot;&gt;                        &lt;!-- 增加 导出所选数据 一栏 --&gt;                        &lt;input type=&quot;hidden&quot; name=&quot;_selected_actions&quot; value=&quot;&quot;/&gt;                        &lt;input type=&quot;hidden&quot; name=&quot;_select_across&quot; value=&quot;&quot;/&gt;                        &lt;label class=&quot;checkbox&quot;&gt;                            &#123;% if et.type == &quot;xlsx&quot; %&#125;                            &lt;input type=&quot;checkbox&quot; name=&quot;export_xlsx_header&quot; checked=&quot;checked&quot; value=&quot;on&quot;&gt;                            &#123;% trans &quot;Export with table header.&quot; %&#125;                            &#123;% endif %&#125;                            &#123;% if et.type == &quot;xls&quot; %&#125;                            &lt;input type=&quot;checkbox&quot; name=&quot;export_xls_header&quot; checked=&quot;checked&quot; value=&quot;on&quot;&gt;                            &#123;% trans &quot;Export with table header.&quot; %&#125;                            &#123;% endif %&#125;                            &#123;% if et.type == &quot;csv&quot; %&#125;                            &lt;input type=&quot;checkbox&quot; name=&quot;export_csv_header&quot; checked=&quot;checked&quot; value=&quot;on&quot;&gt;                            &#123;% trans &quot;Export with table header.&quot; %&#125;                            &#123;% endif %&#125;                            &#123;% if et.type == &quot;xml&quot; %&#125;                            &lt;input type=&quot;checkbox&quot; name=&quot;export_xml_format&quot; checked=&quot;checked&quot; value=&quot;on&quot;&gt;                            &#123;% trans &quot;Export with format.&quot; %&#125;                            &#123;% endif %&#125;                            &#123;% if et.type == &quot;json&quot; %&#125;                            &lt;input type=&quot;checkbox&quot; name=&quot;export_json_format&quot; checked=&quot;checked&quot; value=&quot;on&quot;&gt;                            &#123;% trans &quot;Export with format.&quot; %&#125;                            &#123;% endif %&#125;                        &lt;/label&gt;                        &lt;label class=&quot;checkbox&quot;&gt;                            &lt;input type=&quot;checkbox&quot; name=&quot;all&quot; value=&quot;on&quot;&gt; &#123;% trans &quot;Export all data.&quot; %&#125;                        &lt;/label&gt;                        &lt;!-- 增加 导出所选数据 一栏 --&gt;                        &lt;label class=&quot;checkbox&quot;&gt;                            &lt;input type=&quot;checkbox&quot; name=&quot;selected&quot; value=&quot;on&quot;&gt; 导出勾选数据                        &lt;/label&gt;                    &lt;/div&gt;                    &lt;div class=&quot;modal-footer&quot;&gt;                        &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;&#123;% trans &quot;Close&quot; %&#125;&lt;/button&gt;                        &lt;button class=&quot;btn btn-success myexport  glyphicon glyphicon-export &quot; type=&quot;submit&quot;&gt;&lt;i                                class=&quot;fa fa-share&quot;&gt;&lt;/i&gt; &#123;% trans &quot;Export&quot; %&#125;                        &lt;/button&gt;                    &lt;/div&gt;                &lt;/form&gt;            &lt;/div&gt;&lt;!-- /.modal-content --&gt;        &lt;/div&gt;&lt;!-- /.modal-dalog --&gt;    &lt;/div&gt;&lt;!-- /.modal --&gt;    &#123;% endfor %&#125;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    // 如果是订单导出，把待出货订单设置成待收货订单    $(document).ready(function () &#123;        $(&#x27;.myexport&#x27;).click(function () &#123;            // 当把订单导出时，需要修改订单状态为待收货状态            var url = window.location.protocol + &#x27;//&#x27; + window.location.host + &quot;/exportorder/&quot;;            $(&quot;input[name=&#x27;_select_across&#x27;]&quot;).val($(&quot;input[name=&#x27;select_across&#x27;]&quot;).val());            if ($(&quot;input[name=&#x27;selected&#x27;]&quot;).is(&#x27;:checked&#x27;)) &#123;                var arr = [];                $.each($(&#x27;.action-select&#x27;), function () &#123;                    if (true == $(this).prop(&#x27;checked&#x27;)) &#123;                        arr.push($(this).val());                    &#125;                &#125;);                if(arr.length == 0)&#123;                    alert(&#x27;请先勾选导出数据&#x27;)                    return false                &#125;            &#125;else&#123;                var arr = []                var order_type = $(&#x27;.breadcrumb li&#x27;).eq(1).text().trim()                $(&#x27;.grid-item&#x27;).each(function (index, el) &#123;                    arr.push($(el).find(&#x27;td&#x27;).eq(1).text().trim())                &#125;)            &#125;            if (($(&#x27;.breadcrumb &gt; li&#x27;).eq(1).text()).indexOf(&#x27;订单&#x27;) != -1) &#123;                // 5秒后执行                setTimeout(function () &#123;                    $.ajax(&#123;                        type: &quot;POST&quot;,                        url: url,                        data: &#123;&#x27;orderlist&#x27;: JSON.stringify(arr), &#x27;order_type&#x27;: order_type,&#125;,                        beforeSend: function (xhr) &#123;                            xhr.setRequestHeader(&quot;X-CSRFToken&quot;, $.getCookie(&quot;csrftoken&quot;))                        &#125;,                        success: function (data) &#123;                            window.location.reload();                        &#125;,                        error: function (xhr) &#123;                            alert(&quot;出现未知错误&quot;);                            window.location.reload();                        &#125;                    &#125;);                &#125;, 5000);            &#125;        &#125;);    &#125;)&lt;/script&gt;\n\n68、使用F查询更新用户重要数据from django.db.models import F# 使用F查询更新用户余额balance = 5  MallUser.objects.filter(id=1).update(balance=F(&#x27;balance&#x27;) + balance)\n\n相当于sql的\nupdate Malluser set balance=balance + 5 where id=1;\n\n69、日志输出模块import loggingimport platform# 全局函数PlATFORM = platform.system()if (PlATFORM == &quot;Linux&quot;):    # linux系统,文件保存在var下    SERVER_LOG_PATH = &#x27;/var/mylog.log&#x27;else:    # windows系统,文件保存在D盘下    SERVER_LOG_PATH = &#x27;D:\\mylog.log&#x27;# 定义一个logging的对象，命名为mylogLOGGER = logging.getLogger(&#x27;mylog&#x27;)# 设置级别为WARNINGLOGGER.setLevel(logging.WARNING)# 创建一个handler，用于写入日志文件fh = logging.FileHandler(SERVER_LOG_PATH, encoding=&#x27;utf-8&#x27;)fh.setLevel(logging.WARNING)# 定义handler的输出格式formatter = logging.Formatter(&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;, datefmt=&#x27;%Y-%m-%d %H:%M:%S&#x27;)fh.setFormatter(formatter)# 给Logger添加handlerLOGGER.addHandler(fh)# 不在控制台显示LOGGER.propagate = False\n\n70、字典排序字典在内存中发布是无序的，当想对键值或者键名进行排序时可以先把字典转成元组，这可以达到排序的目的。\nscore = &#123;&#x27;小明&#x27;: &#123;&#x27;avg_score&#x27;: 90, &#x27;English&#x27;: 90, &#x27;Math&#x27;: 90, &#x27;Chniese&#x27;: 90, &#125;,     &#x27;小红&#x27;: &#123;&#x27;avg_score&#x27;: 60, &#x27;English&#x27;: 60, &#x27;Math&#x27;: 61, &#x27;Chniese&#x27;: 59, &#125;,     &#x27;小黑&#x27;: &#123;&#x27;avg_score&#x27;: 70, &#x27;English&#x27;: 75, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 70, &#125;,     &#x27;小白&#x27;: &#123;&#x27;avg_score&#x27;: 80, &#x27;English&#x27;: 95, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 80, &#125;,     &#125;# 对姓名进行排序，即对键名进行排序b = sorted(score.items(), key=lambda x: x[0], reverse=True)show_str = &#x27;&#x27;for info in b:    # print(info)    key, value = info[0], info[1]    show_str += &#x27;姓名：&#123;&#125;,平均分：&#123;&#125;，成绩：&#123;&#125;&#x27;.format(key,value[&#x27;avg_score&#x27;], value) + &#x27;\\r\\n&#x27;print(&#x27;对姓名进行排序&#x27;)print(show_str)# 对平均分进行排序b = sorted(score.items(), key=lambda x: x[1][&#x27;avg_score&#x27;], reverse=True)show_str = &#x27;&#x27;for info in b:    # print(info)    key, value = info[0], info[1]    show_str += &#x27;姓名：&#123;&#125;,平均分：&#123;&#125;，成绩：&#123;&#125;&#x27;.format(key,value[&#x27;avg_score&#x27;], value) + &#x27;\\r\\n&#x27;print(&#x27;对平均分进行排序&#x27;)print(show_str)# 对英语成绩进行排序b = sorted(score.items(), key=lambda x: x[1][&#x27;English&#x27;], reverse=True)show_str = &#x27;&#x27;for info in b:    # print(info)    key, value = info[0], info[1]    show_str += &#x27;姓名：&#123;&#125;,平均分：&#123;&#125;，成绩：&#123;&#125;&#x27;.format(key,value[&#x27;avg_score&#x27;], value) + &#x27;\\r\\n&#x27;print(&#x27;对英语成绩进行排序&#x27;)print(show_str)\n\n输出：\n对姓名进行排序姓名：小黑,平均分：70，成绩：&#123;&#x27;avg_score&#x27;: 70, &#x27;English&#x27;: 75, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 70&#125;姓名：小红,平均分：60，成绩：&#123;&#x27;avg_score&#x27;: 60, &#x27;English&#x27;: 60, &#x27;Math&#x27;: 61, &#x27;Chniese&#x27;: 59&#125;姓名：小白,平均分：80，成绩：&#123;&#x27;avg_score&#x27;: 80, &#x27;English&#x27;: 95, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 80&#125;姓名：小明,平均分：90，成绩：&#123;&#x27;avg_score&#x27;: 90, &#x27;English&#x27;: 90, &#x27;Math&#x27;: 90, &#x27;Chniese&#x27;: 90&#125;对平均分进行排序姓名：小明,平均分：90，成绩：&#123;&#x27;avg_score&#x27;: 90, &#x27;English&#x27;: 90, &#x27;Math&#x27;: 90, &#x27;Chniese&#x27;: 90&#125;姓名：小白,平均分：80，成绩：&#123;&#x27;avg_score&#x27;: 80, &#x27;English&#x27;: 95, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 80&#125;姓名：小黑,平均分：70，成绩：&#123;&#x27;avg_score&#x27;: 70, &#x27;English&#x27;: 75, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 70&#125;姓名：小红,平均分：60，成绩：&#123;&#x27;avg_score&#x27;: 60, &#x27;English&#x27;: 60, &#x27;Math&#x27;: 61, &#x27;Chniese&#x27;: 59&#125;对英语成绩进行排序姓名：小白,平均分：80，成绩：&#123;&#x27;avg_score&#x27;: 80, &#x27;English&#x27;: 95, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 80&#125;姓名：小明,平均分：90，成绩：&#123;&#x27;avg_score&#x27;: 90, &#x27;English&#x27;: 90, &#x27;Math&#x27;: 90, &#x27;Chniese&#x27;: 90&#125;姓名：小黑,平均分：70，成绩：&#123;&#x27;avg_score&#x27;: 70, &#x27;English&#x27;: 75, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 70&#125;姓名：小红,平均分：60，成绩：&#123;&#x27;avg_score&#x27;: 60, &#x27;English&#x27;: 60, &#x27;Math&#x27;: 61, &#x27;Chniese&#x27;: 59&#125;\n\n对列表中字典按多个键值排序from operator import itemgetterdata = [    &#123;&#x27;code&#x27;: 1, &#x27;position&#x27;: 300, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,    &#123;&#x27;code&#x27;: 2, &#x27;position&#x27;: 255, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,    &#123;&#x27;code&#x27;: 3, &#x27;position&#x27;: 256, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,    &#123;&#x27;code&#x27;: 1, &#x27;position&#x27;: 500, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,    &#123;&#x27;code&#x27;: 5, &#x27;position&#x27;: 455, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,    &#123;&#x27;code&#x27;: 1, &#x27;position&#x27;: 322, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,    &#123;&#x27;code&#x27;: 6, &#x27;position&#x27;: 676, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,]data = sorted(data, key=itemgetter(&#x27;code&#x27;, &#x27;position&#x27;))print(data)\n\n输出：\n[&#123;&#x27;code&#x27;: 1, &#x27;position&#x27;: 300, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;, &#123;&#x27;code&#x27;: 1, &#x27;position&#x27;: 322, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;, &#123;&#x27;code&#x27;: 1, &#x27;position&#x27;: 500, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;, &#123;&#x27;code&#x27;: 2, &#x27;position&#x27;: 255, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;, &#123;&#x27;code&#x27;: 3, &#x27;position&#x27;: 256, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;, &#123;&#x27;code&#x27;: 5, &#x27;position&#x27;: 455, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;, &#123;&#x27;code&#x27;: 6, &#x27;position&#x27;: 676, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;]\n\n71、时间格式与字符串互转、比较大小import datetime# 当前时间转字符串now = datetime.datetime.strftime(datetime.datetime.now(), &#x27;%Y-%m-%d %H:%M:%S&#x27;)# 字符串转时间格式now = datetime.datetime.strptime(now, &#x27;%Y-%m-%d %H:%M:%S&#x27;)a = now + datetime.timedelta(minutes=-15)# 时间比较大小if a &lt; now:    print(&#x27;yes&#x27;)\n\n72、python把’\\u’开头的字符串转中文str_data = &#x27;\\\\u7528\\\\u6237 ID \\\\u6216\\\\u5bc6\\\\u7801\\\\u9519\\\\u8bef&#x27;# 字符串.encode(&#x27;utf-8&#x27;).decode(&#x27;unicode_escape&#x27;)str_data_to_zh = str_data.encode(&#x27;utf-8&#x27;).decode(&#x27;unicode_escape&#x27;)print(str_data_to_zh)# 输出用户 ID 或密码错误\n\n73、django进行数据迁移时出现No changes detected解决方案原因：可能是由于app下面没有migrations文件夹所以需要创建这个文件夹，命令\npython manage.py makemigrations --empty 你的app名称\n\n74、ubuntu下载文件到windows桌面apt install lrzszsz 123.txt\n\n75、git查看提交日志git log --author=&quot;ldc&quot;\n\n76、python翻译模块可以把英文翻译成中文，也可以把中文翻译成英文\npip install  translatefrom translate import Translatorname = &#x27;giant panda, panda, panda bear, coon bear, Ailuropoda melanoleuca&#x27;translator = Translator(to_lang=&quot;chinese&quot;)translation = translator.translate(name)print(translation)translator= Translator(from_lang=&quot;chinese&quot;,to_lang=&quot;english&quot;)translation = translator.translate(&quot;我想你&quot;)print(translation)输出：大熊猫，熊猫，熊猫熊，浣熊，大熊猫I missed you.\n\n77、python实现字符串转字典import astimport jsontarget_str = &#x27;&#123;&quot;h&quot;: 1, &quot;e&quot;: 2, &quot;l&quot;: 3, &quot;l&quot;: 4, &quot;o&quot;: 5&#125;&#x27;target_str2 = &quot;&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 2, &#x27;l&#x27;: 3, &#x27;l&#x27;: 4, &#x27;o&#x27;: 5&#125;&quot;# 方式1：使用json，缺点，字符串中不能出现单引号# 由于 json 语法规定 数组或对象之中的字符串必须使用双引号，不能使用单引号# 官网https://www.json.org/json-en.html上有一段描述是# A string is a sequence of zero or more Unicode characters, wrapped in double quotes, using backslash escapesprint(json.loads(target_str))# print(json.loads(target_str2))   # 使用json转这个字符串会报错 Expecting property name enclosed in double quotes# 方式2：使用eval函数，缺点，不安全print(eval(target_str))print(eval(target_str2))# print(eval(&quot;__import__(&#x27;os&#x27;).system(&#x27;dir&#x27;)&quot;))  # 会列出当前的目录文件，如果字符串是一些删除命令，则可以把整个目录清空！# 方式3，使用ast.literal_eval，没有json与eval的缺点，推荐使用这个print(ast.literal_eval(target_str))print(ast.literal_eval(target_str2))\n\n输出：\n&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 2, &#x27;l&#x27;: 4, &#x27;o&#x27;: 5&#125;&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 2, &#x27;l&#x27;: 4, &#x27;o&#x27;: 5&#125;&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 2, &#x27;l&#x27;: 4, &#x27;o&#x27;: 5&#125;&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 2, &#x27;l&#x27;: 4, &#x27;o&#x27;: 5&#125;&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 2, &#x27;l&#x27;: 4, &#x27;o&#x27;: 5&#125;\n\n78、django app 如何在后台显示中文名1.在app (这里以user为例)下面的__init__.py文件中\n添加:\ndefault_app_config = &#x27;user.apps.UserConfig&#x27;\n\n2.在apps.py中\nfrom django.apps import AppConfigclass UserConfig(AppConfig):    name = &#x27;user&#x27;    verbose_name = &#x27;用户&#x27;\n\n79、使用python给Excel指定行添加数据import openpyxl, syswb = openpyxl.load_workbook(&#x27;b.xlsx&#x27;)sheet = wb[&#x27;Sheet1&#x27;]# 在excel表格第二行添加新数据addrow = 1   # 增加一行row = 2  # 在第二行新增一行name = &#x27;b-back.xlsx&#x27; # 新的表名wb1 = openpyxl.Workbook()sheet1 = wb1[&#x27;Sheet&#x27;]# 复制前row行for i in range(1, row):    for j in range(1, sheet.max_column + 1):        sheet1.cell(row=i, column=j).value = sheet.cell(row=i, column=j).value# 复制后row行for i in range(row, sheet.max_row + 1):    for j in range(1, sheet.max_column + 1):        if i == row:            # 给第row行添加新的数据            sheet1.cell(row=row, column=j).value = &#x27;新增&#x27;        sheet1.cell(row=i + addrow, column=j).value = sheet.cell(row=i, column=j).valuewb1.save(name)\n\n\n80、python中的format格式拼接字符串d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 5&#125;print(&#x27;&#123;a&#125;,&#123;b&#125;&#x27;.format(**d))print(&#x27;&#123;0&#125;,&#123;1&#125;,&#123;0&#125;&#x27;.format(&#x27;a&#x27;, &#x27;b&#x27;))print(f&quot;&#123;d[&#x27;a&#x27;]&#125;&quot;)\n\n输出：\n1,2a,b,a1\n\n81、数据库inner join、full join、left join、union、union all区别表a_test\n\n表b_test\n\nINNER JOIN\n是A和B的交集\nSELECT * FROM a_test INNER JOIN b_test ON a_test.name = b_test.namesaInner join 产生的结果集中，是A和B的交集。\n\n\nFULL OUTER JOIN\n产生A和B的并集\nSELECT * FROM a_test FULL OUTER JOIN b_test ON a_test.name = b_test.name Full outer join 产生A和B的并集。但是需要注意的是，对于没有匹配的记录，则会以null做为值。可以使用IF NULL判断。\n\n\nSELECT * FROM a_test FULL OUTER JOIN b_test ON a_test.name = b_test.nameWHERE a_test.id IS null OR b_test.id IS null产生A表和B表没有交集的数据集。\n\n\nLEFT [OUTER] JOIN\n产生表A的完全集，而B表中匹配的则有值，没有匹配的则以null值取代\nSELECT * FROM a_test LEFT OUTER JOIN b_test ON a_test.name = b_test.name有些数据库可以不要OUTERSELECT * FROM a_test LEFT  JOIN b_test ON a_test.name = b_test.nameLeft outer join 产生表A的完全集，而B表中匹配的则有值，没有匹配的则以null值取代。\n\n\nSELECT * FROM a_test LEFT OUTER JOIN b_test ON a_test.name = b_test.name WHERE b_test.id IS null产生在A表中有而在B表中没有的集合。\n\n\nRIGHT [OUTER] JOIN\nRIGHT OUTER JOIN 是后面的表为基础，与LEFT OUTER JOIN用法类似。\nUNION 与 UNION ALL\nUNION 操作符用于合并两个或多个 SELECT 语句的结果集。请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。UNION 只选取记录，而UNION ALL会列出所有记录。SELECT name FROM a_test UNION SELECT name FROM b_test选取不同值\n\n\nSELECT a_test.id,a_test.name  FROM a_test UNION SELECT b_test.id,b_test.name FROM b_test由于 id 51 xh   与 id 4 xh 并不相同，不合并\n\n\nSELECT name FROM a_test UNION ALL SELECT name FROM b_test全部列出来\n\n\n还需要注意的是我们还有一个是“交差集” cross join, 这种Join没有办法用文式图表示，因为其就是把表A和表B的数据进行一个N*M的组合，即笛卡尔积。\n表达式如下：SELECT * FROM a_test CROSS JOIN b_test\n这个笛卡尔乘积会产生 4 x 4 &#x3D; 16 条记录，一般来说，我们很少用到这个语法。但是我们得小心，如果不是使用嵌套的select语句，一般系统都会产生笛卡尔乘积然再做过滤。这是对于性能来说是非常危险的，尤其是表很大的时候。\n82、windows电脑查看端口使用情况找出8000端口对应的PID进程，命令为：\nnetstat -ano|findstr 8000\n\n进程信息如下：\nTCP    0.0.0.0:8000           0.0.0.0:0              LISTENING       1620UDP    0.0.0.0:8000           *:*                                    1620\n\n找出进程对应的详细信息：\ntasklist |findstr 1620KGService.exe                 1620 Console                    1     18,696 K\n\n关进程：\ntaskkill /pid 1620 /F\n\n查看程序占用内存比如查看python占用运行内存\ntasklist  /fi &quot;imagename eq python.exe&quot;\n\n\n83、Django生成表和反向生成Model正向生成：python manage.py makemigrationspython manage.py migrate反向：会根据设置的数据库中的表在自动生成对应的Model代码，并打印出来python manage.py inspectdb以直接将打印的代码直接导入到指定的Model文件中python manage.py inspectdb &gt; models.py\n\n84、windows的hosts文件位置C:\\Windows\\System32\\drivers\\etc\\hosts\n\n85、postgresql数据库# 如果表存在就先删除drop table if exists student;# 创建学生表# id      serial not null  表示id自增# id      integer not null  表示id不自增create table student(    id                    serial not null        constraint student_pk            primary key,    name                  varchar,    class_id              integer,    height                numeric,    weight                numeric,    write_date            timestamp    );comment on table student is &#x27;学生表&#x27;;comment on column student.name is &#x27;名称&#x27;;comment on column student.class_id is &#x27;班级ID&#x27;;comment on column student.height is &#x27;身高&#x27;;comment on column student.weight is &#x27;体重&#x27;;comment on column student.write_date is &#x27;修改时间&#x27;;alter table student    owner to odoo;# 更新update user set name=&#x27;张三&#x27; where id=111# 更新表a的字段为表b的值update account_invoice set sale_order_id=so.id from sale_order so where account_invoice.origin=so.name# 新增insert into &quot;user&quot; (name,sex) values (&#x27;小明&#x27;,1),(&#x27;小红&#x27;, 0)# 新增或更新如果id冲突就更新INSERT INTO  student(id, name)   VALUES(12, &#x27;小明&#x27;),(13, &#x27;小红&#x27;)   ON conflict(id) DO UPDATE   SET name =&#x27;未知&#x27;;如果id冲突就什么也不做INSERT INTO  student(id, name)   VALUES(12, &#x27;小明&#x27;),(13, &#x27;小红&#x27;)   ON conflict(id) DO NOTHING;# 把一个表中的数据插入到另一个表中insert into 目标表名 (column1,column2,columnn) select value1,value2,valuen from  源表名比如：insert into student (name, classs_name,create_date) select  student_name as name, class_name, now() from class_table;# 获取当前时间now()select now()# 删除DELETE FROM table_name [WHERE Clause]# 增加字段alter table 表名 add column 列名 类型;# 删除字段alter table 表名 dropcolumn 列名 ;# postgresql数据库查看表所有字段select * from information_schema.columns where table_schema=&#x27;public&#x27; and table_name=&#x27;表名&#x27;;# postgresql获取所有表名select tablename from pg_tables where schemaname=&#x27;public&#x27;# 对查询结果按id降序显示select * from table_name order by id desc# 对查询结果按id升序显示select * from table_name order by id asc# 转义字符, 查找name中包含单引号的记录select * from student where name like  E&#x27;%\\&#x27;%&#x27;;# 查看表记录总数select relname as TABLE_NAME, reltuples as rowCounts from pg_class where relkind = &#x27;r&#x27; and relnamespace = (select oid from pg_namespace where nspname=&#x27;public&#x27;) order by rowCounts desc;# 将结果转换为数组SELECT array(SELECT &quot;name&quot; FROM sale_order);# 将数组合并为字符串select array_to_string(array[1,2,3], &#x27;,&#x27;)# 联合子集更新，把sale_order_line的name连接换行符，然后按id更新到表a_test中对应的nameupdate a_test set name=array_to_string(array(select name from sale_order_line where order_id=a_test.id),&#x27;&lt;br/&gt;&#x27;);# PostgreSQL合并查询同一列的多条记录，针对一对多，多对多字段比如表：id   name                  1    小明                   1    小红                     id   name1    小亮        --&gt;          1    小明，小亮，小红2    小强                     2    小强，小王2    小王SELECT     id, array_to_string(ARRAY(SELECT unnest(array_agg(name order by name desc))),&#x27;,&#x27;) AS all_nameFROM      studentGROUP BY id;# case语句case var\twhen condition1 then statement1\twhen condition2 then statement2else statementnend as new_name比如：select case name\twhen &#x27;小明&#x27; then &#x27;xm&#x27;\twhen &#x27;小红&#x27; then &#x27;xh&#x27;\twhen &#x27;小刚&#x27; then &#x27;xg&#x27;else &#x27;xw&#x27;end as short_namefrom student# 临时表、字符串合并、类型转换、时间格式转换、当前时间WITH TEMP AS ( \tSELECT CAST ( concat ( bam.account_period_code, &#x27;-01&#x27; ) AS TIMESTAMP ) \t   AS account_period_time \t\t FROM bi_account_move AS bam ) SELECT\taccount_period_time,\tto_char(CURRENT_DATE,&#x27;yyyy-MM-dd hh24:MI:ss&#x27;) as current_date,\tto_char( account_period_time, &#x27;yyyy&#x27; ) as year,\tto_char( account_period_time, &#x27;MM&#x27; ) as month,\tto_char( account_period_time, &#x27;dd&#x27; ) as day FROM TEMP比如：account_period_time\tcurrent_date\t    year\tmonth\tday2019-06-01 0:00:00\t2020-06-24 00:00:00\t2019\t 06\t     012019-06-01 0:00:00\t2020-06-24 00:00:00\t2019\t 06\t     01# 多个字符串拼接select concat(&#x27;payment_&#x27;, CAST(ap.id as varchar)) as line_keyfrom ap# 将查询所得结果集的某一字段拼接成字符串，默认的是逗号select GROUP_CONCAT(id) from test where id&gt;5;结果为：1,2,3,4,5,6,7# 使用其他分隔符拼接select GROUP_CONCAT(id separator &#x27;-&#x27;) from test where id&gt;5;结果为：1-2-3-4-5-6-7# 多个临时表WITH temp_student AS ( SELECT ID, NAME, sex FROM student WHERE sex = TRUE ),temp_class AS (\tSELECT\t\tID,\t\tNAME,\t\tstudent_id,\t\tteacher_id\tFROM\t\tthe_class \t),\ttemp_teacher AS (\tSELECT \t  ID,\t\tNAME,\t\tage \tFROM\t\tteacher \t) \tSELECT\tts.NAME AS student_name,\ttc.NAME AS class_name,\tte.NAME AS teacher_name\tfrom temp_student as ts\tLEFT JOIN temp_class AS tc ON tc.student_id = ts.ID  \tLEFT JOIN teacher AS te ON te.id = tc.teacher_id  # null转成有意义的值select COALESCE(name, &#x27;&#x27;) as name from a_test意思就是如果name为null，就转为空字符串# 字符串截取select SUBSTRING(&#x27;abcd&#x27;,1,2); -- result:ab 表示从下标从1开始,截取2个字符# 使用 interval 时间相加减(+/-)当前时间 + 10秒，select to_char(now() + interval &#x27;10 second&#x27;, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;)  as reqDate from account_period;当前时间 - 10秒select to_char(now() + interval &#x27;-10 second&#x27;, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;)  as reqDate from account_period; 当前时间 + 10分，select to_char(now() + interval &#x27;10 minute&#x27;, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;)  as reqDate  from account_period; 当前时间 + 10时，select to_char(now() + interval &#x27;10 hour&#x27;, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;)  as reqDate from account_period; 当前时间 + 10天，select to_char(now() + interval &#x27;10 day&#x27;, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;)  as reqDate from account_period;当前时间 + 10年，select to_char(now() + interval &#x27;10 year&#x27;, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;)  as reqDate from account_period;# UNION types numeric and text cannot be matchedNULL::NUMERIC 这个问题，是因为几个sql组合在一起时，同一个字段的值，遇到null时，需要进行类型转换。# 对行记录定义行编号，使用函数ROW_NUMBER()# 按分数进行降序，然后给行记录标记行编号，可以作为排名来使用select           \tROW_NUMBER() OVER (ORDER BY score desc) AS sequence_number,\tname,scorefrom\tb_test# 数字转字符串  select cast(123 as VARCHAR); # 字符串转数字  select cast(&#x27;123&#x27; as INTEGER);\n\n86、python控制台输出带颜色的文字方法#格式：　　设置颜色开始 ：\\033[显示方式;前景色;背景色m#说明：前景色            背景色           颜色---------------------------------------30                40              黑色31                41              红色32                42              绿色33                43              黃色34                44              蓝色35                45              紫红色36                46              青蓝色37                47              白色显示方式           意义-------------------------0                终端默认设置1                高亮显示4                使用下划线5                闪烁7                反白显示8                不可见 #例子：\\033[1;31;40m    &lt;!--1-高亮显示 31-前景色红色  40-背景色黑色--&gt;\\033[0m          &lt;!--采用终端默认设置，即取消颜色设置--&gt;\n\n例子print(&#x27;紫红字体 \\033[1;35m hello world \\033[0m!&#x27;)print(&#x27;褐色背景绿色字体 \\033[1;32;43m hello world \\033[0m!&#x27;)print(&#x27;\\033[1;33;44mhello world\\033[0m&#x27;)\n\n\n87、控制台输出白色方框print(&#x27;█&#x27;)\n\n88、xadmin后台编辑多对多字段在models.py定义了多对多字段，想要在编辑时可以灵活使用这个字段的话，可以按以下方法设置：modes.py\nclass Book(models.Model):    title = models.CharField(verbose_name=&quot;书名&quot;, max_length=32)    second_title = models.CharField(verbose_name=&quot;副标题&quot;, max_length=32, blank=True, null=True)    author = models.CharField(verbose_name=&quot;作者&quot;, max_length=32)    translator = models.CharField(verbose_name=&quot;译者&quot;, max_length=32, blank=True, null=True)    intro = models.TextField(verbose_name=&quot;描述&quot;)    pic = models.FileField(verbose_name=&quot;封面图片&quot;, max_length=64, upload_to=&#x27;book_cover&#x27;, null=True, blank=True)    tags = models.ManyToManyField(Tags, verbose_name=&#x27;书籍标签&#x27;, blank=True)    prizes = models.ManyToManyField(Prizes, verbose_name=&#x27;获奖详情&#x27;, blank=True)    sump = models.IntegerField(verbose_name=&quot;收藏人数&quot;, default=0)    rate_num = models.IntegerField(verbose_name=&quot;评分人数&quot;, default=0)    num = models.IntegerField(verbose_name=&quot;浏览量&quot;, default=0)    published_time = models.DateField(blank=True, null=True, verbose_name=&#x27;出版时间&#x27;)    create_time = models.DateTimeField(auto_now_add=True, verbose_name=&#x27;创建时间&#x27;)    class Meta:        db_table = &#x27;book&#x27;        verbose_name = &quot;图书&quot;        verbose_name_plural = &quot;图书&quot;    def __str__(self):        return self.title\n\nadminx.py\n# 书籍管理class BookAdmin(object):    search_fields = [&#x27;title&#x27;, &#x27;author&#x27;, &#x27;intro&#x27;]  # 检索字段    list_display = [&#x27;id&#x27;, &#x27;show_pic&#x27;, &#x27;title&#x27;, &#x27;second_title&#x27;, &#x27;author&#x27;, &#x27;translator&#x27;, &#x27;published_time&#x27;, &#x27;intro&#x27;,                    &#x27;tags&#x27;, &#x27;prizes&#x27;, &#x27;num&#x27;, &#x27;sump&#x27;, &#x27;rate_num&#x27;]  # 要显示的字段    list_filter = [&#x27;published_time&#x27;, &#x27;tags&#x27;, &#x27;prizes&#x27;]  # 分组过滤的字段    ordering = (&#x27;id&#x27;,)  # 设置默认排序字段，负号表示降序排序    list_per_page = 30  # 默认每页显示多少条记录，默认是100条    model_icon = &#x27;fa fa-book&#x27;  # 左侧小图标    list_editable = [&#x27;title&#x27;, &#x27;author&#x27;, &#x27;intro&#x27;, &#x27;published_time&#x27;]  # 可编辑字段    style_fields = &#123;&#x27;tags&#x27;: &#x27;m2m_transfer&#x27;, &#x27;prizes&#x27;: &#x27;m2m_transfer&#x27;&#125;  # 控制字段的显示样式    filter_horizontal = (&#x27;tags&#x27;, &#x27;prizes&#x27;)  # 水平选择编辑多对多字段\n\n重点是设置style_fields 和filter_horizontal ，效果：\n\n89、Django后台通过按钮显示TextField字段内容由于TextField字段类型内容可能很长，在后台显示时很占屏幕位置，可以通过按钮来控制显示，代码如下：models.py中定义了一个TextField字段类型：\nclass Prizes(models.Model):    name = models.CharField(max_length=32, verbose_name=&quot;奖项&quot;)    intro = models.TextField(blank=True, null=True, verbose_name=&#x27;简介&#x27;)    class Meta:        db_table = &#x27;prizes&#x27;        verbose_name = &quot;奖项&quot;        verbose_name_plural = &quot;奖项&quot;    def __str__(self):        return self.name\n\n这里使用xadmin作为后台管理框架，在adminx.py中代码如下：\nimport xadminfrom django.utils.safestring import mark_safefrom xadmin import viewsfrom .models import *# 奖项管理class PrizesAdmin(object):    search_fields = [&#x27;name&#x27;]  # 检索字段    list_display = [&#x27;id&#x27;, &#x27;name&#x27;, &#x27;show_intro&#x27;]    list_filter = [&#x27;name&#x27;]    ordering = (&#x27;id&#x27;,)    def show_intro(self, obj):        # 显示简介        if not obj.intro:            return mark_safe(&#x27;&#x27;)        if len(obj.intro) &lt; 20:            return mark_safe(obj.intro)        short_id = f&#x27;&#123;obj._meta.db_table&#125;_short_text_&#123;obj.id&#125;&#x27;        short_text_len = len(obj.intro) // 4        short_text = obj.intro[:short_text_len] + &#x27;......&#x27;        detail_id = f&#x27;&#123;obj._meta.db_table&#125;_detail_text_&#123;obj.id&#125;&#x27;        detail_text = obj.intro        text = &quot;&quot;&quot;&lt;style type=&quot;text/css&quot;&gt;                        #%s,%s &#123;padding:10px;border:1px solid green;&#125;                   &lt;/style&gt;                    &lt;script type=&quot;text/javascript&quot;&gt;                    function openShutManager(oSourceObj,oTargetObj,shutAble,oOpenTip,oShutTip,oShortObj)&#123;                        var sourceObj = typeof oSourceObj == &quot;string&quot; ? document.getElementById(oSourceObj) : oSourceObj;                        var targetObj = typeof oTargetObj == &quot;string&quot; ? document.getElementById(oTargetObj) : oTargetObj;                        var shortObj = typeof oShortObj == &quot;string&quot; ? document.getElementById(oShortObj) : oShortObj;                        var openTip = oOpenTip || &quot;&quot;;                        var shutTip = oShutTip || &quot;&quot;;                        if(targetObj.style.display!=&quot;none&quot;)&#123;                           if(shutAble) return;                           targetObj.style.display=&quot;none&quot;;                           shortObj.style.display=&quot;block&quot;;                           if(openTip  &amp;&amp;  shutTip)&#123;                            sourceObj.innerHTML = shutTip;                            &#125;                        &#125; else &#123;                           targetObj.style.display=&quot;block&quot;;                           shortObj.style.display=&quot;none&quot;;                           if(openTip  &amp;&amp;  shutTip)&#123;                            sourceObj.innerHTML = openTip;                            &#125;                        &#125;                        &#125;                    &lt;/script&gt;                    &lt;p id=&quot;%s&quot;&gt;%s&lt;/p&gt;                    &lt;p&gt;&lt;a href=&quot;###&quot; οnclick=&quot;openShutManager(this,&#x27;%s&#x27;,false,&#x27;点击关闭&#x27;,&#x27;点击展开&#x27;,&#x27;%s&#x27;)&quot;&gt;点击展开&lt;/a&gt;&lt;/p&gt;                    &lt;p id=&quot;%s&quot; style=&quot;display:none&quot;&gt;                       %s                    &lt;/p&gt;                    &quot;&quot;&quot; % (short_id, detail_id, short_id, short_text, detail_id, short_id, detail_id, detail_text)        return mark_safe(text)    show_intro.short_description = &#x27;描述&#x27;\n\n注意：复制代码后需要做如下修改：\n\n一开始效果\n\n点击展开效果：\n90、前端判断上传的文件是否为图片且限制大小为300kB&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en-us&quot;&gt;&lt;body class=&quot;login&quot;&gt;&lt;input class=&quot;form-control input-lg&quot; id=&quot;id_icon&quot; name=&quot;icon&quot; type=&quot;file&quot; onchange=&quot;imgTypeSize(&#x27;id_icon&#x27;,300)&quot;&lt;script type=&quot;text/javascript&quot;&gt;    //判断是否为图片，若为图片，判断其大小是否大于0.3M    function imgTypeSize(FileId, maxsize) &#123;        /*获取图片内容对象*/        var imgFile = document.getElementById(FileId).files[0];        if (imgFile.name == &quot;&quot;) &#123;            alert(&quot;请上传头像哦&quot;);            return false;        &#125; else &#123;            /*图片类型正则验证*/            var imgStr = /\\.(jpg|jpeg|png|bmp|BMP|JPG|PNG|JPEG)$/;            if (!imgStr.test(imgFile.name)) &#123;                alert(&quot;文件不是图片类型&quot;);                return false;            &#125; else &#123;                /*图片大小*/                var imagSize = imgFile.size;                if (imagSize &lt; (1024 * maxsize)) &#123;                    return true;                &#125; else &#123;                    alert(imgFile.name + &quot;大小不能超过&quot; + maxsize + &quot;kB&quot;);                    document.getElementById(FileId).value = &quot;&quot;                    return false;                &#125;            &#125;        &#125;    &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n91、form表单提交前验证&lt;form action=&quot;&quot; method=&quot;post&quot; id=&quot;login-form&quot; onsubmit=&quot;return toVaild()&quot;&gt;\t&lt;input class=&quot;form-control&quot; id=&quot;id_account&quot; name=&quot;account&quot; type=&quot;text&quot; placeholder=&quot;账号&quot;/&gt;\t&lt;input class=&quot;form-control&quot; id=&quot;id_password&quot; name=&quot;password&quot; type=&quot;password&quot; placeholder=&quot;密码&quot;&gt;&lt;form&gt;&lt;script type=&quot;text/javascript&quot;&gt;    document.getElementById(&#x27;id_username&#x27;).focus()    function toVaild() &#123;        var account = document.getElementById(&quot;id_account&quot;).value;        var password = document.getElementById(&quot;id_password&quot;).value;        if (account == &quot;&quot; || password == &quot;&quot;) &#123;            alert(&quot;请输入账号和密码&quot;);            return false;        &#125; else &#123;            return true;        &#125;    &#125;&lt;/script&gt;\n\n92、有序字典import collectionsd1 = collections.OrderedDict()  # 创建一个有序字典d1[&#x27;a&#x27;] = &#x27;A&#x27;d1[&#x27;b&#x27;] = &#x27;B&#x27;d1[&#x27;c&#x27;] = &#x27;C&#x27;d1[&#x27;d&#x27;] = &#x27;D&#x27;for k, v in d1.items():    print(k, v)\n\n93、Python在Windows系统下实现TTS（文字转语音）导入包：\npip install pypiwin32import win32com.clientspk = win32com.client.Dispatch(&quot;SAPI.SpVoice&quot;)spk.Speak(u&quot;my name is ldc,what is your name&quot;)spk.Speak(u&quot;大家好&quot;)\n\n94、定义一个简单闹钟# pip install pypiwin32 -i https://pypi.python.org/simpleimport win32com.clientimport time import winsoundspk = win32com.client.Dispatch(&quot;SAPI.SpVoice&quot;)# 定义闹钟时间clocktime = [[19, 19], [11, 10], [12, 10], [18, 47]]  runinghour = 1  # 定义运行时间times = runinghour * 3600  # 次数print(times)for i in range(1, times):    time_now = [time.localtime(time.time()).tm_hour, time.localtime(time.time()).tm_min]    if time_now in clocktime:        print(time_now)        winsound.Beep(1000, 1000)        spk.Speak(u&quot;快去看下饭好了没有？&quot;)    time.sleep(60)  # 每分钟对比一次时间\n\n95、根据年月获取当月天数def get_month_days(year, month):    &quot;&quot;&quot;    根据年份，月份信息显示此月份天数    :param year: 年份：    :param month: 月份（1～12）：    :return: 当月天数    &quot;&quot;&quot;    if month &gt;12 or month &lt;= 0:        return -1    if month == 2:        return 29 if year % 4 == 0 and year % 100 != 0 or year % 400 == 0 else 28    if month in (4, 6, 9, 11):        return 30    else:        return 31a = &#x27;2020-04&#x27;.split(&#x27;-&#x27;)year = int(a[0])month = int(a[1])print(get_month_days(year,month))输出：30\n\n96、Django获取favicon.ico图标制作一个ico文件，使用PS或者某些在线生成ico的网站\n将此文件命名为“favicon.ico”后放在static&#x2F;下\n\n在urls.py中定义路由：\nfrom django.urls import pathfrom django.views.generic import RedirectViewurlpatterns = [\t# 访问favicon.ico 网站图标    path(&quot;favicon.ico&quot;,RedirectView.as_view(url=&#x27;static/favicon.ico&#x27;)),]\n\n97、django 静态文件配置settings.py\nSTATIC_URL = &#x27;/static/&#x27;# 添加静态资源路由地址STATICFILES_DIRS = [    os.path.join(BASE_DIR, &#x27;static&#x27;),]# 使用python manage.py collectstatic收集静态文件时时使用STATIC_ROOT# STATIC_ROOT = os.path.join(BASE_DIR, &#x27;static&#x27;)\n\nurls.py\nfrom django.urls import path, re_path\nfrom django.views.generic import RedirectView\nfrom django.views.static import serve\n\nfrom &#39;你的项目名称&#39; import settings\nurlpatterns = [\n   \n    path(&quot;favicon.ico&quot;,RedirectView.as_view(url=&#39;static/favicon.ico&#39;)),\n    re_path(&#39;static/(?P&lt;path&gt;.*)$&#39;, serve, &#123;&#39;document_root&#39;: settings.STATICFILES_DIRS[0]&#125;),\n    \n]\n\n98、django JsonResponse返回中文时显示unicode编码（\\u67e5\\u8be2）原因这个unicode编码，是python3默认返回的编码。\n解决方案JsonResponse里面有个参数json_dumps_params，设置为json_dumps_params&#x3D;{‘ensure_ascii’:False}即可。\ndata = &#123;&#x27;msg&#x27;: &#x27;创建成功&#x27;,&#125;return JsonResponse(data=data, json_dumps_params=&#123;&#x27;ensure_ascii&#x27;: False&#125;)\n\n99、获取当前时间月份的首日与最后一天import calendardef get_month_start_and_end(date=datetime.datetime.now()):    &quot;&quot;&quot;    获取当前时间的月份首日与最后一天    :param date:    :return: (首日，最后一天)    &quot;&quot;&quot;    year, month = str(date).split(&#x27;-&#x27;)[0], str(date).split(&#x27;-&#x27;)[1]    end = calendar.monthrange(int(year), int(month))[1]    return f&#x27;&#123;year&#125;-&#123;month&#125;-01&#x27;, f&#x27;&#123;year&#125;-&#123;month&#125;-&#123;end&#125;&#x27;\n\n100、xadmin后台批量操作adminx.py\nimport xadminfrom django.db.models import  Sumfrom xadmin.plugins.actions import BaseActionViewclass MyCountFeeAction(BaseActionView):    &quot;&quot;&quot;        用户余额统计        &quot;&quot;&quot;    action_name = &quot;countuserfee&quot;  #: 相当于这个 Action 的唯一标示, 尽量用比较针对性的名字    description = u&#x27;统计用户总余额&#x27;  #: 描述, 出现在 Action 菜单中, 可以使用 ``%(verbose_name_plural)s`` 代替 Model 的名字.    model_perm = &#x27;view&#x27;  # 权限    def do_action(self, queryset):        all_balance = MallUser.objects.all().aggregate(Sum(&#x27;balance&#x27;))        return HttpResponse(f&#x27;用户总余额&#123;all_balance&#125;&#x27;)class UserAdmin(object):    &quot;&quot;&quot;用户信息管理&quot;&quot;&quot;    list_display = [&#x27;username&#x27;, &#x27;balance&#x27;, &#x27;status&#x27;, &#x27;addtime&#x27;]    search_fields = [&#x27;username&#x27;, ]    list_filter = [&#x27;status&#x27;, &#x27;addtime&#x27;]    list_per_page = 30  # 默认每页数量    model_icon = &#x27;fa fa-user&#x27;    list_editable = [&#x27;status&#x27;]    ordering = [&#x27;-addtime&#x27;]    actions = [ MyCountFeeAction]  # 添加批量选择操作\n\n\n101、xadmin过滤器外键显示特定值（比如只能过滤自己与超级管理员定义的数据）首先，修改xadmin源码，修改xadmin&#x2F;filters.py,在401行，做如下修改，\n把self.lookup_choices = field.get_choices(include_blank=False)\n改为：\n\n# 调用自定义的方法\nif hasattr(model_admin, &#39;&#123;field&#125;_choices&#39;.format(field=field.name)):\n        self.lookup_choices = getattr(model_admin, &#39;&#123;field&#125;_choices&#39;.format(field=field.name))(field, request,params, model,model_admin,field_path)\n    else:\n        self.lookup_choices = field.get_choices(include_blank=False)\n\n如图:\n\n然后，在adminx.py中定义过滤的方法：\nimport xadminfrom django.db.models import  Q, Sumfrom xadmin.plugins.actions import BaseActionViewclass MeasurePointAdmin(object):    # search_fields = [&#x27;user__name&#x27;, &#x27;user__account&#x27;]  # 检索字段    list_display = [&#x27;num&#x27;, &#x27;elevation&#x27;, &#x27;correct_num&#x27;, &#x27;cumulative_amount&#x27;]    list_filter = [&#x27;user&#x27;, &#x27;is_default&#x27;, &#x27;create_time&#x27;]  # 分组过滤的字段    list_editable = [&#x27;num&#x27;, &#x27;elevation&#x27;, &#x27;correct_num&#x27;, &#x27;cumulative_amount&#x27;]    ordering = (&#x27;id&#x27;,)  # 设置默认排序字段，负号表示降序排序    list_per_page = 30  # 默认每页显示多少条记录，默认是100条    model_icon = &#x27;fa fa-users&#x27;  # 左侧小图标    readonly_fields = [&#x27;user&#x27;, &#x27;is_default&#x27;]    import_excel = True    actions = [MyCountFeeAction]\t\t# 定义的函数名必须是  字段名_choices    def user_choices(self, field, request, params, model, model_admin, field_path):        # 超级用户不做控制        if self.request.user.is_superuser:            return field.get_choices(include_blank=False)        # 过滤器只显示自己与超级管理员        user_lst = field.related_model._default_manager.filter(Q(id=self.request.user.id) | Q(is_superuser=True))        # 返回格式 [(&#x27;pk&#x27;,&#x27;标题&#x27;),]        return [(user.id, user.username) for user in user_lst]\n\n效果:\n\n102、Django中的CSRF局部禁用为了避免没有csrf token而产生的403的forbidden错误，可以使用csrf_exempt装饰器来处理POST、GET请求的View, 这种方式是CSRF局部禁用。\nfrom django.utils.decorators import method_decoratorfrom django.views.decorators.csrf import csrf_exempt@method_decorator(csrf_exempt)def update_data(request):    if request.method == &#x27;POST&#x27;:    \tpass\telif request.method == &#x27;GET&#x27;:    \tpass\n\n103、使用python命令创建django项目创建django项目方式一：直接打开pycharm创建，选择file-&gt;new project-&gt;django方式二：通过命令创建先创建虚拟环境：python -m venv django_venv然后导入django库：pip install django -i https://pypi.tuna.tsinghua.edu.cn/simple最后使用命令创建：django-admin startproject my_django_project\n104、 二维列表、二维数组行求和与列求和import pandas as pdfrom functools import reduce# 二维数组，对列和行求和a = [    [&#x27;&#x27;, 0, &#x27;&#x27;, 1, 4.1],    [&#x27;&#x27;, 0, &#x27;&#x27;, &#x27;&#x27;, 4],    [&#x27;123&#x27;, 0, &#x27;&#x27;, 3, 4, 6,7],]def aa(x, y):    x = 0 if isinstance(x, str) else x    y = 0 if isinstance(y, str) else y    return x + y# 对行求和row_sum = [reduce(aa, i) for i in a]# 对列求和，只能处理相同长度的子元素column_sum_1 = [reduce(aa, i) for i in zip(*a)]# 对列求和，可以处理不同长度的子元素column_sum_2 = list(dict(pd.DataFrame(a).fillna(0).apply(lambda x: &#x27;&#x27; if any(isinstance(d, str) for d in x) else round(x.sum(), 2))).values())print(&#x27;行求和：&#123;&#125;\\r\\n列求和(相同长度)：&#123;&#125;\\r\\n列求和：&#123;&#125;&#x27;.format(row_sum, column_sum_1, column_sum_2))\n\n输出：\n行求和：[5.1, 4, 20]列求和(相同长度)：[0, 0, 0, 4, 12.1]列求和：[&#x27;&#x27;, 0, &#x27;&#x27;, &#x27;&#x27;, 12.1, 6.0, 7.0]\n\n105、获取时间字符串的月份数from datetime import datetime    def get_months(start_month_str, end_month_str):    &#x27;&#x27;&#x27;    # 获取时间字符串中的月份数    :param start_month_str: 开始字符串    :param end_month_str: 结束字符串    :return: 月份数    &#x27;&#x27;&#x27;    end_month_date = datetime.strptime(end_month_str, &#x27;%Y-%m&#x27;)    start_month_date = datetime.strptime(start_month_str, &#x27;%Y-%m&#x27;)    end_year, end_month = end_month_date.year, end_month_date.month    start_year, start_month = start_month_date.year, start_month_date.month    return (end_year - start_year) *12 + (end_month - start_month) + 1end_month_str = &#x27;2021-02&#x27;start_month_str = &#x27;2020-07&#x27;print(get_months(start_month_str, end_month_str))输出：8\n\n106、字符串不足补零print(&#x27;hello world&#x27;.zfill(15)) # 补0print(&#x27;hello world&#x27;.rjust(15)) # 右对齐，补空格print(&#x27;hello world&#x27;.ljust(15)) # 左对齐，补空格输出：0000hello world    hello worldhello world  \n\n107、时间戳转字符串日期import timet1 = time.time()print(t1)print(time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime(t1)))输出：1621741567.0821922021-05-23 11:46:07\n\n使用函数：\n# !/usr/bin/python# -*- coding: utf-8 -*-&quot;&quot;&quot;@contact: 微信 1257309054@file: 时间戳转日期.py@time: 2022/6/27 17:16@author: LDC&quot;&quot;&quot;import timeimport datetime# 正确10位长度的时间戳可精确到秒，11-14位长度则是包含了毫秒def int_to_datetime(intValue):    if len(str(intValue)) == 10:        # 精确到秒        timeValue = time.localtime(intValue)        tempDate = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, timeValue)        datetimeValue = datetime.datetime.strptime(tempDate, &quot;%Y-%m-%d %H:%M:%S&quot;)    elif 10 &lt; len(str(intValue)) and len(str(intValue)) &lt; 15:        # 精确到毫秒        k = len(str(intValue)) - 10        timetamp = datetime.datetime.fromtimestamp(intValue / (1 * 10 ** k))        datetimeValue = timetamp.strftime(&quot;%Y-%m-%d %H:%M:%S.%f&quot;)    else:        return -1    return datetimeValuetime1 = 1656321420time2 = 1656321086560print(int_to_datetime(time1))print(int_to_datetime(time2))&#x27;&#x27;&#x27;输出：2022-06-27 17:17:002022-06-27 17:11:26.560000&#x27;&#x27;&#x27;\n\n108、列表转字符串a = [1,2,3]print(&#x27;,&#x27;.join(map(str,a)))输出：`1,2,3`\n\n109、pip国内镜像源pip install 库名 -i https://pypi.tuna.tsinghua.edu.cn/simple清华：-i https://pypi.tuna.tsinghua.edu.cn/simple阿里云：-i http://mirrors.aliyun.com/pypi/simple/中国科技大学 -i https://pypi.mirrors.ustc.edu.cn/simple/华中理工大学：-i http://pypi.hustunique.com/山东理工大学：-i http://pypi.sdutlinux.org/ 豆瓣：-i http://pypi.douban.com/simple/\n\n110、python把时间字符串转换成刚刚、1天前、3个月前、1年前import datetimeimport timedef date_interval(date_str):    &#x27;&#x27;&#x27;    获取时间间隔    1分钟前，2分钟前，10分钟前，1小时前，2小时前，1天前，2天前，3天前，1个月前，3个月前，1年前，3年前    :param date_str: 时间字符串    :return: 字符串    &#x27;&#x27;&#x27;    date_str = time.strptime(date_str, &#x27;%Y-%m-%d %H:%M:%S&#x27;)    # 将时间元组转换为时间戳    t = time.mktime(date_str)    # 当前时间    seconds = time.time() - t    years = int(seconds // (60 * 60 * 24 * 365))    if years:        return &#x27;&#123;&#125;年前&#x27;.format(years)    months = int(seconds // (60 * 60 * 24 * 30))    if months:        return &#x27;&#123;&#125;月前&#x27;.format(months)    days = int(seconds // (60 * 60 * 24))    if days:        return &#x27;&#123;&#125;天前&#x27;.format(days)    hours = int(seconds // (60 * 60))    if hours:        return &#x27;&#123;&#125;小时前&#x27;.format(hours)    minutes = int(seconds // (60))    if minutes:        return &#x27;&#123;&#125;分钟前&#x27;.format(minutes)    return &#x27;刚刚&#x27;if __name__ == &#x27;__main__&#x27;:    date1 = &#x27;2019-07-10 15:27:51&#x27;    date2 = &#x27;2021-07-10 15:27:51&#x27;    date3 = &#x27;2021-08-10 15:27:51&#x27;    date4 = &#x27;2021-08-12 11:01:51&#x27;    date5 = datetime.datetime.now() + datetime.timedelta(seconds=-3)    date5 = date5.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;)    print(date_interval(date1))    print(date_interval(date2))    print(date_interval(date3))    print(date_interval(date4))    print(date_interval(date5))\n\n111、Django使用ORM执行sql语句通过raw函数执行\nalarm_datas = gsm.AlertMessage.objects.raw(&#x27;&#x27;&#x27;                select am_all.id, am_all.sensor_number                    FROM alert_message as am_all                    where                         am_all.real=&#x27;1&#x27;                        and am_all.is_show=1                    order by am_all.alarm_level desc                &#x27;&#x27;&#x27;)for ad in alarm_datas:\tprint(ad.sensor_number)\n\n112、Django通过变量字段获取数据通过方法__getattribute__来获取\nalert_messages = AlertMessage.objects.filter(real=0)am_fields = [&#x27;id&#x27;, &#x27;real&#x27;, &#x27;name&#x27;]for am in alert_messages:\tfor i in range(len(am_fields)):\t\tprint(am_fields[i], am.__getattribute__(am_fields[i]))\n\n113、Django查询变量字段、更新变量字段通过**&#123;变量名:值&#125;来操作\nfield = &#x27;device_code&#x27;# 查询device_infos = gsm.DeviceInfo.objects.filter(**&#123;field: &#x27;012&#x27;&#125;)# 更新gsm.DeviceInfo.objects.filter(device_code=&#x27;012&#x27;).update(**&#123;field : &#x27;0&#x27;&#125;)\n\n114、vue生成dist文件安装npm，到官网下载在vue项目下打开cmd，输入命令\nnpm run build\n\n如果报错，npm ERR! missing script: build，则使用以下命令\nnpm run build:prod\n\n具体看package.json\n\n115、python获取电脑磁盘、CPU、内存使用情况import psutil#  pip install psutil# 获取本机磁盘使用率和剩余空间G信息def get_disk_info():    # 循环磁盘分区    content = &quot;&quot;    for disk in psutil.disk_partitions():        # 读写方式 光盘 or 有效磁盘类型        if &#x27;cdrom&#x27; in disk.opts or disk.fstype == &#x27;&#x27;:            continue        disk_name_arr = disk.device.split(&#x27;:&#x27;)        disk_name = disk_name_arr[0]        disk_info = psutil.disk_usage(disk.device)        # 磁盘剩余空间，单位G        free_disk_size = disk_info.free//1024//1024//1024        # 当前磁盘使用率和剩余空间G信息        info = &quot;&#123;&#125;盘使用率：&#123;&#125;%%， 剩余空间：&#123;&#125;G &quot;.format(disk_name, str(disk_info.percent), free_disk_size)        # 拼接多个磁盘的信息        content = content + info    print(content)# cpu信息def get_cpu_info():    cpu_percent = psutil.cpu_percent(interval=1)    cpu_info = &quot;CPU使用率：%i%%&quot; % cpu_percent    print(cpu_info)# 内存信息def get_memory_info():    virtual_memory = psutil.virtual_memory()    used_memory = virtual_memory.used/1024/1024/1024    free_memory = virtual_memory.free/1024/1024/1024    memory_percent = virtual_memory.percent    memory_info = &quot;内存使用：%0.2fG，使用率%0.1f%%，剩余内存：%0.2fG&quot; % (used_memory, memory_percent, free_memory)    print(memory_info)if __name__ == &#x27;__main__&#x27;:    get_disk_info()    get_cpu_info()    get_memory_info()\n\n116、max比较字典列表&#x27;&#x27;&#x27;使用max函数比较字典列表对象需求：找出用户组最大id的字典&#x27;&#x27;&#x27;def com_id(f):    &#x27;&#x27;&#x27;    比较用用户ids列表    :param f: 字典    :return: 返回最大的用户id    &#x27;&#x27;&#x27;    return max(f[&#x27;user_ids&#x27;])friends_added = [        &#123;&#x27;user_ids&#x27;: [1, 2], &#x27;create_at&#x27;: &#x27;2020-01-01&#x27;&#125;,        &#123;&#x27;user_ids&#x27;: [3, 6], &#x27;create_at&#x27;: &#x27;2020-01-02&#x27;&#125;,        &#123;&#x27;user_ids&#x27;: [2, 1], &#x27;create_at&#x27;: &#x27;2020-02-02&#x27;&#125;,        &#123;&#x27;user_ids&#x27;: [4, 1], &#x27;create_at&#x27;: &#x27;2020-02-02&#x27;&#125;,    ]# max函数中使用key参数，指定自定义函数来比较item = max(friends_added, key=com_id)item_1 = max(friends_added, key=lambda f: max(f[&#x27;user_ids&#x27;])) # com_id可以转成lambda函数print(item)print(item_1)输出：&#123;&#x27;user_ids&#x27;: [3, 6], &#x27;create_at&#x27;: &#x27;2020-01-02&#x27;&#125;&#123;&#x27;user_ids&#x27;: [3, 6], &#x27;create_at&#x27;: &#x27;2020-01-02&#x27;&#125;\n\n117、django查询表的具体字段ExampleModel.objects.values(&#x27;id&#x27;, &#x27;username&#x27;)# 返回的结果是QuerySet， 里面的元素是dict格式# [&#123;&#x27;id&#x27;:1, &#x27;username&#x27;: &#x27;Austin&#x27;&#125;, &#123;&#x27;id&#x27;:2, &#x27;username&#x27;:&#x27;Sam&#x27;&#125;, ...]# 相当于SQL中的SELECT id, username FROM ......, # 只返回对应属性（字段）的值\n\n118、MySQL查询数据添加自增序号set @i = 0;select waveform, &#x27;沿桥风吹&#x27; as label ,(@i:=@i+1) xh from alert_message where is_real=1 and node_id=138\n\n119、MySQL 时间截取年月日select id,\t\t\taddtime, \t\t\tdate_format(addtime,&#x27;%Y-%m-%d&#x27;) as short_time \tfrom alert_message \twhere date_format(addtime,&#x27;%Y-%m-%d&#x27;) = &#x27;2022-03-13&#x27;\n\n\n120、 列表取奇数下标值list1=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;]print(&#x27;奇数下标值&#x27;,list1[1::2])输出：奇数下标值 [&#x27;b&#x27;, &#x27;d&#x27;]\n\n121、列表取偶数下标值list1=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;]print(&#x27;偶数下标值&#x27;,list1[::2])偶数下标值 [&#x27;a&#x27;, &#x27;c&#x27;, &#x27;e&#x27;]\n\n122、列表相同元素分类、分组import itertoolsdata = [1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 1, &#x27;a&#x27;, &#x27;a&#x27;]a =[list(group) for key, group in itertools.groupby(data)]print(a)输出：[[1], [2, 2, 2, 2], [3, 3, 3], [4, 4, 4, 4], [1], [&#x27;a&#x27;, &#x27;a&#x27;]]\n\n123、ubuntu切换用户1）从user用户切换到root用户sudo su2）从root用户切回user用户su user (user是你自己安装时候的用户名)，或是直接输入exit，也可Ctrl+D组合键推出\n124、numpy二维数组获取某一列import numpy as npa = [    [1, 2, 3, 4, 5, 6],    [7, 8, 9, 10, 11, 12],    [13.2, 14.8, 15.9, 16.10, 16.11, 17.12],]a_np = np.array(a)  # 把二维列表转成numpy数组print(&#x27;第一行&#x27;, a_np[0].tolist())  # 获取第一行print(&#x27;第一列&#x27;, a_np[:, 0].tolist())  # 获取第一列输出：第一行 [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]第一列 [1.0, 7.0, 13.2]\n\n\n","categories":["编程"],"tags":["编程","Python"]},{"title":"【解决办法】树莓派系统使用PIP安装ultralytics失败","url":"/2025/10/09/%E3%80%90%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E3%80%91%E6%A0%91%E8%8E%93%E6%B4%BE%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8PIP%E5%AE%89%E8%A3%85ultralytics%E5%A4%B1%E8%B4%A5/","content":"树莓派系统使用PIP安装ultralytics失败，解决办法：虚拟环境smp4bu@raspberrypi:~ $ pip install ultralytics[export]error: externally-managed-environment× This environment is externally managed╰─&gt; To install Python packages system-wide, try apt install    python3-xyz, where xyz is the package you are trying to    install.    If you wish to install a non-Debian-packaged Python package,    create a virtual environment using python3 -m venv path/to/venv.    Then use path/to/venv/bin/python and path/to/venv/bin/pip. Make    sure you have python3-full installed.    For more information visit http://rptl.io/venvnote: If you believe this is a mistake, please contact your Python installation or OS distribution provider. You can override this, at the risk of breaking your Python installation or OS, by passing --break-system-packages.hint: See PEP 668 for the detailed specification.\n\n\n\n你遇到的错误信息表明你正在一个“外部管理的环境”中尝试安装 ultralytics 包。这是因为你的 Python 安装是通过操作系统的包管理工具（如 apt）进行管理的。\n解决方法1. 创建虚拟环境最推荐的解决方法是创建一个虚拟环境，这样你可以在其中自由安装和管理 Python 包，而不会影响系统级的 Python 安装。以下是具体步骤：\n\n安装 python3-venv（如果还没有安装）：\nsudo apt install python3-venv\n\n创建一个虚拟环境：\npython3 -m venv myenv\n这里 myenv 是你虚拟环境的名称，可以根据需要更改。\n\n激活虚拟环境：\nsource myenv/bin/activate\n\n安装 ultralytics 包：在虚拟环境激活后，你可以使用 pip 安装 ultralytics：\npip install ultralytics[export]\n\n使用虚拟环境：每次需要使用这个环境时，记得先激活它。使用完成后，可以通过 deactivate 命令退出虚拟环境。\n\n\n2. 使用系统包管理器（不推荐）如果你希望使用系统包管理器来安装某个特定的 Python 包，虽然不推荐，但你可以尝试使用 apt：\nsudo apt install python3-ultralytics\n请注意，这可能没有最新版本。\n3. 直接覆盖（不推荐）如果你非常确定要在系统环境中安装，可以使用 --break-system-packages 选项，但这样做风险较高，可能会导致系统不稳定：\npip install ultralytics[export] --break-system-packages\n\n总结创建虚拟环境是最安全和推荐的方式，它可以帮助你避免对系统环境造成影响，同时允许你自由地管理和安装 Python 包。\n","categories":["Linux"],"tags":["树莓派","Linux"]},{"title":"我的第一个GitHub仓库","url":"/2025/10/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAGitHub%E4%BB%93%E5%BA%93/","content":"Code Circus 🎪我的代码马戏团 - 记录学习CS每一步的代码仓库\n🎯 项目徽章\n🎪 马戏团大帐🎩 核心内容├── 📖 教材实践│   ├── 🎒 课堂练习│   └── 🏡 课后习题├── 🔬 实验报告│   └── 📦 各学期实验存档  \n🎭 专项训练├── 🏆 算法竞技场│   ├── 🥇 蓝桥杯真题│   └── 🥈 LeetCode精选  \n🎨 创意工坊├── ✨ 代码片段│   ├── 💡 灵感实现│   └── 🎁 实用工具  \n🚀 技术飞轮\n🌟 马戏团特色\n🎯 多语言学习路径：C&#x2F;C++ → Java → Python → ASM 的渐进式学习\n🧠 知识图谱：语法基础 → 数据结构 → 算法实战 → 系统设计\n📝 注释规范：每个案例含「实现思路」「复杂度分析」「应用场景」注释\n🚴 持续更新：代码练习 + 学习笔记\n\nStar History\n \n  \n\n“The magic of myth and legend has come true in our generation.With the right spell on the keyboard, the display comes alive,full of things that couldn’t have existed or happened before.”  \n—— Frederick Brooks《人月神话》\n","categories":["日常"],"tags":["编程","日常","Github"]},{"title":"第十四届蓝桥杯第二期模拟赛题解","url":"/2025/10/12/%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AC%AC%E4%BA%8C%E6%9C%9F%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/","content":"第十四届蓝桥杯第二期模拟赛题解A题(填空题)题面请找到一个大于 2022 的最小数，这个数转换成二进制之后，最低的 6 个二进制为全为 0 。请将这个数的十进制形式作为答案提交。\n算法(枚举)直接枚举即可。更新：本题应该是只需要低六位都为0即可，一开始在做的时候以为第7位应该不能为0。\n代码(C++)答案：2112（正解：2048）\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;string get(int x)&#123;string s;while(x)&#123;s += x % 2 + &#x27;0&#x27;;x /= 2;&#125;if(s[0] == s[1] &amp;&amp; s[1] == s[2] &amp;&amp; s[2] == s[3]&amp;&amp; s[3] == s[4] &amp;&amp; s[4] == s[5] &amp;&amp; s[0] == &#x27;0&#x27;)&#123;cout &lt;&lt; &quot;res&quot;;&#125;reverse(s.begin(), s.end());return s;&#125;int get_res(string s)&#123;int res = 0;for(int i = 0; i &lt; s.size(); i ++) res = res * 2 + s[i] - &#x27;0&#x27;;cout &lt;&lt; res &lt;&lt; endl;return res;&#125;int main()&#123;// string s;//// int x = 2022;// while(x)// &#123;// s += x % 2 + &#x27;0&#x27;;// x /= 2;// &#125;//// for(int i = 2023; i &lt;= 10000; i ++)// cout &lt;&lt; get(i) &lt;&lt; endl;// 100001000000get_res(&quot;100000000000&quot;);// reverse(s.begin(), s.end());// cout &lt;&lt; s &lt;&lt; endl;return 0;&#125;\nB题(填空题)题面我们计从 1949 年 10 月 1 日至 1949 年 10 月 2 日为经过了 1 天。请问从 1949 年 10 月 1 日至 2022 年 1 月 1 日经过了多少天？\n算法(模拟)模拟即可。\n代码(c++)答案：26390\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int months[12] = &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30&#125;;bool is_leapYear(int y)&#123;return y % 400 == 0 || (y % 100 != 0 &amp;&amp; y % 4 == 0);&#125;int get(int y, int m, int d)&#123;int res = d;for(int i = 1949; i &lt; y; i ++)if(is_leapYear(i)) res += 366;else res += 365;for(int i = 0; i &lt; m; i ++)res += months[i];if(m &gt; 2 &amp;&amp; is_leapYear(y)) res ++;return res;&#125;int main()&#123;cout &lt;&lt; get(2022, 1, 1) - get(1949, 10, 1) &lt;&lt; endl;return 0;&#125;\nC题(填空题)题面8518 是一个非常特殊的数，如果把这个数看成 16 进制数，它的值为 (8518)16&#x3D;8161616+51616+116+8&#x3D;34072，而 34072 正好是 8518 的整数倍。9558 也是这样一个数，当看成 16 进制时是 38232。其实长度为 1 的数 0 到 9 都满足看成 16 进制后是自己的整数倍（1倍）。请问，除开长度为 1 的数，最小的满足这样条件的数是多少？\n算法(枚举)枚举即可。\n代码(c++)答案：1038\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;bool check(int x)&#123;string s = to_string(x);int res = 0;for(int i = 0; i &lt; s.size(); i ++) res = res * 16 + s[i] - &#x27;0&#x27;;return res % x == 0;&#125;int main()&#123;int x = 10;while(true)&#123;if(check(x))&#123;cout &lt;&lt; x &lt;&lt; endl;break;&#125;x ++;&#125;return 0;&#125;\nD题(填空题)题面小蓝有一个 30 行 60 列的数字矩阵，矩阵中的每个数都是 0 到 9 之间的数字。现在小蓝想从这个矩阵的第一行第一列画一条折线到第 30 行 60 列，线只能沿水平向右走或竖直向下走，只能在有数字的地方拐弯。小蓝想知道，这样一条线经过的数字的和最大是多少。\n\n本题的输入在文章底部。\n\n算法(线性DP)线性DP，状态计算为：$f[i,j]&#x3D;max(max(f[i - 1][j], f[i][j - 1])) + v$，$v$是该点的权值。答案为$f[30][60]$。\n代码(c++)答案：592\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 35, M = 65;int n = 30, m = 60;char g[N][M];int f[N][M];int main()&#123;for(int i = 1; i &lt;= n; i ++) scanf(&quot;%s&quot;, g[i] + 1);// cout &lt;&lt; &quot;?&quot; &lt;&lt; endl;for(int i = 1; i &lt;= n; i ++)for(int j = 1; j &lt;= m; j ++)&#123;f[i][j] = max(f[i - 1][j], f[i][j - 1]) + g[i][j] - &#x27;0&#x27;;&#125;cout &lt;&lt; f[n][m] &lt;&lt; endl;return 0;&#125;\nE题(填空题)题面将 2022 拆分成不同的质数的和，请问最多拆分成几个？\n算法(判断质数,01背包求方案数)可以通过枚举$2$到$2022$间的数，对于每个数判断一下是否是质数(共307个)，也可以用线性筛求解质数，接下来本题的意思就是在一堆质数中选取最多的质数个数来凑成2022，并且每一个质数只能选一次，直接上01背包的板子即可，但是需要注意，最终还需求解方案数，01背包的方案数求解就是最终的状态是通过哪一步得来的，一直往前找，一直到最开始的状态，这期间所经历得到状态个数就是答案。\n代码(C++)答案：32\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 2100;int n = 307, m = 2022;int cnt = 0;int primes[N];bool st[N];int f[310][N];void get_primes(int n)&#123;for(int i = 2; i &lt;= n; i ++)&#123;if(!st[i])&#123;primes[++ cnt] = i;for(int j = i + i; j &lt;= n; j += i) st[j] = true;&#125;&#125;&#125;int main()&#123;get_primes(2022);for(int i = 1; i &lt;= n; i ++)for(int j = 2; j &lt;= m; j ++)&#123;if(primes[i] &lt;= j)&#123;f[i][j] = max(f[i - 1][j], f[i - 1][j - primes[i]] + primes[i]);&#125;else f[i][j] = f[i - 1][j];&#125;int j = m, res = 0;for(int i = n; i; i --)if(f[i][j] != f[i - 1][j]) &#123;j -= primes[i];res ++;cout &lt;&lt; primes[i] &lt;&lt; &#x27; &#x27;;&#125;puts(&quot;&quot;);// cout &lt;&lt; f[n][m] &lt;&lt; endl;cout &lt;&lt; res &lt;&lt; endl;return 0;&#125;\nF题题面小蓝正在拷贝一份文件，他现在已经拷贝了 t 秒时间，已经拷贝了 c 字节，文件总共有 s 字节，如果拷贝是匀速进行的，请问小蓝大概还需要拷贝多少秒？\n输入格式输入一行包含三个整数 t, c, s，相邻两个整数之间用一个空格分隔。\n输出格式输出一个整数，表示答案。数据保证答案正好是整数。\n数据范围对于 50% 的评测用例，1 &lt;&#x3D; t, c, s &lt;&#x3D; 10000。对于所有评测用例，1 &lt;&#x3D; t, c, s &lt;&#x3D; 1000000000。\n算法(模拟)模拟即可，对于通过求解速度$v&#x3D;c&#x2F;t$的方式来解答本题会在样例$2$就RE了，具体就是$c&#x2F;t$的计算方式会导致其值为0，导致程序中出现除0的代码行，不妨将整个式子写下来，即$answer&#x3D;(s-c)&#x2F;(c&#x2F;t)&#x3D;(s-c)\\times t&#x2F;c$，题目保证答案一定为整数，只需注意数据范围最大为$1e9$，分子相乘会爆$int$，需要用$long\\ long$来表示答案。\n代码(C++)#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int t, c, s;// (s - c) * t / c// 1000000000 big dataint main()&#123;scanf(&quot;%d%d%d&quot;, &amp;t, &amp;c, &amp;s);printf(&quot;%lld\\n&quot;, (s - c) * 1ll * t / c);return 0;&#125;\nG题题面小蓝有 n 个单词，但是单词中有一些是重复的，请帮小蓝去除重复的单词。\n输入格式输入第一行包含一个正整数 n ，表示小蓝的单词数量。接下来 n 行，每行包含一个由小写字母组成的单词。\n输出格式请输出去除重复后的那些单词。如果一个单词出现了多遍，请保留第一次出现的单词，去除之后出现的单词，按输入的顺序输出。\n数据范围对于所有评测用例，1 &lt;&#x3D; n &lt;&#x3D; 100，每个单词的长度不超过 100。\n算法(哈希表)读取数据后，按顺序输出，在输出判断当前字符串是否输出过，没有出现过则输出一行后换行，否则跳过，再在哈希表中存下当前的字符串，在C++中可用$unordered\\underline{~}map$来当作哈希表使用。\n代码(C++)#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;using namespace std;const int N = 110;int n;string words[N];unordered_map&lt;string, int&gt; mp;int main()&#123;cin &gt;&gt; n;for(int i = 0; i &lt; n; i ++)&#123;cin &gt;&gt; words[i];// mp[words[i]] ++ ;&#125;for(int i = 0; i &lt; n; i ++)&#123;string s = words[i];if(!mp.count(s)) cout &lt;&lt; s &lt;&lt; endl;mp[s] ++ ;&#125;return 0;&#125;\nH题题面一个字符串如果从左向右读和从右向左读相同，则称为一个回文串，例如 lanqiaoaiqnal 是一个回文串。小蓝有一个字符串，请将这个字符串右边加上一些字符，使其成为一个回文串。如果有多种方案，请输出最短的回文串。\n输入格式输入一行包含一个字符串，由小写英文字母组成。\n输出格式输出一行包含答案。\n数据范围对于所有评测用例，1 &lt;&#x3D; 字符串长度 &lt;&#x3D; 100。\n算法(贪心,双指针)枚举字符串中最长的回文后缀即可，枚举出来后，此时的前缀（可能为空）进行反转后就是应当加在最开始字符串的后面，输出答案即可。\n代码(C++)#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int n;string s;bool check(string s)&#123;int i = 0, j = s.size() - 1;while(i &lt; j)if(s[i ++] != s[j --])return false;return true;&#125;int main()&#123;cin &gt;&gt; s;n = s.size();for(int i = 0, len = n; i &lt; n; i ++, len --)&#123;string t = s.substr(i, len);if(check(t))&#123;string prev = s.substr(0, i);string post = prev;if(prev.size())&#123;reverse(post.begin(), post.end());cout &lt;&lt; prev + t + post &lt;&lt; endl;return 0;&#125;else&#123;cout &lt;&lt; t &lt;&lt; endl;return 0;&#125;&#125;&#125;return 0;&#125;\nI题题面给定一个字母矩阵。一个 X 图形由中心点和由中心点向四个45度斜线方向引出的直线段组成，四条线段的长度相同，而且四条线段上的字母和中心点的字母相同。　　一个 X图形可以使用三个整数 r, c, L 来描述，其中 r, c 表示中心点位于第 r 行第 c 列，正整数 L 表示引出的直线段的长度。 对于 1 到 L 之间的每个整数 i，X图形满足：第 r-i 行第 c-i 列与第 r 行第 c 列相同，第 r-i 行第 c+i 列与第 r 行第 c 列相同，第 r+i 行第 c-i 列与第 r 行第 c 列相同，第 r+i 行第 c+i 列与第 r 行第 c 列相同。　　例如，对于下面的字母矩阵中，所有的字母 L 组成一个 X图形，其中中间的 5 个 L 也组成一个 X图形。所有字母 Q 组成了一个 X图形。　　LAAALA　　ALQLQA　　AALQAA　　ALQLQA　　LAAALA　　给定一个字母矩阵，请求其中有多少个 X图形。\n输入格式输入第一行包含两个整数 n, m，分别表示字母矩阵的行数和列数。接下来 n 行，每行 m 个大写字母，为给定的矩阵。\n输出格式输出一行，包含一个整数，表示答案。\n数据范围对于 50% 的评测用例，1 &lt;&#x3D; n, m &lt;&#x3D; 10。对于所有评测用例，1 &lt;&#x3D; n, m &lt;&#x3D; 100。\n算法(枚举)由于本题的数据量较小，暴力枚举即可，细节见代码。\n代码(C++)#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110;int n, m;char g[N][N];inline bool isInner(int x, int y)&#123;return x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m;&#125;inline bool check(char c, int x, int y, int d)&#123;int ax = x - d, ay = y - d;int bx = x - d, by = y + d;int cx = x + d, cy = y - d;int dx = x + d, dy = y + d;if(isInner(ax, ay) &amp;&amp; isInner(bx, by)&amp;&amp; isInner(cx, cy) &amp;&amp; isInner(dx, dy)) &#123;return c == g[ax][ay] &amp;&amp; g[ax][ay] == g[bx][by]&amp;&amp; g[bx][by] == g[cx][cy] &amp;&amp; g[cx][cy] == g[dx][dy];&#125;return false;&#125;inline int get(int x, int y)&#123;char c = g[x][y];int d = 1;while(check(c, x, y, d)) d ++;return d - 1;&#125;int main()&#123;scanf(&quot;%d%d&quot;, &amp;n, &amp;m);for(int i = 1; i &lt;= n; i ++) scanf(&quot;%s&quot;, g[i] + 1);int res = 0;for(int i = 2; i &lt; n; i ++)for(int j = 2; j &lt; m; j ++)res += get(i, j);printf(&quot;%d\\n&quot;, res);return 0;&#125;\nJ题题面小蓝有一个序列 a[1], a[2], …, a[n]，每次可以交换相邻的两个元素，代价为两个元素中较大的那个。请问，要通过交换将序列变为从小到大递增的序列，总代价最少为多少？\n输入格式输入一行包含一个整数 n ，表示序列长度。第二行包含 n 个整数，表示给定的序列。\n输出格式输出一行包含一个整数，表示最少代价的值。\n数据范围对于 30% 的评测用例，1 &lt;&#x3D; n &lt;&#x3D; 1000, 1 &lt;&#x3D; a[i] &lt;&#x3D; 1000。对于 60% 的评测用例，1 &lt;&#x3D; n &lt;&#x3D; 50000, 1 &lt;&#x3D; a[i] &lt;&#x3D; 50000。对于所有评测用例，1 &lt;&#x3D; n &lt;&#x3D; 1000000, 1 &lt;&#x3D; a[i] &lt;&#x3D; 1000000。\n算法(贪心,逆序对,树状数组)我们考虑每一个后缀中的第一个元素$x$应该被交换几次才应该满足最后的升序排列，情况一：如果后缀已经是升序，那么最小代价为0，不需要进行任何交换，情况二：后缀中小于$x$的所有数都应当于x进行交换，并且最小代价为$cnt(&lt;x) \\times x$，因为我们从后往前枚举完每一个后缀时，它应该变为了升序的序列。\n\n证明：对应着情况一、二，情况一：升序，计算下一个后缀，情况二：我们花费了最小代价将其变为升序。\n\n需要说明的是我们并不用手动的将其变为升序，因为只要不存在逆序对，那么这个序列就一定是升序的，我们会花费代价将有逆序对的后缀变为逆序对数量为0的后缀，即升序。计算逆序对的方式有很多，在本题中最适合使用的是支持单点修改和区间查询的树状数组。注意某点的代价极限为$1e6 \\times 1e6$，会爆$int$，记得开$long\\ long$。\n代码(C++)#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1000010;typedef long long LL;int n;int a[N];int tr[N];int lowbit(int x)&#123;return x &amp; -x;&#125;void add(int x, int v)&#123;for(int i = x; i &lt; N; i += lowbit(i)) tr[i] += v;&#125;int query(int x)&#123;int res = 0;for(int i = x; i; i -= lowbit(i)) res += tr[i];return res;&#125;int main()&#123;scanf(&quot;%d&quot;, &amp;n);for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);LL res = 0;for(int i = n; i &gt;= 1; i --)&#123;int v = a[i];res += query(v - 1) * 1ll * v;add(v, 1);&#125;printf(&quot;%lld\\n&quot;, res);return 0;&#125;\n附录D题输入（30 $\\times$ 60）174094882455171152761423221685761892795431233411387427793198650286024865090061389344606618496378829135984076361542097372601657541200146071777733599818266038012509478351201640618984143988087783837107349651099683484992553337438088068198972282890781586124258626539246182119762952003918195325258677229419698255491250839396799769357665825441616335532825361862146291503649293440596342887581257444442930778730382520372975343211325351222640703400531067500454956482168314849207060705673849265774579830223671554026061117300483012903885770893074783710083450145620356667677191627276513995926532444279237315785832411595106453089134746365281031552217482363035280722591085079053410485925413958279617719034175332412908745680774313630190429314820559328748143552689295945058801322270313370955837837939182801848609300876356583948397645861551964542532682663945625356614462682551015176002433628234343684739800880514363921982340231989891351425389287014819359798014755509282450440511590838726938103384801541373585690893606978941566666714061214952341523168827712604946036245881214982452998386986623826275782780208928205527678781609589000725521486468983551558405472149903035076783644195574734088152324666290493119955560594634905391288186024902215444250421277955403412298227858394469856607272647132163832860126054679347881638761723785858733108109249157334220127702410373959720286708183036202841837581704881367895556630088230650972282944827258473951902831431040790814079538232104075905120989173307660289899942087873076421916033622143260549608274076012938515668898707915863945382394851328164677964192631597026176253407553188801750590935427267220117591817866992665840378311257621611574856498432538327068011953631534031790352912617015229051836886166704989498756486878095690013558017746707412183571476823027885971347137127534455141","categories":["编程"],"tags":["C","编程","C++","蓝桥杯"]},{"title":"OEC/OEC-T实现精确稳定自动挂载硬盘——避免检测不到硬盘无法启动问题","url":"/2025/10/19/OEC-OEC-T%E5%AE%9E%E7%8E%B0%E7%B2%BE%E7%A1%AE%E7%A8%B3%E5%AE%9A%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/","content":"在 Armbian 系统中，挂载硬盘是一个常见操作。但传统的挂载方式（如直接修改 /etc/fstab 文件）存在一定风险：一旦硬盘无法正常挂载，可能导致系统无法启动。本文介绍一种更安全、更稳定的挂载方式：使用 UUID 和 systemd 挂载单元文件。这种方式不仅精确，还能确保在硬盘无法挂载时，系统依然可以正常启动，实现更高的安全性和稳定性。\n\n为什么推荐使用 UUID 挂载？\n精确性：UUID（通用唯一标识符）是硬盘分区的唯一标识，不会因设备名称（如 /dev/sda1）变化而改变。  \n稳定性：传统挂载依赖设备名，可能因启动顺序等因素变动导致挂载失败。UUID 始终唯一，确保稳定挂载。  \n安全性：systemd 挂载单元文件结合 nofail 选项，即使硬盘无法挂载，系统也能正常启动，避免系统崩溃。\n\n\n挂载教程详解以下以挂载 1 块 SATA 为例，演示如何通过 UUID 和 systemd 挂载单元实现自动挂载，USB 外挂硬盘同理。\n1. 查看硬盘信息，获取 UUID\n打开 SSH 终端，查看所有存储设备和分区信息： lsblk\n找到你要挂载的分区（如 /dev/sda1、/dev/sdb1），查询其 UUID 和文件系统类型： sudo blkid /dev/sda1\n 输出示例： /dev/sda1: UUID=&quot;4a98af13f-452e-d447-bdd8-87306eec8437&quot; TYPE=&quot;ext4&quot;\n\n请记下对应的 UUID 和 TYPE，后续会用到。\n\n\n\n\n2. 创建挂载点在 /mnt 目录下为硬盘创建挂载点（如 /mnt/HDD、/mnt/SSD）：\nsudo mkdir -p /mnt/HDD\n\n\n3. 创建 systemd 挂载单元文件用文本编辑器（如 vim、nano、notepad++ 等）新建名为 mnt-HDD.mount 的文件，内容如下：\n[Unit]Description=Mount Disk with UUIDRequires=local-fs.targetAfter=local-fs.target[Mount]What=/dev/disk/by-uuid/4a98af13f-452e-d447-bdd8-87306eec8437Where=/mnt/HDDType=ext4Options=defaults,nofail[Install]WantedBy=multi-user.target\n\n\n\nWhat：这里的 UUID 请替换成你实际查询到的 UUID。\nType：请根据实际分区的文件系统类型填写（如 ext4、ntfs、exfat 等）。\nWhere：对应你的挂载点路径。\n\n\n\n4. 上传文件到系统使用 WinSCP 或其他工具，将刚才编辑好的 mnt-HDD.mount 文件上传到 /etc/systemd/system/ 目录下。\n\n5. 启用并启动挂载单元\n使挂载单元随系统启动自动挂载： sudo systemctl enable mnt-HDD.mount\n立即挂载（无需重启）： sudo systemctl start mnt-HDD.mount\n\n\n6. 验证挂载效果\n查看挂载是否成功： mount | grep /mnt/HDD\n或检查 systemd 单元状态： sudo systemctl status mnt-HDD.mount\n 正常情况下会看到类似输出： /dev/sda1 on /mnt/HDD type ext4 (rw,relatime)\n\n\n7. 重启系统确认重启系统，验证自动挂载是否生效：\nsudo reboot\n\n\n8. 验证自动挂载重启后，再次使用 lsblk 或 mount | grep /mnt/HDD 检查分区是否已自动挂载到 /mnt/HDD。\n\n其他注意事项\nUUID 检查：确保 UUID 填写无误。可随时用 blkid 命令查询。\n文件系统类型：Type=ext4 需与你的分区实际文件系统类型一致。\n挂载选项：Options=defaults,nofail 中的 nofail 表示即使硬盘不存在，系统也不会报错。如果希望硬盘必须存在，可以去掉 nofail。\n多块硬盘：多块硬盘时，分别创建不同的挂载点和对应的 .mount 文件即可。\n\n\n总结通过上述方法，使用 UUID 和 systemd 挂载单元文件，可以让 Armbian（OEC&#x2F;OECT）系统实现精确、稳定且安全的硬盘自动挂载。即使硬盘临时失联，系统也能正常启动，极大提升了系统的健壮性和可维护性。\n","categories":["Linux"],"tags":["Linux","日常"]}]