[{"title":"C语言编程小细节(1)","url":"/2025/10/12/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%BB%86%E8%8A%82%EF%BC%881%EF%BC%89/","content":"C语言中关于”0”的细节‘\\0’ ，‘0’， “0” 之间的区别‘\\0’‘\\0’对应ASCII码是0，字符是（Null），即空字符。判断一个字符串是否结束的标志就是看是否遇到‘\\0’，如果遇到‘\\0’，则表示字符串结束。\n‘0’‘0’是字符常量，对应的ASCII码是48，对应的十六进制数就是0x30，通常我们在编程的时候，用字符转化为数字的时候经常要用到，比如要将‘8’转换为数字8，在语句中这样写：  8+‘0’。这里的8就是数字。\n字符‘0’和数字0的区别：前者是字符常量，后者是整形常量，它们的含义和在计算机中的存储方式截然不同。但是字符常量可以像整数一样在程序中参与相关运算。例如：‘9’-3；\n“0”“0”是字符串常量，字符串常量是由一对双引号括起的字符序列。例如：“CHINA”，“I LOVE YOU”，“123”等都是合法的字符串常量。\n注意：\n1，字符常量由单引号括起来；字符串常量由双引号括起来。\n2：字符常量只能是单个字符；字符串常量则可以含一个或多个字符。\n","categories":["编程"],"tags":["C","编程"]},{"title":"Git命令备忘录","url":"/2025/10/21/Git%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98%E5%BD%95/","content":"Git 是一种分布式版本控制系统。借助此备忘单，您可以快速查阅最常用的 Git 命令。\n🛠️ 配置设置在开始前，先配置您的身份信息。使用 --global 选项表示对您系统上的所有仓库生效。\ngit config --global user.name &quot;您的姓名&quot;git config --global user.email &quot;您的邮箱&quot;git config --global core.editor &quot;code --wait&quot;  # 设置VS Code为默认提交编辑器git config --global alias.st status           # 创建常用命令的别名，例如用 `git st` 代替 `git status`\n\n🚀 入门与基础操作\n\n\n命令\n用途\n\n\n\ngit init\n在当前目录初始化一个新的Git仓库\n\n\ngit clone &lt;仓库地址&gt;\n将远程仓库克隆到本地\n\n\ngit status\n查看工作区和暂存区的文件状态\n\n\ngit add &lt;文件名&gt;\n将特定文件的更改添加到暂存区\n\n\ngit add .\n添加当前目录下所有更改的文件到暂存区\n\n\ngit commit -m &quot;提交信息&quot;\n将暂存区的更改提交到本地仓库\n\n\ngit commit -am &quot;提交信息&quot;\n对已跟踪的文件，一次性完成添加和提交（相当于 git add -u 和 git commit -m 的组合）\n\n\n🌱 分支管理分支是Git的核心，允许您在不影响主线代码的情况下独立工作。\n\n\n\n命令\n用途\n\n\n\ngit branch\n列出所有本地分支\n\n\ngit branch -a\n列出所有本地和远程分支\n\n\ngit branch &lt;分支名&gt;\n创建一个新分支\n\n\ngit checkout &lt;分支名&gt; 或 git switch &lt;分支名&gt;\n切换到指定分支\n\n\ngit checkout -b &lt;新分支名&gt;\n创建并立即切换到新分支\n\n\ngit merge &lt;分支名&gt;\n将指定分支的更改合并到当前分支\n\n\ngit branch -d &lt;分支名&gt;\n删除一个已合并的分支\n\n\ngit branch -D &lt;分支名&gt;\n强制删除一个分支（即使它未被合并）\n\n\ngit branch -m &lt;新分支名&gt;\n重命名当前分支\n\n\n📡 远程协作\n\n\n命令\n用途\n\n\n\ngit remote -v\n查看已关联的远程仓库\n\n\ngit remote add origin &lt;仓库地址&gt;\n添加一个远程仓库并命名为 origin\n\n\ngit push -u origin &lt;分支名&gt;\n将本地分支推送到远程仓库，并建立追踪关系（首次推送后可使用 git push）\n\n\ngit fetch\n从远程仓库下载最新数据，但不会自动合并到工作区\n\n\ngit pull\n从远程仓库拉取更新并合并到当前分支（相当于 git fetch + git merge）\n\n\ngit push origin --delete &lt;远程分支名&gt;\n删除远程仓库的指定分支\n\n\n⏪ 撤销与回退当需要修正错误时，这些命令非常重要。\n\n\n\n命令\n用途\n\n\n\ngit commit --amend\n修改最近一次提交。可以修改提交信息，或者将暂存区的新更改加入上次提交。\n\n\ngit reset --soft HEAD~1\n撤销上次提交，但保留更改内容在暂存区。\n\n\ngit reset --mixed HEAD~1\n撤销上次提交，并取消暂存更改（默认选项）。\n\n\ngit reset --hard HEAD~1\n谨慎使用。撤销上次提交，并丢弃所有工作区的更改。\n\n\ngit checkout -- &lt;文件名&gt;\n撤销对某个文件在工作区的修改（还原到最近一次提交的状态）。\n\n\ngit revert &lt;某次提交的哈希值&gt;\n创建一个新的提交来撤销指定提交的更改，这是一种安全且不重写历史的撤销方式，特别适合用于已推送的提交。\n\n\n💾 临时保存更改（储藏）当您需要临时切换分支但又不想提交未完成的工作时，储藏功能非常有用。\ngit stash                    # 将当前工作区和暂存区的更改临时储藏起来git stash list              # 列出所有的储藏栈git stash pop               # 应用最近一次储藏的更改，并将其从储藏栈中删除git stash apply             # 应用最近一次储藏的更改，但不从储藏栈中删除git stash drop              # 删除最近一次储藏的更改\n\n🔍 查看与比较\n\n\n命令\n用途\n\n\n\ngit log --oneline\n以简洁的单行格式查看提交历史。\n\n\ngit log --graph\n以图形化方式查看分支合并历史。\n\n\ngit diff\n查看工作区与暂存区之间的差异。\n\n\ngit diff --staged\n查看暂存区与上一次提交之间的差异。\n\n\ngit show &lt;提交哈希值&gt;\n显示某次提交的具体修改内容。\n\n\n","categories":["Git"],"tags":["日常","Git"]},{"title":"HTTP状态码速查","url":"/2025/10/21/HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E9%80%9F%E6%9F%A5/","content":"\n  \n    \n      文档说明\n\n    \n    \n      HTTP 状态码是服务器在响应客户端请求时返回的三位数字代码，用于表示请求的处理状态。它们分为五类，首位数字定义了响应的类别。\n\n    \n  \n\n\n1xx - 信息性响应表示请求已被接收，需要继续处理。\n\n100 Continue: 等待客户端发送请求的正文部分。\n101 Switching Protocols: 服务器已同意切换协议。\n102 Processing: 服务器正在处理请求，但尚未有可用的响应（用于 WebDAV）。\n103 Early Hints: 服务器在最终的 HTTP 消息之前返回一些响应头。\n\n2xx - 成功表示请求已成功被服务器接收、理解并接受。\n\n200 OK: 标准成功响应，表示请求已成功处理。\n201 Created: 请求已成功，并因此创建了一个新的资源。\n202 Accepted: 服务器已接受请求进行处理，但处理尚未完成。\n203 Non-Authoritative Information: 请求成功，但返回的实体头部的元信息并非来自原始服务器，而可能来自本地或第三方副本。\n204 No Content: 服务器成功处理了请求，但不会返回任何内容主体。\n205 Reset Content: 服务器提示发送此请求的客户端应重置当前文档视图。\n206 Partial Content: 由于客户端发送了范围请求头，服务器只返回了部分资源。\n207 Multi-Status: 后续的消息体是一个XML消息，可能包含多个独立的响应代码（用于 WebDAV）。\n208 Already Reported: DAV 绑定的成员已在先前部分的多状态响应中被枚举（用于 WebDAV）。\n226 IM Used: 服务器已经完成了对资源的请求，响应是操作结果的表示。\n\n3xx - 重定向表示需要客户端采取进一步的操作才能完成请求，通常需要重定向到另一个URL。\n\n300 Multiple Choices: 表示客户端请求的资源有多个选择，每个选择都有自己的特定地址。\n301 Moved Permanently: 请求的资源已被永久移动到新的 URI，今后应使用新的 URI。\n302 Found: 请求的资源临时移动到另一个 URI 上，客户端应继续使用原始 URI。\n303 See Other: 对当前请求的响应可以在另一个 URI 上找到，客户端应该使用 GET 方法获取资源。\n304 Not Modified: 所请求的资源自上次请求后未被修改，客户端可以使用缓存的版本。\n305 Use Proxy: 请求的资源必须通过代理访问，代理的位置在 Location 头部中给出。\n306 Switch Proxy: 已不再使用，最初表示“后续请求应使用指定的代理”。\n307 Temporary Redirect: 请求的资源临时位于另一个 URI，请求应使用原请求方法重复发往该 URI。\n308 Permanent Redirect: 请求的资源已永久移动到另一个 URI，当前以及所有未来的请求都应使用新的 URI。\n\n4xx - 客户端错误表示客户端的请求有错误，服务器无法处理。\n\n400 Bad Request: 由于存在语法错误、参数不正确等明显的客户端错误，服务器无法或不会处理该请求。\n401 Unauthorized: 请求需要用户认证或认证失败。\n402 Payment Required: 为将来使用而保留，最初意图是可能用于数字现金或小额支付系统。\n403 Forbidden: 请求有效，但服务器拒绝执行。用户可能没有访问该资源所需的权限。\n404 Not Found: 服务器找不到请求的资源。\n405 Method Not Allowed: 请求中使用的 HTTP 方法不被目标资源支持。\n406 Not Acceptable: 服务器无法根据客户端请求头中的条件（如 Accept 头）生成相应的内容。\n407 Proxy Authentication Required: 客户端必须首先通过代理服务器的身份验证。\n408 Request Timeout: 服务器在等待客户端发送请求时超时。\n409 Conflict: 请求无法处理，因为与请求的当前状态存在冲突（例如编辑冲突）。\n410 Gone: 请求的资源已永久删除且不可恢复。\n411 Length Required: 服务器拒绝处理没有包含 Content-Length 头部的请求。\n412 Precondition Failed: 服务器不满足请求者在请求中设置的某个前提条件。\n413 Payload Too Large: 请求的实体数据过大，服务器无法或不愿意处理。\n414 URI Too Long: 请求的 URI 过长，服务器无法处理。\n415 Unsupported Media Type: 请求的媒体格式不被服务器或资源支持。\n416 Range Not Satisfiable: 客户端请求了资源的某个部分，但服务器无法提供该部分。\n417 Expectation Failed: 服务器无法满足 Expect 请求头字段的期望值。\n418 I’m a teapot: 服务器拒绝尝试用茶壶煮咖啡（来自愚人节笑话RFC）。\n421 Misdirected Request: 请求被发送到一个无法产生响应的服务器。\n422 Unprocessable Entity: 请求格式正确，但由于存在语义错误无法被处理。\n423 Locked: 所要访问的资源当前已被锁定。\n424 Failed Dependency: 由于之前的某个请求失败，导致当前请求失败。\n425 Too Early: 服务器不愿意冒险处理一个可能被重放的请求。\n426 Upgrade Required: 客户端应升级到其他协议，例如 TLS&#x2F;1.0。\n428 Precondition Required: 原始服务器要求请求是有条件的。\n429 Too Many Requests: 客户端在给定的时间内发送了过多的请求。\n431 Request Header Fields Too Large: 由于单个头字段或所有头字段集体过大，服务器拒绝处理请求。\n451 Unavailable For Legal Reasons: 由于法律原因，服务器运营商拒绝访问某个资源或一组资源。\n\n5xx - 服务器错误表示服务器在处理请求的过程中发生了错误。\n\n500 Internal Server Error: 服务器遇到了一个未曾预料的情况，导致它无法完成请求处理。\n501 Not Implemented: 服务器不支持实现请求所需的功能。\n502 Bad Gateway: 服务器作为网关或代理时，从上游服务器收到了一个无效的响应。\n503 Service Unavailable: 服务器由于超载或系统维护，当前无法处理请求（通常是临时状态）。\n504 Gateway Timeout: 服务器作为网关或代理时，未能及时从上游服务器收到响应。\n505 HTTP Version Not Supported: 服务器不支持请求中所用的 HTTP 协议版本。\n506 Variant Also Negotiates: 服务器存在内部配置错误，透明内容协商导致循环引用。\n507 Insufficient Storage: 服务器无法存储完成请求所需的表示（用于 WebDAV）。\n508 Loop Detected: 服务器在处理请求时检测到无限循环（用于 WebDAV）。\n510 Not Extended: 需要对请求进行进一步扩展，服务器才能完成处理。\n511 Network Authentication Required: 客户端需要进行网络认证才能获得网络访问权限（常见于需认证门户）。\n\n\n","categories":["日常"],"tags":["日常","网络"]},{"title":"HTTP状态码详解","url":"/2025/10/21/HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E8%AF%A6%E8%A7%A3/","content":"概述HTTP 状态码是服务器在响应客户端请求时返回的三位数字代码，用于快速传达请求的处理结果。它们遵循 RFC 规范，是 Web 通信和 API 交互的基石。状态码的首位数字定义了响应的类别，后两位表示具体状态。合理使用状态码有助于快速定位问题、优化用户体验并构建健壮的 Web 服务。\n状态码分类HTTP 状态码根据首位数字分为五类：\n\n\n\n分类\n范围\n含义\n说明\n\n\n\n1xx\n100-199\n信息响应\n请求已接收，需要继续处理。\n\n\n2xx\n200-299\n成功响应\n请求已被服务器成功接收、理解并处理。\n\n\n3xx\n300-399\n重定向\n需要客户端进一步操作才能完成请求。\n\n\n4xx\n400-499\n客户端错误\n请求包含语法错误或无法完成，问题出在客户端。\n\n\n5xx\n500-599\n服务器错误\n服务器在处理请求时发生内部错误，问题出在服务器端。\n\n\n常见状态码详解1xx - 信息响应这类状态码表示临时响应，通常用于握手或协议升级，在日常开发中较少直接处理。\n\n100 Continue\n\n含义：客户端发送 Expect: 100-continue 请求头后，服务器若同意处理，则返回此状态码。客户端随后可发送完整的请求体。\n适用场景：常用于大文件上传前验证权限，避免传输无谓的数据。\n\n\n101 Switching Protocols\n\n含义：服务器同意客户端要求切换协议的请求（如从 HTTP 升级到 WebSocket）。\n适用场景：协议升级，例如建立 WebSocket 连接。\n\n\n\n2xx - 成功表示请求已成功被服务器接收、理解并处理。\n\n200 OK\n\n含义：最通用的成功状态码，表示请求已成功完成。\n适用场景：\nGET 请求成功获取资源。\nPUT 或 PATCH 请求成功更新资源。\n\n\n扩展解释：即使业务数据为空（如查询结果为空列表），只要请求本身处理成功，仍应返回 200。\n\n\n201 Created\n\n含义：请求已成功，并导致创建了一个新资源。\n适用场景：通常用于 POST 请求创建新资源（如用户注册、新建订单）。\n最佳实践：响应应包含新资源的 URI（通过 Location 头字段）。\n\n\n204 No Content\n\n含义：服务器成功处理了请求，但不需要返回任何实体内容。\n适用场景：\nDELETE 请求成功删除资源。\nPUT&#x2F;PATCH 更新成功但无需返回数据。\n\n\n前端与后端：前端收到 204 后，应知悉操作成功，但界面可能无需更新。\n\n\n206 Partial Content\n\n含义：服务器成功处理了部分 GET 请求。\n适用场景：用于支持断点续传或分片下载大文件（如视频、大型文档）。客户端通过 Range 头指定请求范围。\n\n\n\n3xx - 重定向表示需要客户端执行额外的操作（通常是重定向）才能完成请求。\n\n301 Moved Permanently\n\n含义：永久重定向。请求的资源已被永久分配新的 URI，将来任何对此资源的引用都应使用本次返回的 URI。\nSEO 影响：搜索引擎会更新其索引，将权重转移到新 URL。\n最佳实践：适用于网站域名变更、目录结构永久调整。\n\n\n302 Found\n\n含义：临时重定向。请求的资源临时位于不同的 URI。\n注意：由于历史原因，许多客户端在重定向时会将 POST 请求改为 GET 请求。若需保持方法不变，应使用 307 Temporary Redirect。\n适用场景：短链接跳转、用户登录后临时重定向到首页。\n\n\n304 Not Modified\n\n含义：所请求的资源在客户端缓存后自上次请求以来未被修改，服务器不会返回资源内容，客户端可直接使用缓存副本。\n触发条件：客户端发送带条件请求头（如 If-Modified-Since 或 If-None-Match）的请求。\n优化作用：可显著减少网络传输，提升性能。\n\n\n308 Permanent Redirect\n\n含义：与 301 类似，表示永久重定向。关键区别在于 308 会强制客户端在重定向时保持原有的请求方法和实体体。\n适用场景：确保像 POST 请求这样的非幂等操作在永久重定向时不会意外变为 GET 请求，更安全。\n\n\n\n4xx - 客户端错误表示客户端似乎发生了错误，妨碍了服务器的处理。\n\n400 Bad Request\n\n含义：通用客户端错误，服务器因某些原因（通常是语法错误）无法或不会处理该请求。\n常见原因：请求参数格式错误（如无效的 JSON）、缺少必需参数、参数验证失败。\n排查方向：检查请求体、查询参数、请求头格式是否符合 API 要求。\n\n\n401 Unauthorized\n\n含义：未认证。请求需要用户认证，但认证失败或未提供。\n与 403 的区别：401 是“未证明身份”，403 是“已证明身份但权限不足”。\n最佳实践：响应通常应包含 WWW-Authenticate 头，指示认证方式。\n\n\n403 Forbidden\n\n含义：服务器理解请求，但拒绝执行。身份验证成功并不足以授权访问。\n常见原因：\n用户权限不足（如普通用户尝试访问管理员接口）。\nIP 地址被禁止访问。\n访问权限设置问题。\n\n\n\n\n404 Not Found\n\n含义：服务器找不到请求的资源。\n常见原因：\n请求的 URL 路径错误或资源已被删除。\n后端路由配置错误或 API 路径不存在。\n\n\n用户体验：应提供友好的 404 错误页面，引导用户。\n\n\n429 Too Many Requests\n\n含义：客户端在给定的时间内发送了过多请求，触发了服务器的速率限制（Rate Limiting）。\n解决方案：客户端应等待一段时间再重试，通常响应头会包含 Retry-After 指示重试时间。\n\n\n\n5xx - 服务器错误表示服务器在处理请求的过程中发生了错误。\n\n500 Internal Server Error\n\n含义：通用服务器错误消息，表示服务器遇到了一个未曾预料的状况，导致它无法完成对请求的处理。\n常见原因：服务器端代码存在未处理的异常（如空指针）、数据库连接失败、配置文件错误等。\n排查方向：查看服务器错误日志是定位 500 错误最直接有效的方法。\n\n\n502 Bad Gateway\n\n含义：服务器作为网关或代理时，从上游服务器收到了无效的响应。\n常见场景：Nginx 等反向代理后面的应用服务器（如 Tomcat, Node.js 应用）崩溃、无响应或网络不通。\n排查方向：检查上游服务器进程状态、网络连通性以及上游服务器本身的健康度。\n\n\n503 Service Unavailable\n\n含义：服务器当前无法处理请求（由于暂时的过载或维护）。\n与 500 的区别：503 通常表示服务是暂时不可用，稍后可能恢复。服务器可能通过 Retry-After 头告知客户端预计的恢复时间。\n常见场景：服务器进行维护、重启或因高并发导致系统资源耗尽。\n\n\n504 Gateway Timeout\n\n含义：服务器作为网关或代理，未能及时从上游服务器收到响应。\n与 502 的区别：502 是收到了“无效响应”，504 是“没有在规定时间内收到任何响应”，即超时。\n排查方向：检查上游服务器处理是否缓慢，或适当调整网关的超时设置。\n\n\n\n总结与最佳实践\n精准使用：在 API 设计中，应选择最符合语义的状态码。例如，创建资源成功用 201，删除成功且无内容返回用 204。\n避免混用：不应在业务逻辑错误时全部返回 200，然后在响应体中用自定义代码表示错误。这会破坏 HTTP 语义，应直接使用 4xx 或 5xx 状态码。\n明确职责：遇到 4xx 错误，排查重点在客户端（检查 URL、参数、权限）；遇到 5xx 错误，排查重点在服务器端（查看日志、检查依赖服务）。\n工具辅助：利用浏览器开发者工具的 Network 面板或 Postman 等工具，可以直观地查看和分析请求返回的状态码。\n\n理解并正确应用 HTTP 状态码，是每一位 Web 开发者、运维人员的基本功，它能帮助您快速定位问题，优化系统交互逻辑，从而构建更健壮、更易维护的网络应用。\n","categories":["日常"],"tags":["日常","网络"]},{"title":"JavaScript 正则表达式速查表","url":"/2025/10/21/JavaScript-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%80%9F%E6%9F%A5%E8%A1%A8/","content":"正则表达式速查表JavaScript 正则表达式速查表\n普通字符\n\n\n表达式\n说明\n\n\n\n. 或 [^\\n\\r]\n任意字符，不包括换行符或回车符\n\n\n[A-Za-z]\n字母\n\n\n[a-z]\n小写字母\n\n\n[A-Z]\n大写字母\n\n\n\\d 或 [0-9]\n数字\n\n\n\\D 或 [^0-9]\n非数字\n\n\n_\n下划线\n\n\n\\w 或 [A-Za-z0-9_]\n字母、数字或下划线\n\n\n\\W 或 [^A-Za-z0-9_]\n\\w 的反义，即非字母、数字或下划线\n\n\n\\S\n\\s 的反义，即非空白字符\n\n\n空白字符\n\n\n表达式\n说明\n\n\n\n（空格）\n空格\n\n\n\\t\n制表符（Tab）\n\n\n\\n\n换行符\n\n\n\\r\n回车符\n\n\n\\s\n空格、制表符、换行符或回车符\n\n\n字符集\n\n\n表达式\n说明\n\n\n\n[xyz]\n匹配 x、y 或 z 中的任意一个\n\n\n[^xyz]\n匹配除 x、y、z 之外的任意字符\n\n\n[1-3]\n匹配 1、2 或 3 中的任意一个\n\n\n[^1-3]\n匹配除 1、2、3 之外的任意字符\n\n\n\n字符集可视为方括号内单个字符的“或”操作。\n在开头的 [ 后使用 ^ 表示取反，即匹配不在字符集内的字符。\n字符集中，. 表示字面上的句点字符。\n\n需要转义的字符字符集外\n\n\n表达式\n说明\n\n\n\n\\.\n句点\n\n\n\\^\n脱字符（插入符号）\n\n\n\\$\n美元符号\n\n\n&#96;\n&#96;\n\n\n\\\\\n反斜杠\n\n\n\\/\n斜杠\n\n\n\\(\n左圆括号\n\n\n\\)\n右圆括号\n\n\n\\[\n左方括号\n\n\n\\]\n右方括号\n\n\n\\{\n左花括号\n\n\n\\}\n右花括号\n\n\n字符集内\n\n\n表达式\n说明\n\n\n\n\\\\\n反斜杠\n\n\n\\]\n右方括号\n\n\n\n^ 仅在紧跟 [ 后时需要转义。\n- 仅在位于两个字母或两个数字之间时需要转义。\n\n量词\n\n\n表达式\n说明\n\n\n\n{2}\n恰好出现 2 次\n\n\n{2,}\n至少出现 2 次\n\n\n{2,7}\n出现 2 到 7 次（含 2 和 7）\n\n\n*\n出现 0 次或多次\n\n\n+\n出现 1 次或多次\n\n\n?\n出现 0 次或 1 次\n\n\n\n量词位于被量化表达式的后面。\n\n边界\n\n\n表达式\n说明\n\n\n\n^\n字符串开头\n\n\n$\n字符串结尾\n\n\n\\b\n单词边界\n\n\n\n单词边界匹配规则：\n字符串开头且第一个字符为 \\w。\n字符串中相邻字符间，前一个为 \\w，后一个为 \\W。\n字符串结尾且最后一个字符为 \\w。\n\n\n\n匹配\n\n\n表达式\n说明\n\n\n\n&#96;foo\nbar&#96;\n\n\nfoo(?=bar)\n匹配紧跟 bar 之前的 foo\n\n\nfoo(?!bar)\n匹配不紧跟 bar 之前的 foo\n\n\n(?&lt;=bar)foo\n匹配紧跟在 bar 之后的 foo\n\n\n(?&lt;!bar)foo\n匹配不紧跟在 bar 之后的 foo\n\n\n分组与捕获\n\n\n表达式\n说明\n\n\n\n(foo)\n捕获组；匹配并捕获 foo\n\n\n(?:foo)\n非捕获组；匹配 foo，但不捕获\n\n\n(foo)bar\\1\n\\1 是对第 1 个捕获组的反向引用；匹配 foobarfoo\n\n\n\n捕获组仅在以下方法中有意义：\nstring.match(regexp)\nstring.matchAll(regexp)\nstring.replace(regexp, callback)\n\n\n\\N 表示对第 N 个捕获组的反向引用，捕获组编号从 1 开始。\n\n参考资料与工具\nMDN 正则表达式指南\nRegExplained\n\n","categories":["日常"],"tags":["编程","日常"]},{"title":"Java编程初学记录","url":"/2025/10/12/Java%E7%BC%96%E7%A8%8B%E5%88%9D%E5%AD%A6%E8%AE%B0%E5%BD%95/","content":"记录初学Java时练习过的题目~1、1!+2!+…+10!的值//1.编写一个Java程序，求1!+2!+…+10!的值，程序文件命名为“FactoriesSum.java”。public class FactoriesSum &#123;    public static void main(String[] args) &#123;        int sum=0;        for(int i=1,a=1;i&lt;=10;i++,a=1)&#123;            for(int j=1;j&lt;=i;j++)&#123;                a*=j;            &#125;            sum+=a;        &#125;        System.out.println(&quot;1!+2!+…+10!=&quot;+sum);    &#125;&#125;\n\n\n\n2、 输出从100-200 之间（包括100和200）的所有质数//2.编写一个Java程序，输出从100-200 之间（包括100和200）的所有质数，以空格分隔方式输出这些数字，程序文件命名为“PrimeNumer.java”。//提示：质数为大于1的自然数中，除了1和它本身以外不能被其他数整除的自然数。例如2,3,5,7……public class PrimeNumer &#123;    public static void main(String[] args) &#123;        for(int i =100,t=0;i&lt;=200;i++,t=0)&#123;            int j;            for(j=2;j&lt;(int)(i/2);j++)&#123;                if(i%j!=0)                    t++;                else                    break;            &#125;            if(j==(int)(i/2))                System.out.printf(&quot;%d &quot;,i);        &#125;    &#125;&#125;\n\n\n\n3 求100-999之间的水仙花数//3.编写一个Java程序，求100-999之间的水仙花数，程序文件命名为“Narcissus.java”。// 提示：水仙花数为一个数的每一位数字的立方之和等于这个数，如数字153，1^3+5^3+3^3=153，以空格分隔输出这些数字。public class Narcissus &#123;    public static void main(String[] args) &#123;        for(int i=100;i&lt;=999;i++)&#123;            int a=i%10;            int b=i/10%10;            int c=i/100;            if(Math.pow(a,3)+Math.pow(b,3)+Math.pow(c,3)==i)                System.out.printf(&quot;%d &quot;,i);        &#125;    &#125;&#125;\n\n\n\n4 、输出1949年-2023年内的闰年//4.编写一个Java程序，输出1949年-2023年内的闰年，要求按行输出，一行5个年份，用空格分隔，程序文件命名为“LeapYear.java”。public class LeapYear &#123;    public static void main(String[] args) &#123;        for (int i = 1949,a=0; i &lt;= 2023; i++) &#123;            if ((i % 4 == 0 &amp;&amp; i % 100 != 0) || i % 400 == 0) &#123;                System.out.printf(&quot;%d\\t&quot;, i);                a++;                if(a%5==0)&#123;                    System.out.print(&quot;\\n&quot;);                &#125;            &#125;        &#125;    &#125;&#125;\n\n5、“动物”类//1.编写Java程序实现如下功能//（1）设计一个“动物”类：Animal，包括：//①两个公有属性：name（字符串类型）和age（整形）；//②两个公有方法：eat（void类型，方法参数为：一个字符串类型）和move（void类型，方法参数为空），方法内部各自打印一行语句。//（2）接下来设计“猫”类：Cat，继承“Animal”类，新增一个公有属性：color（字符串类型）。//在“猫”类请实现以下方法：//①构造方法：参数列表为：name、age、color，通过构造方法可以设置猫的这三个属性。//②公有方法catchAnimal (void类型，方法参数为：一个Animal类型)，方法内部打印：[猫的名字]捉住了[动物的名字]。例如：小花猫捉住了老鼠。public class demo &#123;    public static void main(String[] args) &#123;        Animal mouse=new Animal(&quot;老鼠&quot;,999);        Cat cat =new Cat(&quot;汤姆猫&quot;,3,&quot;蓝色&quot;);        cat.catchAnimal(mouse);    &#125;&#125;  class Animal&#123;    public String name;    public int age;    public Animal(String name1, int age1) &#123;        this.name = name1;        this.age = age1;    &#125;    void eat(String s)&#123;        System.out.println(s);    &#125;    void move()&#123;        System.out.println(&quot;呼..呼..&quot;);    &#125;&#125;class Cat extends Animal&#123;    public String color;    public Cat(String name, int age,String color) &#123;        super(name, age);        this.color=color;    &#125;    public void catchAnimal(Animal A)&#123;        System.out.println(this.name+&quot;捉住了&quot;+A.name);    &#125;&#125;\n\n\n\n6、形状的抽象类//2.编写程序，实现以下功能：//（1）定义一个形状的抽象类：Shape，包含两个抽象方法：//①getArea：获取形状的面积；//② getPerimeter：获取形状的周长；//（2）再定义两个子类-圆形类和矩形类：Circle和Rectangle，分别继承自Shape类。//① Circle类中需要包含一个私有变量-半径radius和一个构造方法，// 构造方法带有一个参数radius，通过构造方法可以设置矩形的半径；并且需要实现getArea和getPerimeter方法分别获取圆形的面积和周长。//② Rectangle类中需要包含两个私有变量-长度length和宽度width；// 以及构造方法，构造方法带有两个参数length和width，通过构造方法可以设置矩形的长和宽；并且需要实现getArea和getPerimeter方法分别获取矩形的面积和周长。//3.最后，编写一个测试类Test，在main方法中创建一个Circle和一个Rectangle对象，并分别调用它们的getArea和getPerimeter方法，打印它们的面积和周长。public class Test &#123;    public static void main(String[] args) &#123;    Circle Y=new Circle(5);        System.out.println(&quot;圆的面积为&quot;+Y.getArea()+&quot;,周长为&quot;+Y.getPerimeter());    Rectangle J=new Rectangle(4,3);        System.out.println(&quot;矩形的面积为:&quot;+J.getArea()+&quot;,周长为:&quot;+J.getPerimeter());    &#125;&#125;abstract class Shape&#123;    public abstract double getArea();    public abstract double getPerimeter();&#125;class Circle extends Shape&#123;    private double radius;    final public  double PI=3.1415926;    Circle(double radius)&#123;        this.radius=radius;    &#125;    public double getArea() &#123;        return Math.pow(this.radius,2)*PI;    &#125;    public double getPerimeter() &#123;        return 2*radius*PI;    &#125;&#125;class Rectangle extends Shape&#123;    private double length,width;    Rectangle(double length,double width)&#123;        this.length=length;        this.width=width;    &#125;    public double getArea() &#123;        return this.length*this.width;    &#125;    public double getPerimeter() &#123;        return (this.length+this.width)*2;    &#125;&#125;\n\n\n\n7 、声音模拟器import java.lang.*;//3.编写Java程序，完成如下功能：//设计一个声音模拟器，希望模拟器可以模拟出喜多动物的叫声，要求如下：//编写接口Animal。Animal接口有两个抽象方法cry()和getAnimalName()，即要求，实现该接口的各种具体动物类给出自己的叫声和种类名称。//设计一个动物声音模拟器,希望模拟器可以模拟许多动物的叫声,要求如下://(1)编写接口Animal。Animal接口有两个抽象方法cry()和 getAnimalName(),即要求实现该接口的各种具体动物类给出自己的叫声和种类名称。//(2)编写模拟器类Simulator。该类有一个 playSound(Animal animal)方法,该方法的参数是 Animal类型,// 即参数animal可以调用实现Animal接口类重写的cry()方法播放具体动物的声音,调用重写的getAnimalName()方法显示动物种类的名称。//(3)编写实现Animal接口的 Dog类和Cat类。public class demo &#123;    public static void main(String[] args) &#123;        Cat mao=new Cat();        Dog dog=new Dog();        Simulator s=new Simulator();        s.playSound(mao);        s.playSound(dog);    &#125;&#125;interface Animal&#123;    public abstract void cry();    public abstract String getAnimalName();&#125;class Simulator&#123;    void playSound(Animal animal)&#123;        System.out.printf(animal.getAnimalName()+&quot;的叫声是&quot;);        animal.cry();    &#125;&#125;class Dog implements Animal&#123;    public void cry() &#123;        System.out.println(&quot;汪汪！&quot;);    &#125;    public String getAnimalName() &#123;        return (String)&quot;狗&quot;;    &#125;&#125;class Cat implements Animal&#123;    public void cry() &#123;        System.out.println(&quot;喵呜~&quot;);    &#125;    public String getAnimalName() &#123;        return (String)&quot;猫&quot;;    &#125;&#125;\n\n\n\n8、银行Bank//4.假设银行Bank已有了按整年计算利息的一般方法，其中year只能取整数，利率计算规则为：存款数*年数*利率。//建设银行（ConstructionBank）和中国银行（ChinaBank）都是银行的子类，准备隐藏继承的成员变量year// 并重写计算利息的方法，即自己声明一个double类型的year变量，比如当year取值为5.216时，表示要计算5年零216天的利息// 但希望首先按照银行Bank的方法computerInterest()计算出5整年的利息，然后再自己计算216天的利息，// 那么，建设银行就必须把5.216的整数部分赋给隐藏的year，并让super调用隐藏的，按整年计算利息的方法。//分别创建ConstructionBank类和ChinaBank类继承Bank类，子类重写父类的computerInterest()方法，// 创建主类SaveMoney，在主类中创建ConstructionBank和ChinaBa=nk对象，初始化存款数为10000// 存款时间为3.216年（3年零216天）、建设银行年利率为2.8%，日利率为0.002%，// 中国银行年利率为2.9%，日利率为0.0015%，输出两家银行的利息，输出格式为：//%d元存在建设银行%d年零%d天的利息为%f元\\n//%d元存在中国银行%d年零%d天的利息为%f元\\n//如：//10000元存在建设银行3年零216天的利息为883.2元//10000元存在中国银行3年零216天的利息为902.4元public class SaveMoney &#123;    public static void main(String[] args) &#123;        ConstructionBank JS = new ConstructionBank(10000,3.216,0.028,0.00002);        ChinaBank ZH = new ChinaBank(10000,3.216,0.029,0.000015);        System.out.printf(&quot;%d元存在建设银行%d年零%d天的利息为%f元\\n&quot;,JS.saveMoney,(int)Math.floor(JS.year),(int)(1000*(JS.year-Math.floor(JS.year))),JS.computerInterest());        System.out.printf(&quot;%d元存在中国银行%d年零%d天的利息为%f元\\n&quot;,ZH.saveMoney,(int)Math.floor(ZH.year),(int)(1000*(ZH.year-Math.floor(ZH.year))),ZH.computerInterest());    &#125;&#125;class Bank&#123;    int saveMoney;    int year;    double Interest;    double InterestRate;    double ComputerInterest()&#123;        return saveMoney*year*Interest;    &#125;    void SetInterestRate(double interest) &#123;        this.Interest=interest;    &#125;&#125;class ConstructionBank extends Bank&#123;    double year;    public ConstructionBank(int saveMoney,double year,double interest, double interestRate) &#123;        this.saveMoney=saveMoney;        this.Interest=interest;        this.InterestRate=interestRate;        this.year = year;    &#125;    double computerInterest()&#123;        super.year=(int)Math.floor(year);        return super.ComputerInterest()+saveMoney*1000*(year-Math.floor(year))*InterestRate;    &#125;&#125;class ChinaBank extends Bank&#123;    double year;    public ChinaBank(int saveMoney, double year, double interest, double interestRate) &#123;        this.saveMoney=saveMoney;        this.Interest=interest;        this.InterestRate=interestRate;        this.year = year;    &#125;    double computerInterest()&#123;        super.year=(int)Math.floor(year);        return super.ComputerInterest()+saveMoney*1000*(year-Math.floor(year))*InterestRate;    &#125;&#125;\n\n9、公司的雇员//1. 某公司的雇员分为以下若干类：//(1) Employee：这是所有员工总的父类。//① 属性：员工的姓名,员工的生日月份//② 方法：getSalary(int month) 根据参数月份来确定工资，如果该月员工过生日，则公司会额外奖励100 元。//(2) SalariedEmployee：Employee 的子类，拿固定工资的员工。//① 属性：月薪。//(3)HourlyEmployee：Employee 的子类，按小时拿工资的员工，每月工作超出160小时的部分按照1.5 倍工资发放。//① 属性：每小时的工资、每月工作的小时数。//(4) SalesEmployee：Employee 的子类，销售，工资由月销售额和提成率决定。//① 属性：月销售额、提成率。//(5) BasePlusSalesEmployee：SalesEmployee 的子类，有固定底薪的销售人员，工资由底薪加上销售提成部分。//① 属性：底薪、提成。//要求：//创建一个Employee 数组，分别创建若干不同的Employee对象放入Employee 数组中，初始化// 张三为SalariedEmployee类型员工月薪为4000元，生日为5月份；// 李四为HourlyEmployee类型员工，生日为6月份，每小时工资25元，当月工作了200小时；// 王五为SalesEmployee类型员工，生日为7月份，底薪为2500，提成为3000，当前要发的是6月份工资，要求打印结果为：//张三6月份的工资为4000元//李四6月份的工资为5600元//王五6月份的工资为5500元。public class demo &#123;    public static void main(String[] args) &#123;        Employee[] employees=new Employee[3];        employees[0]=new SalariedEmployee(&quot;张三&quot;,5,4000);        employees[1]=new HourlyEmployee(&quot;李四&quot;,6,25,200);        employees[2]=new BasePlusSalesEmployee(&quot;王五&quot;,7,2500,3000);        for(int i=0;i&lt;3;i++)&#123;            System.out.printf(&quot;%s6月份的工资为%.0f元\\n&quot;,employees[i].name,employees[i].getSalary(6));        &#125;    &#125;&#125;abstract class Employee&#123;    String name;    int birth;    public abstract double getSalary(int month);&#125;class SalariedEmployee extends Employee&#123;    double Monthly;    public SalariedEmployee(String name,int birth,double monthly) &#123;        this.name=name;        this.birth=birth;        Monthly = monthly;    &#125;    public double getSalary(int month) &#123;        if (month==birth)            return Monthly+100;        else            return Monthly;    &#125;&#125;class HourlyEmployee extends Employee &#123;    double Hourly,hour;    public HourlyEmployee(String name,int birth,double hourly, double hour) &#123;        this.name=name;        this.birth=birth;        Hourly = hourly;        this.hour = hour;    &#125;    public double getSalary(int month) &#123;        if(hour&lt;=160)&#123;            if(month==birth)                return hour*Hourly+100;            else return hour*Hourly;        &#125;        else&#123;            if(month==birth)                return (hour-160)*1.5*Hourly+160*Hourly+100;            else                return (hour-160)*1.5*Hourly+160*Hourly;        &#125;    &#125;&#125;class SalesEmployee extends Employee&#123;    double MonthlySales,RoyaltyRate;    public double getSalary(int month) &#123;        return MonthlySales*RoyaltyRate;    &#125;&#125;class BasePlusSalesEmployee extends SalesEmployee&#123;    double Monthly,Commission;    public BasePlusSalesEmployee(String name,int birth,double monthly,double commission) &#123;        this.name=name;        this.birth=birth;        Monthly=monthly;        Commission=commission;    &#125;    public double getSalary(int month) &#123;        if (month==birth)            return Monthly+Commission+100;        else            return Monthly+Commission;    &#125;&#125;\n\n\n\n10、控制台输入一个字符串s，请你反转字符串中单词的顺序import java.util.Scanner;public class  ReverseStr &#123;    public static void main(String[] args) &#123;        String s;        String regex = &quot;\\s+&quot;;        String[] a;        Scanner read=new Scanner(System.in);        s=read.nextLine();        a=s.split(regex);        for(int i=a.length-1;i&gt;=0;i--)&#123;            System.out.printf(&quot;%s &quot;,a[i]);        &#125;    &#125;&#125;\n\n\n\n11、产生10个1-100之间的随机整数输出import java.util.*;//1. 产生10个1-100之间的随机整数输出，// 并把这10个数按从小到大的顺序输出，程序文件命名为“RandomSort.java”。public class RandomSort &#123;    public static void main(String[] args) &#123;        Random random = new Random();        int[] a = new int[10];        for(int i=0;i&lt;10;i++)&#123;            a[i]= random.nextInt(90)+10;        &#125;        Arrays.sort(a);        for(int i=0;i&lt;10;i++)&#123;            System.out.printf(&quot;%d &quot;,a[i]);        &#125;    &#125;&#125;\n\n\n\n12、使用for循环语句计算5+55+555+5555+..//2. 编写应用程序，使用for循环语句// 计算5+55+555+5555+...的前10项之和,程序文件命名为“SequenceSum.java”。public class SequenceSum &#123;    public static void main(String[] args) &#123;        long sum=0;        for(int i=1;i&lt;=10;i++)&#123;            sum+=(long)((5.0/9.0)*Math.pow(10,i));        &#125;        System.out.println(&quot;5+55+555+5555+...的前10项之和为&quot;+sum);    &#125;&#125;\n\n\n\n13、输出满足1+2+3+…+n&gt;10000//3. 编写程序，输出// 满足1+2+3+...+n&gt;10000的最小正整数n,程序文件命名为“IntegerMin.java”。public class IntegerMin &#123;    public static void main(String[] args) &#123;        int sum=0;        int i=0;        while (sum&lt;10000)&#123;            sum+=++i;        &#125;        System.out.println(i);    &#125;&#125;\n\n\n\n14、创建一个桌子（Table）类package t14;//4.编写程序，实现以下功能：//创建一个桌子（Table）类，该类中有桌子名称（name）// 重量（weight）、桌面宽度（width）、长度（length）// 和桌子高度（height）属性以及以下几个方法：//（1）无参构造方法：默认值初始化所有成员变量；//（2）有参构造方法：根据参数初始化成员变量；//（3）area():计算桌面的面积；//（4）display():在屏幕上输出所有成员变量的值；//在测试（Test）类的main()方法中实现创建一个桌子对象，// 计算桌面的面积，改变桌子重量，并在屏幕上输出所有桌子属性的值。public class Test &#123;    public static void main(String[] args) &#123;        Table table=new Table();        System.out.println(table.name+&quot;的桌面面积为&quot;+table.area());        table.weight=6;        table.display();    &#125;&#125;class Table&#123;    String name;    double weight,width,lengeh,height;    public Table()&#123;        name = &quot;办公桌&quot;;        weight = 5;        width = 1.5;        lengeh =1.7;        height = 1.2;    &#125;    public Table(String name, double weight, double width, double lengeh, double height) &#123;        this.name = name;        this.weight = weight;        this.width = width;        this.lengeh = lengeh;        this.height = height;    &#125;    double area()&#123;        return width*lengeh;    &#125;    void display()&#123;        System.out.println(&quot;桌子名：&quot;+name);        System.out.println(&quot;桌子的重量：&quot;+weight);        System.out.println(&quot;桌面宽：&quot;+width);        System.out.println(&quot;桌面长：&quot;+lengeh);        System.out.println(&quot;桌子高：&quot;+height);    &#125;&#125;\n\n\n\n15、假定根据学生的3门学位课程的分数决定其是否可以拿到学位//编写程序，实现以下功能：//假定根据学生的3门学位课程的分数决定其是否可以拿到学位，// 对于本科生，如果3门课程的平均分数超过60分即表示通过，// 而对于研究生，则需要平均超过80分才能够通过。根据上述要求，// 请完成以下Java类的设计：//（1）设计一个基类Student描述学生的共同特征。//（2）设计一个描述本科生的类Undergraduate，该类继承并扩展Student类。//（3）设计一个描述研究生的类Graduate，该类继承并扩展Student类。//（4）设计一个测试类StudentText，分别创建本科生和研究生这两个类的对象，// 并输出相关信息(对应学生的姓名、平均分、是否可以拿到学位)，要求平均分保留2位小数。public class StudentText &#123;    public static void main(String[] args) &#123;        UnderGraduate A =new UnderGraduate(&quot;小明&quot;,99,80,55);        Graduate B =new Graduate(&quot;李华&quot;,60,99,86);        System.out.printf(&quot;本科生%s的平均分为%.2f,他&quot;,A.name,A.getAverage());        A.isPass();        System.out.printf(&quot;研究生%s的平均分为%.2f,他&quot;,B.name,B.getAverage());        B.isPass();    &#125;&#125;class Student&#123;    String name;    double courseA,courseB,courseC;    public Student(String name, double courseA, double courseB, double courseC) &#123;        this.name = name;        this.courseA = courseA;        this.courseB = courseB;        this.courseC = courseC;    &#125;    public String getName()&#123;        return name;    &#125;    public double getAverage()&#123;        return (courseA+courseB+courseC) /3;    &#125;&#125;class UnderGraduate extends Student&#123;    public UnderGraduate(String name, double courseA, double courseB, double courseC) &#123;        super(name, courseA, courseB, courseC);    &#125;    void isPass()&#123;        if(this.getAverage()&gt;=60)            System.out.print(&quot;可以拿到学位\\n&quot;);        else            System.out.print(&quot;不可以拿到学位\\n&quot;);    &#125;&#125;class Graduate extends Student&#123;    public Graduate(String name, double courseA, double courseB, double courseC) &#123;        super(name, courseA, courseB, courseC);    &#125;    void isPass()&#123;        if(this.getAverage()&gt;=80)            System.out.print(&quot;可以拿到学位\\n&quot;);        else            System.out.print(&quot;不可以拿到学位\\n&quot;);    &#125;&#125;\n\n\n\n16、设计一个计算柱体应用程序，希望该应用程序可以计算不同柱体的体积//6.编写程序，实现以下功能：//设计一个计算柱体应用程序，希望该应用程序可以计算不同柱体的体积，要求如下：//(1)  首先设计一个抽象类Geometry（几何图形）类，// 在该抽象类中定义一个抽象getArea()方法.//(2)  然后设计PillarL（柱体）类，// 该类的对象调用getVolume()方法计算柱体的体积，//(3)  分别设计Circle（圆）类和Rectangle（矩形）类// 和Triangle（三角形）类作为Geometry类的子类。//(4)  最后设计Application测试类分别求出圆柱的体积，// 四棱柱的体积，三棱柱的体积。//提示：三角形的面积可以由海伦公式计算。//海伦公式：如果一个三角形的三边长为a，b，c，设p=（a+b+c）/2public class Application &#123;    public static void main(String[] args) &#123;        Circle circle = new Circle(5);        Rectangle rectangle = new Rectangle(4,3);        Triangle triangle =new Triangle(3,4,5);        Pillar A = new Pillar(circle,5);        System.out.println(&quot;圆柱的体积为：&quot;+A.getVolmume());        A.bottom=rectangle;        System.out.println(&quot;四棱柱的体积为：&quot;+A.getVolmume());        A.bottom=triangle;        System.out.println(&quot;三棱柱的体积为：&quot;+A.getVolmume());    &#125;&#125;class Pillar&#123;    Geometry bottom;    double height;    public Pillar(Geometry bottom, double height) &#123;        this.bottom = bottom;        this.height = height;    &#125;    double getVolmume()&#123;        return bottom.getArea()*height;    &#125;&#125;abstract class Geometry&#123;    abstract double getArea();&#125;class Circle extends Geometry&#123;    double r;    final double PI = 3.1415926;    public Circle(double r) &#123;        this.r = r;    &#125;    double getArea() &#123;        return PI*Math.pow(r,2);    &#125;&#125;class Rectangle extends Geometry &#123;    double a,b;    public Rectangle(double a, double b) &#123;        this.a = a;        this.b = b;    &#125;    double getArea() &#123;        return a*b;    &#125;&#125;class Triangle extends Geometry&#123;    double a,b,c;    public Triangle(double a, double b, double c) &#123;        this.a = a;        this.b = b;        this.c = c;    &#125;    double getArea() &#123;        double p=(a+b+c)/2;        return Math.sqrt(p*(p-a)*(p-b)*(p-c));    &#125;&#125;\n\n\n\n17、设计一个应用程序，该应用程序用接口实现计算三个数的算术平均数和几何平均数//7.编写程序，实现以下功能：//设计一个应用程序，该应用程序用接口实现计算三个数的算术平均数和几何平均数，// 例如有两个数a,b,c其算术平均数为：（a+b+c）/3;// 其几何平均数为：\\sqrt[3]&#123;a\\ast b\\ast c&#125;。要求如下：// 设计一个接口（CompurerAverage），该接口有一个抽象方法average（）// 要求实现该接口的类完成平均数的计算。// 设计一个ArithmeticAverage类实现算术平均数的运算。// 设计一个GeometryAverage类实现几何平均数的运算。// 设计一个TestAverage测试类完成测试。public class TestAverage &#123;    public static void main(String[] args) &#123;        ArithmeticAverage A =new ArithmeticAverage(3.0,4.0,5.0);        GeometryAverage B =new GeometryAverage(3.0,4.0,5.0);        System.out.println(&quot;3,4,5的算数平均数为&quot;+A.average());        System.out.println(&quot;3,4,5的几何平均数为&quot;+B.average());    &#125;&#125;interface CompurerAverage&#123;    double average();&#125;class ArithmeticAverage implements CompurerAverage&#123;    double a,b,c;    public ArithmeticAverage(double a, double b, double c) &#123;        this.a = a;        this.b = b;        this.c = c;    &#125;    public double average() &#123;        return (a+b+c)/3;    &#125;&#125;class GeometryAverage implements CompurerAverage&#123;    double a,b,c;    public GeometryAverage(double a, double b, double c) &#123;        this.a = a;        this.b = b;        this.c = c;    &#125;    public double average() &#123;        return Math.pow(a*b*c,1.0/3.0);    &#125;&#125;   &#125;&#125;\n\n\n\n18、使用Scanner类的实例解析字符串import java.util.*;//8. 编写程序，实现以下功能：//使用Scanner类的实例解析字符串// “欢迎光临美好生活超市,你所买的苹果20.5元，梨20元,铅笔5.8元，香蕉30.5元，矿泉水20.8元。”// 中的金额，并计算出此次在超市中花费的总额。要求如下：//（1）设计一个givePriceSum类用于解析字符串中的金额。//（2）设计一个PriceSumTest测试类测试结果。public class PriceSumTest &#123;    public static void main(String[] args) &#123;        String cost = &quot;欢迎光临美好生活超市,你所买的苹果20.5元，梨20元,铅笔5.8元，香蕉30.5元，矿泉水20.8元。&quot;;        double priceSum = GetPrice.givePriceSum(cost);        System.out.printf(&quot;%s\\n你此次花费的金额为:%.2f元\\n&quot;,cost,priceSum);    &#125;&#125;class GetPrice &#123;    public static double givePriceSum(String cost) &#123;        Scanner scanner = new Scanner(cost);        scanner.useDelimiter(&quot;[^0-9.]+&quot;); //scanner设置分隔标记        double sum=0;        while(scanner.hasNext())&#123;            try&#123;  double price = scanner.nextDouble();                sum = sum+price;            &#125;            catch(InputMismatchException exp)&#123;                String t = scanner.next();            &#125;        &#125;        return sum;    &#125;&#125;\n\n\n\n19、使用文件字符输入和输出流将文件source File中的内容加到文件target File中public class Test &#123;    public static void main(String args[]) &#123;      File sourceFile = new File(&quot;D:\\\\myjavafile\\\\myProject\\\\myfile\\\\a.txt&quot;);  //读取的文件      File targetFile = new File(&quot;D:\\\\myjavafile\\\\myProject\\\\myfile\\\\b.txt&quot;);  //写入的文件      char c[] =new char[19];               //char型数组       try&#123;           Writer out = new FileWriter(targetFile,true); //指向目的地的输出流         Reader in  = new FileReader(sourceFile);   //指向源的输入流           int n = -1;         while((n=in.read(c))!=-1) &#123;             out.write(c,0,n);         &#125;         out.flush();         out.close();      &#125;      catch(IOException e) &#123;          System.out.println(&quot;Error &quot;+e);      &#125;  &#125;&#125;\n\n\n\n20、输入一行字符串，分别统计出其中英文字母、空格、数import java.util.*;//编程实现输入一行字符串，分别统计出其中// 英文字母、空格、数字和其它字符的个数。程序文件命名为“Counter.java”。public class Counter &#123;    public static void main(String[] args) &#123;        int zm=0,kg=0,sz=0,qt=0;        Scanner read=new Scanner(System.in);        String s = read.nextLine();        char[] a =s.toCharArray();        for(int i=0;i&lt;a.length;i++)&#123;            if ((a[i]&gt;=&#x27;a&#x27;&amp;&amp;a[i]&lt;=&#x27;z&#x27;)||(a[i]&gt;=&#x27;A&#x27; &amp;&amp; a[i]&lt;=&#x27;Z&#x27;))    zm++;            else if (a[i]&gt;=&#x27;0&#x27; &amp;&amp; a[i]&lt;=&#x27;9&#x27;)   sz++;            else if (a[i]==&#x27; &#x27;)  kg++;            else  qt++;        &#125;        System.out.println(&quot;字符串[&quot;+s+&quot;]中&quot;);        System.out.println(&quot;字母有&quot;+zm+&quot;个&quot;);        System.out.println(&quot;数字有&quot;+sz+&quot;个&quot;);        System.out.println(&quot;空格有&quot;+kg+&quot;个&quot;);        System.out.println(&quot;其他字符有&quot;+qt+&quot;个&quot;);    &#125;&#125;","categories":["编程"],"tags":["编程","JAVA"]},{"title":"MathJax-LaTeX公式","url":"/2025/10/16/MathJax-LaTeX%E5%85%AC%E5%BC%8F/","content":"希腊字母小写字母：\n大写字母：\n常见变体：\n上下标\n分式与根式\n\n普通运算符\n\n\n\n\n大型运算符\n单重积分二重积分三重积分曲线积分∯曲面积分∰三重曲面积分\n\n\n标注符号\n箭头\n括号与定界符\n多行公式\n大括号其他\n矩阵\n\n\n\n实战演练\n\n\n\n源代码(MathJax)## 希腊字母小写字母：$$\\alpha,\\ \\beta,\\ \\gamma,\\ \\delta,\\ \\epsilon,\\ \\zeta,\\ \\eta,\\ \\theta,\\ \\iota,\\ \\kappa,\\ \\lambda,\\ \\mu,\\ \\nu,\\ \\xi,\\ \\omicron,\\ \\pi,\\ \\rho,\\ \\sigma,\\ \\tau,\\ \\upsilon,\\ \\phi,\\ \\chi,\\ \\psi,\\ \\omega$$大写字母：$$\\Gamma,\\ \\Delta,\\ \\Theta,\\ \\Lambda,\\ \\Xi,\\ \\Pi,\\ \\Sigma,\\ \\Upsilon,\\ \\Phi,\\ \\Psi,\\ \\Omega$$常见变体：$$\\varepsilon,\\ \\vartheta,\\ \\varpi,\\ \\varrho,\\ \\varsigma,\\ \\varphi$$## 上下标$$\\begin{array}{cl}a^2,a_1\\\\\\\\x^{y+z},p_{ij},p_ij\\\\\\\\x_i,x_{\\text i}\\\\\\\\\\text{A B},\\rm{A B}\\\\\\\\\\text A B,\\rm A B\\\\\\\\{\\rm A} B\\\\\\\\\\text{e},\\text{i}\\end{array}$$## 分式与根式$$\\frac{1}{2},\\frac 1 2,\\\\\\frac 1 {x+y}\\\\\\frac {\\dfrac 1 x + 1}{y + 1}$$$$\\sqrt 2,\\sqrt{x+y},\\sqrt[3]x$$## 普通运算符$$\\begin{array}{cl}+-\\\\\\\\\\times,\\cdot,\\div\\\\\\\\\\pm,\\mp\\\\\\\\\\ge,\\le,\\gg,\\ll,\\ne,\\approx,\\equiv\\\\\\\\\\cap,\\cup,\\in,\\notin,\\subseteq,\\subsetneqq,\\varnothing\\\\\\\\\\forall,\\exists,\\nexists\\\\\\\\\\because,\\therefore\\\\\\\\\\mathbb R,\\mathbb R,\\mathbb Q,\\mathbb N,\\mathbb Z_+\\\\\\\\\\mathcal F,\\mathscr F\\end{array}$$$$\\cdots,\\vdots,\\ddots$$$$\\infty,\\partial,∂,\\nabla,\\propto,\\degree$$$$\\begin{array}{cl}\\sin x,\\sec x,\\cosh x\\\\\\\\\\log_2 x, \\ln x,\\lg x\\\\\\\\\\lim\\limits_{x \\to 0} \\frac { x}{\\sin x}\\\\\\\\\\max x\\end{array}$$$$\\text{MSE}(x)$$## 大型运算符$$\\sum,\\prod\\\\\\sum_i,\\sum_{i=0}^N\\\\\\frac{\\sum\\limits_{i=1}^n x_i}{\\prod\\limits_{i=1}^n x_i}$$$$\\begin{array}{cl}\\int &amp; \\verb|\\int| \\text{ 单重积分} \\\\\\\\\\iint &amp; \\verb|\\iint| \\text{ 二重积分} \\\\\\\\\\iiint &amp; \\verb|\\iiint| \\text{ 三重积分} \\\\\\\\\\oint &amp; \\verb|\\oint| \\text{ 曲线积分} \\\\\\\\\\unicode{x222F} &amp; \\verb|\\unicode{x222F}| \\text{ 曲面积分 (oiint)} \\\\\\\\\\unicode{x2230} &amp; \\verb|\\unicode{x2230}| \\text{ 三重曲面积分 (oiiint)}\\end{array}$$$$\\int_{-\\infty}^0 f(x)\\,\\text d x\\\\$$$$\\begin{array}{cl}a\\, a \\\\\\\\a\\ a \\\\\\\\a\\quad a \\\\\\\\a\\qquad a\\end{array}$$## 标注符号$$\\vec x,\\overrightarrow {AB}\\\\\\bar x,\\overline{AB}$$## 箭头$$\\leftarrow,\\Rightarrow,\\Leftrightarrow,\\longleftarrow$$## 括号与定界符$$\\begin{array}{cl}([])\\{ \\}\\\\\\\\\\lceil,\\rceil,\\lfloor,\\rfloor,||\\\\\\\\\\left(0,\\frac 1 a\\right]\\\\\\\\\\left.\\frac {∂f}{∂x}\\right|_{x=0}\\end{array}$$## 多行公式$$\\begin{align} a&amp;=b+c+d\\\\\\\\\\&amp;=e+f \\end{align}$$## 大括号$$f(x)=\\begin{cases}\\sin x, &amp; -π\\le x \\le π\\\\\\\\0,&amp; \\text{其他}\\end{cases}$$## 矩阵$$\\begin{matrix}a &amp; b &amp; \\cdots &amp; c \\\\\\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\e &amp; f &amp; \\cdots &amp; g\\end{matrix}$$$$\\begin{bmatrix}a &amp; b &amp; \\cdots &amp; c \\\\\\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\e &amp; f &amp; \\cdots &amp; g\\end{bmatrix}\\quad\\begin{pmatrix}a &amp; b &amp; \\cdots &amp; c \\\\\\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\e &amp; f &amp; \\cdots &amp; g\\end{pmatrix}\\quad\\begin{vmatrix}a &amp; b &amp; \\cdots &amp; c \\\\\\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\e &amp; f &amp; \\cdots &amp; g\\end{vmatrix}$$$$\\begin{Bmatrix}a &amp; b &amp; \\cdots &amp; c \\\\\\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\e &amp; f &amp; \\cdots &amp; g\\end{Bmatrix}\\quad\\begin{Vmatrix}a &amp; b &amp; \\cdots &amp; c \\\\\\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\e &amp; f &amp; \\cdots &amp; g\\end{Vmatrix}$$$$\\bf A,\\bf B^{\\rm T}$$## 实战演练$$f(x) = \\frac 1 {\\sqrt{2\\pi} \\sigma} {\\rm e} ^ {-\\frac {(x-\\mu)^2}{2\\sigma ^ 2}}\\\\\\\\f(x) = \\frac 1 {\\sqrt{2\\pi} \\sigma} \\exp \\left[ {-\\frac {(x-\\mu)^2}{2\\sigma ^ 2}}\\right]$$$$\\\\lim_{N\\\\to\\\\infty} P\\\\left\\\\{\\\\left|\\\\frac{I(\\\\alpha_i)}{N} - H(s)\\\\right| &lt; \\\\varepsilon\\\\right\\\\} = 1$$$$x(n) = \\frac 1 {2\\pi} \\int _{-π} ^ π X\\left( {\\rm e} ^ {{\\rm j} \\omega } \\right) {\\rm e} ^ {{\\rm j} \\omega n} \\, {\\rm d}\\omega\\\\$$$$\\begin{align}\\vec B \\left( \\vec r \\right) &amp;= \\frac {\\mu_0}{4\\pi}\\oint_C \\frac {I \\, {\\rm d} \\vec l \\times \\vec R}{R^3}\\\\\\\\&amp;= \\frac {\\mu_0}{4\\pi} \\int_V \\frac{\\vec J_V \\times \\vec R}{R^3}\\, {\\rm d} V'\\end{align}$$\n\n\n\n\n\n","categories":["LaTeX"],"tags":["MathJax","LaTeX"]},{"title":"OEC/OEC-T实现精确稳定自动挂载硬盘——避免检测不到硬盘无法启动问题","url":"/2025/10/19/OEC-OEC-T%E5%AE%9E%E7%8E%B0%E7%B2%BE%E7%A1%AE%E7%A8%B3%E5%AE%9A%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/","content":"在 Armbian 系统中，挂载硬盘是一个常见操作。但传统的挂载方式（如直接修改 /etc/fstab 文件）存在一定风险：一旦硬盘无法正常挂载，可能导致系统无法启动。本文介绍一种更安全、更稳定的挂载方式：使用 UUID 和 systemd 挂载单元文件。这种方式不仅精确，还能确保在硬盘无法挂载时，系统依然可以正常启动，实现更高的安全性和稳定性。\n\n为什么推荐使用 UUID 挂载？\n精确性：UUID（通用唯一标识符）是硬盘分区的唯一标识，不会因设备名称（如 /dev/sda1）变化而改变。  \n稳定性：传统挂载依赖设备名，可能因启动顺序等因素变动导致挂载失败。UUID 始终唯一，确保稳定挂载。  \n安全性：systemd 挂载单元文件结合 nofail 选项，即使硬盘无法挂载，系统也能正常启动，避免系统崩溃。\n\n\n挂载教程详解以下以挂载 1 块 SATA 为例，演示如何通过 UUID 和 systemd 挂载单元实现自动挂载，USB 外挂硬盘同理。\n1. 查看硬盘信息，获取 UUID\n打开 SSH 终端，查看所有存储设备和分区信息： lsblk\n找到你要挂载的分区（如 /dev/sda1、/dev/sdb1），查询其 UUID 和文件系统类型： sudo blkid /dev/sda1\n 输出示例： /dev/sda1: UUID=&quot;4a98af13f-452e-d447-bdd8-87306eec8437&quot; TYPE=&quot;ext4&quot;\n\n请记下对应的 UUID 和 TYPE，后续会用到。\n\n\n\n\n2. 创建挂载点在 /mnt 目录下为硬盘创建挂载点（如 /mnt/HDD、/mnt/SSD）：\nsudo mkdir -p /mnt/HDD\n\n\n3. 创建 systemd 挂载单元文件用文本编辑器（如 vim、nano、notepad++ 等）新建名为 mnt-HDD.mount 的文件，内容如下：\n[Unit]Description=Mount Disk with UUIDRequires=local-fs.targetAfter=local-fs.target[Mount]What=/dev/disk/by-uuid/4a98af13f-452e-d447-bdd8-87306eec8437Where=/mnt/HDDType=ext4Options=defaults,nofail[Install]WantedBy=multi-user.target\n\n\n\nWhat：这里的 UUID 请替换成你实际查询到的 UUID。\nType：请根据实际分区的文件系统类型填写（如 ext4、ntfs、exfat 等）。\nWhere：对应你的挂载点路径。\n\n\n\n4. 上传文件到系统使用 WinSCP 或其他工具，将刚才编辑好的 mnt-HDD.mount 文件上传到 /etc/systemd/system/ 目录下。\n\n5. 启用并启动挂载单元\n使挂载单元随系统启动自动挂载： sudo systemctl enable mnt-HDD.mount\n立即挂载（无需重启）： sudo systemctl start mnt-HDD.mount\n\n\n6. 验证挂载效果\n查看挂载是否成功： mount | grep /mnt/HDD\n或检查 systemd 单元状态： sudo systemctl status mnt-HDD.mount\n 正常情况下会看到类似输出： /dev/sda1 on /mnt/HDD type ext4 (rw,relatime)\n\n\n7. 重启系统确认重启系统，验证自动挂载是否生效：\nsudo reboot\n\n\n8. 验证自动挂载重启后，再次使用 lsblk 或 mount | grep /mnt/HDD 检查分区是否已自动挂载到 /mnt/HDD。\n\n其他注意事项\nUUID 检查：确保 UUID 填写无误。可随时用 blkid 命令查询。\n文件系统类型：Type=ext4 需与你的分区实际文件系统类型一致。\n挂载选项：Options=defaults,nofail 中的 nofail 表示即使硬盘不存在，系统也不会报错。如果希望硬盘必须存在，可以去掉 nofail。\n多块硬盘：多块硬盘时，分别创建不同的挂载点和对应的 .mount 文件即可。\n\n\n总结通过上述方法，使用 UUID 和 systemd 挂载单元文件，可以让 Armbian（OEC&#x2F;OECT）系统实现精确、稳定且安全的硬盘自动挂载。即使硬盘临时失联，系统也能正常启动，极大提升了系统的健壮性和可维护性。\n","categories":["Linux"],"tags":["日常","Linux"]},{"title":"YOLOv10初见","url":"/2025/10/09/YOLOv10%E5%88%9D%E8%A7%81/","content":"概述YOLOv10是清华大学研究人员在Ultralytics软件包基础上推出的最新一代实时目标检测算法。作为YOLO系列的重要革新，YOLOv10通过消除NMS后处理和全面优化模型架构，在保持实时性的同时实现了最先进的检测性能3,7。\n本文将深入解析YOLOv10的核心创新、架构设计和训练策略，帮助读者全面了解这一突破性技术的原理与优势。\n核心创新亮点1. 无NMS端到端检测传统YOLO版本依赖非极大值抑制（NMS）后处理来消除重复检测框，但这增加了计算开销和推理延迟。YOLOv10通过一致的双重标签分配策略，彻底摆脱了对NMS的依赖4,9。\n双重检测头设计：\n\n一对多头（One-to-Many Head）：训练时为每个真实框分配多个正样本，提供丰富的监督信号\n一对一头（One-to-One Head）：推理时为每个目标生成唯一预测框，实现端到端检测\n\n通过一致匹配度量（$ \\mathcal{M} &#x3D; p \\cdot \\text{IoU} \\cdot s $）协调两种策略，确保分类置信度、定位精度与空间先验的深度对齐9。\n2. 效率-精度驱动的模型设计YOLOv10从整体架构层面优化了计算效率与精度的平衡：\n轻量级组件设计：\n\n轻量级分类头：采用深度可分离卷积减少计算冗余\n空间-通道解耦下采样（SC-Down）：将空间缩减与通道调制解耦，最小化信息损失\n秩引导块设计：根据阶段冗余调整模块结构，优化参数利用4,7\n\n特征提取增强：\n\n大核卷积（7×7）：扩大感受野，增强上下文信息捕捉能力，尤其在轻量级变体中效果显著\n部分自注意力模块（PSA）：以最小开销改进全局表征学习2,3\n\n网络架构详解骨干网络（Backbone）YOLOv10采用增强版CSPNet作为骨干网络，引入动态稀疏卷积机制，通过动态激活区域选择减少冗余计算。结合大核深度卷积，在深层阶段扩大感受野，显著提升复杂场景下的特征捕捉能力9。\n颈部网络（Neck）传统的PANet被分阶段特征融合机制替代，通过可学习权重动态调整深浅特征的融合比例。在浅层侧重细节信息（如边缘），深层侧重语义信息（如类别），实现更高效的多尺度特征融合9。\n检测头（Head）双头设计是YOLOv10的核心创新：\n\n训练阶段：同时使用一对多头和一对一头，通过双重监督提高学习准确性\n推理阶段：仅使用一对一头，直接输出最终检测结果，无需NMS后处理4\n\n性能表现下表展示了YOLOv10各版本在COCO数据集上的性能对比7：\n\n\n\n模型变体\n输入尺寸\nAPval\n参数量\nFLOPs\n延迟\n\n\n\nYOLOv10-N\n640×640\n38.5%\n2.3M\n6.7G\n1.84ms\n\n\nYOLOv10-S\n640×640\n46.3%\n7.2M\n21.6G\n2.49ms\n\n\nYOLOv10-M\n640×640\n51.1%\n15.4M\n59.1G\n4.74ms\n\n\nYOLOv10-B\n640×640\n52.5%\n19.1M\n92.0G\n5.74ms\n\n\nYOLOv10-L\n640×640\n53.2%\n24.4M\n120.3G\n7.28ms\n\n\nYOLOv10-X\n640×640\n54.4%\n29.5M\n160.4G\n10.70ms\n\n\n性能优势：\n\n与YOLOv9相比，YOLOv10-B在相同性能下延迟减少46%，参数量减少25%9\nYOLOv10-S的速度是RT-DETR-R18的1.8倍，参数量和FLOPs减少2.8倍7\n\n训练策略与优化双重标签分配策略YOLOv10采用动态软匹配机制，根据训练阶段动态调整正负样本匹配策略：初期放宽IoU阈值加速收敛，后期收紧以提升精度。与YOLOv9的SimOTA相比，收敛速度加快20%，小目标漏检率降低15%9。\n损失函数设计复合损失函数融合了：\n\nPowerful-IoU：改进版CIoU，强化定位精度\nSlideLoss：动态平衡样本分布\n\n在COCO数据集上，该组合使定位误差降低12%，正负样本分类置信度方差缩小18%9。\n实际应用与部署边缘设备优化轻量化版本YOLOv10-N仅2.3M参数，在树莓派4B上实现45 FPS检测速度，mAP达39.5%。与YOLOv5-N相比，参数量减少60%，速度提升30%9。\n多任务支持YOLOv10支持目标检测、实例分割与关键点检测的多任务联合学习。在Cityscapes数据集上，多任务联合训练使mAP（检测）与mIoU（分割）分别达到68.2%和63.5%，较独立训练提升5.7%和4.1%9。\n总结与展望YOLOv10通过无NMS端到端检测、双重标签分配策略和全局效率-精度优化，重新定义了实时目标检测的性能边界。其在COCO数据集上的mAP突破54.4%，同时保持120 FPS的推理速度，实现了精度与效率的双重超越9。\n随着自动驾驶、工业质检和智能监控等应用对实时性要求的不断提高，YOLOv10的创新设计为边缘计算场景下的高效目标检测提供了新的解决方案。其端到端的架构不仅简化了部署流程，更为未来实时视觉系统的发展指明了方向。\n\n参考资料：YOLOv10论文源码及预训练模型可在官方GitHub仓库获取：https://github.com/THU-MIG/yolov10\n\n","categories":["深度学习"],"tags":["目标检测","YOLO"]},{"title":"Python的100个代码示例","url":"/2025/10/12/Python%E7%9A%84100%E4%B8%AA%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/","content":"1. 生成6位数字随机验证码import randomimport stringdef num_code(length=6):    &quot;&quot;&quot;    生成长度为length的数字随机验证码    :param length: 验证码长度    :return: 验证码    &quot;&quot;&quot;        return &#x27;&#x27;.join(random.choice(string.digits) for i in range(0, length))\n\n2.md5加密import  hashlib# md5加密def md5_encrypt(en_str):    &quot;&quot;&quot;    使用md5二次加密生成32位的字符串    :param en_str: 需要加密的字符串    :return: 加密后的字符串    &quot;&quot;&quot;       md5 = hashlib.md5()  # 使用MD5加密模式    md5.update(en_str.encode(&#x27;utf-8&#x27;))  # 将参数字符串传入    md5.update(md5.hexdigest().encode(&#x27;utf-8&#x27;))  # md5二次加密    return md5.hexdigest()\n\n3. 生成唯一tokenimport uuid\nimport  hashlib\n\ndef only_token():\n    &quot;&quot;&quot;\n    使用md5加密uuid生成唯一的32位token\n    :return: 加密后的字符串\n    &quot;&quot;&quot;\nmd5 = hashlib.md5()  # 使用MD5加密模式\nmd5.update(str(uuid.uuid1()).encode(&#39;utf-8&#39;))  \nreturn md5.hexdigest()\n\n4、发送手机验证码#验证码管理表class AuthCode(models.Model):    name = models.CharField(max_length=10,default=None, null=True, blank=True,verbose_name=&#x27;姓名&#x27;)    phone = models.CharField(max_length=11, unique=True, verbose_name=&#x27;手机号&#x27;)    code = models.CharField(max_length=6,verbose_name=&#x27;验证码&#x27;)    purpose = models.IntegerField(default=0,verbose_name=&#x27;用途:0-&gt;注册验证 1-&gt;找回密码 2-&gt;其它&#x27;)    sendNum = models.IntegerField(default=0,verbose_name=&#x27;发送次数&#x27;)    isCanGet = models.BooleanField(default=0,verbose_name=&#x27;0-&gt;可以获取,1-&gt;不可以获取&#x27;)    recentlySendTime = models.DateTimeField(auto_now_add=True,verbose_name=&#x27;最近一次发送时间&#x27;)    creation_time = models.DateTimeField(auto_now=True, verbose_name=&#x27;创建时间&#x27;)    class Meta:        verbose_name = &#x27;手机验证码&#x27;        verbose_name_plural = verbose_name\n\n实现逻辑import http.clientimport urllib# 使用互亿无线host = &quot;106.ihuyi.com&quot;sms_send_uri = &quot;/webservice/sms.php?method=Submit&quot;# 查看用户名 登录用户中心-&gt;验证码通知短信&gt;产品总览-&gt;API接口信息-&gt;APIIDaccount = &quot;你的用户名&quot;# 查看密码 登录用户中心-&gt;验证码通知短信&gt;产品总览-&gt;API接口信息-&gt;APIKEYpassword = &quot;你的密码&quot;def send_sms(text, mobile):    text = f&quot;您的验证码是：&#123;text&#125;。请不要把验证码泄露给其他人。&quot;    params = urllib.parse.urlencode(        &#123;&#x27;account&#x27;: account, &#x27;password&#x27;: password, &#x27;content&#x27;: text, &#x27;mobile&#x27;: mobile, &#x27;format&#x27;: &#x27;json&#x27;&#125;)    headers = &#123;&quot;Content-type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;Accept&quot;: &quot;text/plain&quot;&#125;    conn = http.client.HTTPConnection(host, port=80, timeout=30)    conn.request(&quot;POST&quot;, sms_send_uri, params, headers)    response = conn.getresponse()    response_str = response.read()    conn.close()    return response_strif __name__ == &#x27;__main__&#x27;:    mobile = &quot;手机号&quot;    text = &#x27;123122&#x27;    print(json.loads(send_sms(text, mobile).decode(&#x27;utf-8&#x27;)))\n\n5、生成二维码import qrcodeimport iodef maker_qrcode(url):    &quot;&quot;&quot;    生成二维码    :param url: 需要生成二维码的url    :return: 返回图片字节流    &quot;&quot;&quot;    image = qrcode.make(url)  # 创建二维码片    buffer = io.BytesIO()    # 将图片内容丢入容器    image.save(buffer, &#x27;png&#x27;)    # 返回容器内的字节    return buffer.getvalue()    或者from .settings import BASE_DIRdef create_qrcode(name, url):    &quot;&quot;&quot;    生成机器扫码支付二维码    :param name: 图片名称    :param url: 支付路由    :return:    &quot;&quot;&quot;    img = qrcode.make(url, border=0)  # 创建二维码片    save_path = BASE_DIR + &#x27;/&#x27; + name + &#x27;.png&#x27;    print(save_path)    img.save(save_path)    return img\n\n6.微信群发# coding=utf8import itchat, timeitchat.auto_login(True)SINCERE_WISH = u&#x27;祝%s新年快乐！&#x27;friendList = itchat.get_friends(update=True)[35:]count = 0for  index,friend in enumerate(friendList):    print(index,friend[&#x27;DisplayName&#x27;],friend[&#x27;NickName&#x27;])    itchat.send(SINCERE_WISH % (friend[&#x27;DisplayName&#x27;]                                or friend[&#x27;NickName&#x27;]), friend[&#x27;UserName&#x27;])    time.sleep(2)    print(&#x27;备注名称&#x27;,friend[&#x27;DisplayName&#x27;],&#x27;昵称&#x27;,friend[&#x27;NickName&#x27;],&#x27;用户名&#x27;,friend[&#x27;UserName&#x27;])print(&quot;----end----&quot;)&quot;&quot;&quot;# 发送文本itchat.send(&#x27;Hello, WeChat!&#x27;)# 发送图片itchat.send_image(&#x27;my_picture.png&#x27;)# 发送视频itchat.send_video(&#x27;my_video.mov&#x27;)# 发送文件itchat.send_file(&#x27;my_file.zip&#x27;)&quot;&quot;&quot;\n\n7、微信自动回复# -*- coding=utf-8 -*-import requestsimport itchatimport random#图灵机器人#http://www.tuling123.com/member/robot/1380138/center/frame.jhtml?page=0&amp;child=0获取apikeyKEY = &#x27;你的KEY&#x27;def get_response(msg):    apiUrl = &#x27;http://www.tuling123.com/openapi/api&#x27;    data = &#123;        &#x27;key&#x27;    : KEY,        &#x27;info&#x27;   : msg,        &#x27;userid&#x27; : &#x27;wechat-robot&#x27;,    &#125;    try:        r = requests.post(apiUrl, data=data).json()        return r.get(&#x27;text&#x27;)    except:        return@itchat.msg_register(itchat.content.TEXT)def tuling_reply(msg):    defaultReply = &#x27;I received: &#x27; + msg[&#x27;Text&#x27;]    robots=[&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;]    reply = get_response(msg[&#x27;Text&#x27;])+random.choice(robots)    return reply or defaultReplyitchat.auto_login(enableCmdQR=False)itchat.run()\n\n8、提取Django中model中的字段名变成字典、列表import ret = &quot;&quot;&quot;    goods_id = models.IntegerField(verbose_name=&#x27;商品编号&#x27;)    label_code = models.CharField(max_length=20, verbose_name=&#x27;商品标签&#x27;)&quot;&quot;&quot;# 字典print(&#123;k:None for k in re.findall(&#x27;([a-z_A-Z]+)\\s=\\s&#x27;,t)&#125;)# 列表# print([k for k in re.findall(&#x27;([a-z_A-Z]+)\\s=\\s&#x27;,t)])输出&#123;&#x27;goods_id&#x27;: None, &#x27;lable_code&#x27;: None&#125;\n\n9、数据库中给表创建数据import pymysqldef createData(dataDict,tableName):    &quot;&quot;&quot;    给数据表创建数据    :param dataDict: 字典    :param tableName: 表名    :return:     &quot;&quot;&quot;    #连接数据库    conn = pymysql.connect(        host=&#x27;192.168.0.188&#x27;, #数据库所在地址URL        user=&#x27;root&#x27;, #用户名        password=&#x27;123456&#x27;, #密码        database=&#x27;名称&#x27;, #数据库名称        port=3306,  #端口号        charset=&#x27;utf8&#x27;    )    #拿到查询游标    cursor = conn.cursor()    clos,value = zip(*dataDict.items())    sql = &quot;INSERT INTO `%s`(%s) VALUES (%s)&quot; % (tableName,                                                &#x27;,&#x27;.join(clos),                                                &#x27;,&#x27;.join([&#x27;%s&#x27;] * len(value))                                                )    print(sql)    cursor.execute(sql, value)    conn.commit()    cursor.close()    conn.close()    print(&#x27;Done&#x27;)\n\n10.捕捉异常try:    passexcept 异常类型 as e:    passfinally:    pass        异常类型Exception  全部异常AttributeError 试图访问一个对象没有的属性，比如foo.x，但是foo没有属性xIOError 输入/输出异常；基本上是无法打开文件ImportError 无法引入模块或包；基本上是路径问题或名称错误IndentationError 语法错误（的子类） ；代码没有正确对齐IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5]KeyError 试图访问字典里不存在的键KeyboardInterrupt Ctrl+C被按下NameError 使用一个还未被赋予对象的变量SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）TypeError 传入对象类型与要求的不符合UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，导致你以为正在访问它ValueError 传入一个调用者不期望的值，即使值的类型是正确的\n\n11、获取当前时间import datetimecurrent_time = str(datetime.datetime.now())[:19]print(current_time)输出格式如：2018-10-20 10:01:43local_time = time.strftime(&#x27;%Y%m%d%H%M%S&#x27;, time.localtime(time.time()))print(local_time)\n\n12、订单编号from random import Randomimport timedef random_str(randomlength=8):    str = &#x27;&#x27;    chars = &#x27;AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0123456789&#x27;    length = len(chars) - 1    random = Random()    for i in range(randomlength):        str+=chars[random.randint(0, length)]    return strdef order_num():    &quot;&quot;&quot;    生成付款订单号    :return:    &quot;&quot;&quot;    local_time = time.strftime(&#x27;%Y%m%d%H%M%S&#x27;, time.localtime(time.time()))    result = local_time + random_str(5)    return resultprint(order_num())\n\n13、mysql自动填写当前时间CURRENT_TIMESTAMP\n\n\n为表添加索引ALTER table tableName ADD INDEX indexName(columnName)\n\n14、drf动态过滤查询# page.pyfrom rest_framework.pagination import PageNumberPaginationclass UserPagination(PageNumberPagination):    &quot;&quot;&quot;用户分页器&quot;&quot;&quot;    page_size = 10  # 默认的页面数据数量    page_query_param = &#x27;page&#x27;  # 定制取数据页码key     page_size_query_param = &#x27;page_size&#x27;  # 默认取数据页码key     max_page_size = 15   # 数据每页取值的最大上限# serializers.pyfrom rest_framework import serializersfrom user.models import UserInfoclass UserSerializers(serializers.ModelSerializer):    &quot;&quot;&quot;用户收货地址&quot;&quot;&quot;    class Meta:        model = UserInfo\t    # 所有字段        #fields = &#x27;__all__&#x27;        fields = [&#x27;name&#x27;, &#x27;code&#x27;, &#x27;title&#x27;,  &#x27;province&#x27;, &#x27;city&#x27;,                    &#x27;quxian&#x27;, &#x27;address&#x27;, &#x27;code__gte&#x27;, &#x27;code__lte&#x27;]        # 显示外键        depth = 2# views.pyclass MachineViews(APIView):    def get(self, request, *args, **kwargs):        # 从前端获取出来的过滤参数，解析成字典传进filter()函数中        # 动态过滤，        kwargs = &#123;&#125;        # 表中的字段名        columns = [&#x27;name&#x27;, &#x27;code&#x27;, &#x27;title&#x27;,  &#x27;province&#x27;, &#x27;city&#x27;,                    &#x27;quxian&#x27;, &#x27;address&#x27;, &#x27;code__gte&#x27;, &#x27;code__lte&#x27;]        for k, v in request.query_params.items():            if k not in columns:                return Response(&#x27;参数不对&#x27;, status=status.HTTP_400_BAD_REQUEST)\t\t\tif v:            \tkwargs[k] = v        users = UserInfo.objects.filter(**kwargs)        page = UserPagination()        page_goods_list = page.paginate_queryset(users, self.request, self)        ser = UserSerializers(page_goods_list, many=True)        return page.get_paginated_response(ser.data)        \n\n15、linux后台运行python程序nohup /home/project_venv/user/bin/python3 -u /home/user/user_server.py &gt;&gt; /home/user/user.log 2&gt;&amp;1 &amp;   \n\n16、追加外键ALTER TABLE tb_commentPhoto ADD CONSTRAINT FK_comment_phoneFOREIGN KEY tb_goodsComment(id) REFERENCES tb_commentPhoto(comment_id);\n\n17、写&#x2F;读CSV文件，查看是否存在，若存在就从csv中删除import csvimport randomimport stringdef create_invite_code(random_code_pool=None, length=6, num=10, is_append=False):    &quot;&quot;&quot;    创建随机邀请码,并写入txt文件    :param: random_code_pool 随机邀请码    :param: length 邀请码长度    :param: num 邀请码个数    :param: is_append True追加,False 覆盖    :return:    &quot;&quot;&quot;    if not random_code_pool:        code_pool = string.ascii_uppercase + string.digits        random_code_pool = []        for i in range(num):            s = &#x27;&#x27;            for _ in range(length):                s += random.choice(code_pool)            if s and s not in random_code_pool:                random_code_pool.append(s)    # 写入方法。是追加还是覆盖    write_method = &#x27;a+&#x27; if is_append else &#x27;w&#x27;    # 写入文件    with open(&#x27;./invite_code.csv&#x27;, write_method, newline=&#x27;&#x27;) as f:        writer = csv.writer(f)        for rowData in random_code_pool:            # 按行写入            writer.writerow((rowData,))def check_invite_code(code):    &quot;&quot;&quot;    查看邀请码是否存在txt文件中，    若存在就返回True，并在txt文件中删除    若不存在就返回False    :param code:    :return:    &quot;&quot;&quot;    code_pool = []    with open(&#x27;./invite_code.csv&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;,errors=&#x27;ignore&#x27;) as f:        allFileInfo = csv.reader(f)        for row in allFileInfo:            code_pool.append(row[0])    if code in code_pool:        # 删除查询的code        code_pool.pop(code_pool.index(code))        # 重新写入文件        create_invite_code(code_pool,is_append=False)        return True    return Falseif __name__ == &#x27;__main__&#x27;:    # create_invite_code(length=9,num=100)    print(check_invite_code(&#x27;WJ4PSTJG2&#x27;))\n\n18、django中从request获取访问路径print(&#x27;获取相对路径&#x27;, request.get_full_path())print(&#x27;获取绝对路径&#x27;, request.build_absolute_uri())print(request.build_absolute_uri(&#x27;?&#x27;))print(request.build_absolute_uri(&#x27;/&#x27;)[:-1].strip(&quot;/&quot;))print(request.build_absolute_uri(&#x27;/&#x27;).strip(&quot;/&quot;))print(request.build_absolute_uri(&#x27;/&#x27;))print(&#x27;----------&#x27;)print(request.META[&#x27;HTTP_HOST&#x27;])print(request.META[&#x27;PATH_INFO&#x27;])print(request.META[&#x27;QUERY_STRING&#x27;])iphost = request.META.get(&#x27;REMOTE_ADDR&#x27;, &#x27;&#x27;)  # 获取访问来源IP# 输出如：获取相对路径 /QRcode/?d=1获取绝对路径 http://127.0.0.1:8000/QRcode/?d=1http://127.0.0.1:8000/QRcode/http://127.0.0.1:8000http://127.0.0.1:8000http://127.0.0.1:8000/----------127.0.0.1:8000/QRcode/d=1\n\n19、Django收集静态文件先在项目根目录下创建一个static文件夹然后在settings.py中设置STATIC_ROOT = os.path.join(BASE_DIR, &#x27;static&#x27;)最后执行下面的命令：python manage.py collectstatic\n\n20、xadmin插件https://www.cnblogs.com/lanqie/p/8340215.html\n21、uwsgi自动重启[uwsgi]# 使用nginx连接时 使用socket=0.0.0.0:2019# 直接作为web服务器使用#http=0.0.0.1:8000# 配置工程目录chdir=/home/user# 配置项目的wsgi目录。相对于工程目录wsgi-file=user/wsgi.pyvirtualenv=/home/project_venv/user#配置进程，线程信息processes=1threads=1enable-threads=Truemaster=Truepidfile=uwsgi.piddaemonize=uwsgi.log#启动uwsgi的用户名和用户组uid=rootgid=root#uwsgi自动重启py-autoreload=1\n\n22、谷歌浏览器快捷键浏览器缓存Ctrl+Shift+Del  清除Google浏览器缓存的快捷键Ctrl+Shift+R  重新加载当前网页而不使用缓存内容\n\n23、git克隆分支git clone -b dev 地址 \n\n24、mysql更新语句、新增列、删除列update user set name=&#x27;张三&#x27; where id=111# 删除DELETE FROM table_name [WHERE Clause]# 增加字段alter table 表名 add column 列名 类型;# 删除字段alter table 表名 dropcolumn 列名 ;\n\n25、删除指定格式的文件import osimport redef remove_specified_format_file(file_dir, format_name):    &quot;&quot;&quot;    删除指定格式的文件    :param file_dir: 文件根目录    :param format_name: 格式    :return:    &quot;&quot;&quot;    for root, dirs, files in os.walk(file_dir):        # print(root) #当前目录路径        # print(dirs) #当前路径下所有子目录        # print(files) #当前路径下所有非目录子文件        for file in files:            if re.match(format_name, file):                print(os.path.join(root, file))                os.remove(os.path.join(root, file))remove_specified_format_file(r&#x27;D:\\学习\\LDC\\java&#x27;, r&#x27;\\._*&#x27;)\n\n26、计算文件总数import osdef file_count(file_dir):    &quot;&quot;&quot;        :param file_dir: 文件根目录    :return:    &quot;&quot;&quot;    count = 0    for root, dirs, files in os.walk(file_dir):        # print(root) #当前目录路径        # print(dirs) #当前路径下所有子目录        # print(files) #当前路径下所有非目录子文件        count += len(files)    return countprint(file_count(r&#x27;D:\\学习\\LDC\\java\\Java学习\\newEstore\\estore\\js&#x27;))\n\n27、计算文件夹大小import osdef file_size(file_dir):    &quot;&quot;&quot;    删除指定格式的文件    :param file_dir: 文件根目录    :return:    &quot;&quot;&quot;    size = 0    for root, dirs, files in os.walk(file_dir):        # print(root) #当前目录路径        # print(dirs) #当前路径下所有子目录        # print(files) #当前路径下所有非目录子文件        for file in files:            size += os.path.getsize(os.path.join(root, file))\t# M为单位    return size / 1024 / 1024file_name = r&#x27;D:\\学习&#x27;print(file_size(file_name))\n\n28、Django实现jsonp跨域# html$.ajax(&#123;                    url: &#x27;请求路由&#x27;,                    type: &#x27;GET&#x27;,                    dataType: &#x27;JSONP&#x27;,                    data:&#123;                      code: &#x27;yes&#x27;,                    &#125;,                    jsonp: &#x27;callback&#x27;,                    success: function(res) &#123;                       var selectData = $.parseJSON(res);                       alert(selectData);                    &#125;,                    error: function(err) &#123;                    &#125;                &#125;)# views.pydef get(self, request, *args, **kwargs):        code = request.GET.get(&#x27;code&#x27;, &#x27;&#x27;)        # 跨域请求        callback = request.GET.get(&#x27;callback&#x27;, &#x27;&#x27;)        return HttpResponse(&quot;%s(&#x27;%s&#x27;)&quot; % (callback, json.dumps(&#123;&#x27;code&#x27;: code&#125;)), status=status.HTTP_200_OK)                    cors解决跨域https://www.cnblogs.com/wxiaoyu/p/9578848.html\n\n29、微信获取用户信息参考：https://blog.csdn.net/weixin_39735923/article/details/79202563\n30、uwsgi初始配置问题https://blog.csdn.net/weixin_39735923/article/details/79202563\n31、django中drf序列化# 序列化器class MsgSerializers(serializers.ModelSerializer):    addtime = serializers.DateTimeField(read_only=True, format=&quot;%Y-%m-%d %H:%M:%S&quot;)    hasread = serializers.CharField(source=&#x27;get_hasread_display&#x27;)    msgtype = serializers.CharField(source=&#x27;get_msgtype_display&#x27;)    class Meta:        model = MallMsg        # 可以混合使用        fields = &#x27;__all__&#x27;  # &#x27;__all__&#x27; 所有字段        # 数据库层级控制（序列化链表操作）        # depth = 1  # 外键层级#分页器from rest_framework.pagination import PageNumberPaginationclass MyLimitOffsetPagination(PageNumberPagination):    page_size = 3  # 默认的页面数据数量    page_query_param = &#x27;page&#x27;  # 定制取数据页码key ？    page_size_query_param = &#x27;page_size&#x27;  # 默认取数据页码key &amp;    max_page_size = 15  # 数据每页取值的最大上限\n\n32、第三方库安装openssl pip3 install pyOpenSSL\n\n33、requests请求https携带CA证书import OpenSSLimport requestsimport urllib3.contrib.pyopensslurllib3.contrib.pyopenssl.inject_into_urllib3()def p12_to_pem(certname, pwd):    &quot;&quot;&quot;    从.p12文件中提取pem    :param certname:    :param pwd:    :return:    &quot;&quot;&quot;    pem_name = certname + &quot;.pem&quot;    f_pem = open(pem_name, &#x27;wb&#x27;)    p12file = certname + &quot;.p12&quot;    p12 = OpenSSL.crypto.load_pkcs12(open(p12file, &#x27;rb&#x27;).read(), pwd)    f_pem.write(OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, p12.get_privatekey()))    f_pem.write(OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, p12.get_certificate()))    ca = p12.get_ca_certificates()    if ca is not None:        for cert in ca:            f_pem.write(OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert))    f_pem.close()    return pem_namedef post_cert_request(url, data,header, certname, pwd):    &quot;&quot;&quot;    使用证书发起https请求    :param url:    :param data:    :param certname:    :param pwd:    :return:    &quot;&quot;&quot;    if (certname != &quot;&quot;):        cert = p12_to_pem(certname, pwd)    else:        cert = None    r = requests.post(url, header=header, data=data, cert=cert)    return r\n\n34、django创建缓存命令python manage.py createcachetable 缓存表名\n\n35、Django 更改超级用户密码在工程文件目录下敲入：python manage.py shell再在python交互界面输入：from django.contrib.auth.models import Useruser = User.objects.get(username = &#x27;用户名&#x27;)user.set_password(&#x27;密码&#x27;)user.save()\n\n36、restframe使用缓存https://blog.csdn.net/Odyssues_lee/article/details/80872586\n37、数据库select * from user  where ISNULL(code)update user set code=&#x27;111&#x27;,info=&#x27;微信&#x27; where ISNULL(code)\n\n38、linux常用命令tail -f 日志名  实时监控日志tail -f 80_v10.lognetstat -na|grep 80  查看端口tcp连接数netstat -na|grep 80 | wc -l 计算端口tcp连接数ps -ef|grep python  查看有多少python程序在运行gunzip 2015.csv.gz   # 解压unzip 19.zip # 解压zipwc -l 2015.csv   # 查看行数apt install lrzsz  # 安装sz 文件名  # 下载文件查找文件find / -name 文件名匹配执行过的以find为开头的命令history | grep find\n\n39、xadmin禁止增加、删除# models.py# 用户管理class UserManage(models.Model):    name = models.CharField(max_length=20, verbose_name=&#x27;用户名&#x27;)    phone = models.CharField(max_length=11, unique=True, verbose_name=&#x27;手机号&#x27;)    code = models.CharField(max_length=11, unique=True, verbose_name=&#x27;编号&#x27;)        user = models.ForeignKey(User, on_delete=models.CASCADE, editable=False, null=True, verbose_name=&#x27;管理员&#x27;)# adminx.py# 用户列表class UserAdmin(object):    list_display = [ &#x27;code&#x27;, &#x27;phone&#x27;, &#x27;name&#x27;,]    search_fields = [&#x27;code&#x27;, &#x27;phone&#x27;]    list_filter = [&#x27;code&#x27;, &#x27;phone&#x27;]    list_editable = [&#x27;name&#x27;]  # 数据即时编辑    readonly_fields = [&#x27;code&#x27;, &#x27;phone&#x27;, &#x27;name&#x27;]  # 只读字段，不能编辑    model_icon = &#x27;fa fa-square&#x27;    model = UserInfo        def has_delete_permission(self, *args, **kwargs):    \t# 禁止删除        if args:            return True        return False    \tdef has_add_permission(self,*args,**kwargs):\t\t# 禁止增加        return False            def save_models(self):    \t# 用户级别设置        self.new_obj.user = self.request.user        flag = self.org_obj is None and &#x27;create&#x27; or &#x27;change&#x27;        if flag == &#x27;create&#x27;:        \t# 对密码字段进行加密            self.new_obj.password = encrypt_oracle(self.new_obj.password)        elif flag == &#x27;change&#x27;:            if &#x27;password&#x27; in self.change_message():                self.new_obj.password = encrypt_oracle(self.new_obj.password)        else:        \tpass        super().save_models()xadmin.site.register(UserInfo, UserAdmin)\n\n40、时间格式字符串相减import datetimeimport timestart = str(datetime.datetime.now())[:19]time.sleep(60)end = str(datetime.datetime.now())[:19]print(start,end)link_start = datetime.datetime.strptime(start, &#x27;%Y-%m-%d %H:%M:%S&#x27;)link_end = datetime.datetime.strptime(end, &#x27;%Y-%m-%d %H:%M:%S&#x27;)link_min = round((link_end - link_start).seconds / 60, 2)print(link_min,&#x27;分钟&#x27;)\n\n41、显示循环进度条参考：https://blog.csdn.net/zejianli/article/details/77915751\nfrom tqdm import tqdm,trangefrom time import sleeptext = &quot;&quot;for char in tqdm([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]):    text = text + char    sleep(1)        # 方式二import timedef process_bar(percent, index, total,start_time, start_str=&#x27;&#x27;, end_str=&#x27;&#x27;, total_length=100):    # 进度条    percent_length = int(percent)    bar = &#x27;\\r&#x27; + start_str + (&#x27;\\033[1;31;41m \\033[0m&#x27; * percent_length + &#x27;\\033[1;37;47m \\033[0m&#x27; * (                total_length - percent_length)) + f&#x27;  &#123;round(index / total * 100, 2)&#125;%  &#x27; + f&#x27; &#123;index&#125;|&#123;end_str&#125;&#x27;+ f&#x27;   |已进行时间: &#123;round(time.time() - start_time, 2)&#125;秒&#x27;    print(bar, end=&#x27;&#x27;, flush=True)if __name__ == &#x27;__main__&#x27;:    data_set = [i for i in range(23)]    i = 0    start_time = time.time()    total = len(data_set)    end_str = &#x27;&#123;&#125;&#x27;.format(total)    for data in data_set:        time.sleep(1)        i += 1        process_bar(i * 100 / total, i, total, start_time, start_str=&#x27;&#x27;, end_str=end_str, total_length=100)# 方式三import sysimport timed = [i for i in range(100)]for i in range(len(d)):    time.sleep(1)    sys.stdout.write(&#x27;\\r&gt;&gt; Downloading  %.2f%%&#x27; % (float(i) / float(len(d)) * 100.0))sys.stdout.flush()\n\n42、把列表中的字典转成csv文件import pandas as pdlists = [&#123;&#x27;a&#x27;:1,&#x27;b&#x27;:2&#125;,&#123;&#x27;a&#x27;:2,&#x27;b&#x27;:3&#125;]df = pd.DataFrame(lists)print(df)df.to_csv(&#x27;result2.csv&#x27;)\n\n43、windows添加右键新建MarkDown文件在网上下载Typora软件安装后1、在桌面上新建一个txt文件，输入以下内容：\nWindows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\.md\\ShellNew]&quot;NullFile&quot;=&quot;&quot;&quot;FileName&quot;=&quot;template.md&quot;\n\n2、另存为，改后缀为.reg，保存类型为.txt，编码为Unicode\n\n3、双击运行，确定，重启电脑，此时在桌面右键就有了新建md文件\n44、redis设置值定时过期import datetimeimport redisredis_client = redis.Redis(    host=&#x27;127.0.0.1&#x27;,    port=6379,    db=0,    password=&#x27;123456&#x27;)def redis_set():    &quot;&quot;&quot;    redis设置值定时过期    :return:    &quot;&quot;&quot;    global redis_client    redis_client.set(&#x27;name&#x27;,&#x27;ldc&#x27;)    now = datetime.datetime.now()    # 设置‘name’50秒过期    expire_time = now + datetime.timedelta(hours=0, minutes=0, seconds=50)    redis_client.expireat(&#x27;name&#x27;, expire_time)if __name__ == &#x27;__main__&#x27;:    redis_set()\n\n45、linux根据端口杀进程import osdef killport(port):    command = &#x27;&#x27;&#x27;kill -9 $(netstat -nlp | grep :&#x27;&#x27;&#x27; + str(port) + &#x27;&#x27;&#x27; | awk &#x27;&#123;print $7&#125;&#x27; | awk -F&quot;/&quot; &#x27;&#123; print $1 &#125;&#x27;)&#x27;&#x27;&#x27;    os.system(command)# 开始执行if __name__ == &#x27;__main__&#x27;:    port = 4237    killport(port)\n\n46、监控linux网络流量iftop -n -N -i eth0nethogs eth0vim +/字符串 文件\n\n47、win10添加右键打开cmd通过添加注册表项实现\nwin + r 输入 regedit\n找到注册表位置：HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\\n右键“shel”l,新建“项”，命名为“以管理员身份打开cmd”，\n右键“以管理员身份打开cmd”，新建“DWORD(32位)值”，命名为”ShowBasedOnVelocityId”,值为“639bc8”\n右键“以管理员身份打开cmd”，新建“项”，命名为“command”\n右键“command”，点击“默认”，点击“修改”，填写数值为 cmd.exe &#x2F;s &#x2F;k pushd “%V”\n48、xadmin后台无法显示下拉框完整内容解决方案 在根目录中找到&#x2F;static&#x2F;xadmin&#x2F;vendor&#x2F;selectize&#x2F;selectize.bootstrap3.css在331行后加入 position: static;\n\n49、xadmin单点登录使用中间件实现。\n新建一个utils.py文件，存放以下代码：\nfrom django.contrib.sessions.models import Sessionfrom django.db.models import Qfrom django.utils import timezonefrom django.utils.deprecation import MiddlewareMixinclass XadminMiddleware(MiddlewareMixin):    def process_request(self, request):        &quot;&quot;&quot;xadmin后台单点登录&quot;&quot;&quot;        PATH_INFO = request.META.get(&#x27;PATH_INFO&#x27;, &#x27;&#x27;)        if PATH_INFO and &#x27;xadmin&#x27; in PATH_INFO:            request.session.clear_expired()   # 清除过期的key            session_key = request.session.session_key            for session in Session.objects.filter(~Q(session_key=session_key), expire_date__gte=timezone.now()):                data = session.get_decoded()                if data.get(&#x27;_auth_user_id&#x27;, None) == str(request.user.id):                    session.delete()\n\n然后在urls.py中设置：\nurlpatterns = [...re_path(&#x27;^xadmin/&#x27;, xadmin.site.urls),...]\n\n然后在settings.py中注册中间件\n   MIDDLEWARE = [   ...      &#x27;utils.xadminauth.XadminMiddleware&#x27;,   ...   ]SESSION_COOKIE_AGE = 1209600  # 设置过期时间   SESSION_SAVE_EVERY_REQUEST = Ture  # 每次请求都更新\n\n【参考】 https://blog.csdn.net/Python_anning\n50、Django restful 多个models数据表序列化合并返回（一次请求返回多个序列化器数据）# 导入第三方包pip install django-crispy-forms==1.7.2# 在settings.py中添加应用INSTALLED_APPS = [...&#x27;drf_multiple_model&#x27;,&#x27;rest_framework&#x27;,...]# 在views.py中使用    from drf_multiple_model.pagination import MultipleModelLimitOffsetPagination    from drf_multiple_model.views import ObjectMultipleModelAPIView            class LimitPagination(MultipleModelLimitOffsetPagination):        # 多个models数据表联合查询，分页，每页限制数据10条        default_limit = 10            class StudentSerializers(serializers.ModelSerializer):        &quot;&quot;&quot;学生表序列化器&quot;&quot;&quot;        # merchant = MerchantSerializers()                register_time = serializers.DateTimeField(read_only=True, format=&quot;%Y-%m-%d %H:%M:%S&quot;)               class Meta:            model = Student            fields = &#x27;__all__&#x27;    class ClassesSerializers(serializers.ModelSerializer):        &quot;&quot;&quot;班级表序列化器&quot;&quot;&quot;        # merchant = MerchantSerializers()                add_time = serializers.DateTimeField(read_only=True, format=&quot;%Y-%m-%d %H:%M:%S&quot;)               class Meta:            model = Classes            fields = &#x27;__all__&#x27;        class SchoolSerializers(serializers.ModelSerializer):        &quot;&quot;&quot;学校表序列化器&quot;&quot;&quot;        # merchant = MerchantSerializers()                add_time = serializers.DateTimeField(read_only=True, format=&quot;%Y-%m-%d %H:%M:%S&quot;)               class Meta:            model = School            fields = &#x27;__all__&#x27;                          class StudentInfo(ObjectMultipleModelAPIView):        # 获取学生信息，班级信息，学校信息            def get(self, request, *args, **kwargs):            uid = request.GET.get(&#x27;uid&#x27;, &#x27;&#x27;)  # 学生id            cid = request.GET.get(&#x27;cid&#x27;, &#x27;&#x27;)  # 班级id            sid = request.GET.get(&#x27;sid&#x27;, &#x27;&#x27;)  # 学校id                        self.querylist = [                &#123;&#x27;queryset&#x27;: Student.objects.filter(id=uid).order_by(&#x27;-id&#x27;),                    &#x27;serializer_class&#x27;:  StudentSerializers, &#x27;label&#x27;: &#x27;student&#x27;, &#125;,                &#123;&#x27;queryset&#x27;: Classes.objects.filter(id=cid).order_by(&#x27;-id&#x27;),                    &#x27;serializer_class&#x27;:  ClassesSerializers, &#x27;label&#x27;: &#x27;classes&#x27;, &#125;,                &#123;&#x27;queryset&#x27;: School.objects.filter(id=sid).order_by(&#x27;-id&#x27;),                    &#x27;serializer_class&#x27;:  SchoolSerializers, &#x27;label&#x27;: &#x27;school&#x27;, &#125;,            ]                return self.list(request, *args, **kwargs)            pagination_class = LimitPagination\n\n51、 Django序列化器返回外键关联数据通过 related_name&#x3D;’goods_price’把两个表关联起来，当返回Goods的信息时也会返回相应的GoodsPrice信息\nclass GoodsPriceSerializers(serializers.ModelSerializer):    &quot;&quot;&quot;商品价格表序列化器&quot;&quot;&quot;        class Meta:        model = GoodsPrice        fields = [&#x27;price&#x27;]class GoodsSerializers(serializers.ModelSerializer):    &quot;&quot;&quot;商品表序列化器&quot;&quot;&quot;        goods_price = GoodsPriceSerializers(many=True, read_only=True)    class Meta:        model = Goods        fields = [&#x27;title&#x27;,&#x27;goods_price&#x27;]        depth = 2class Goods(models.Model):    &quot;&quot;&quot;商品表&quot;&quot;&quot;    title = models.CharField(max_length=50, verbose_name=&#x27;商品名称&#x27;)    class Meta:        db_table = &#x27;goods&#x27;        verbose_name = &#x27;商品信息表&#x27;        verbose_name_plural = verbose_name    def __str__(self):        return self.titleclass GoodsPrice(models.Model):    &quot;&quot;&quot;商品价格表,通过外键关联商品信息表&quot;&quot;&quot;    price = models.DecimalField(max_digits=10, decimal_places=2, default=0, verbose_name=&#x27;售价&#x27;)    goods = models.ForeignKey(to=&#x27;Goods&#x27;, related_name=&#x27;goods_price&#x27;, on_delete=models.SET_NULL, blank=True, null=True,verbose_name=&#x27;商品&#x27;)    def __str__(self):        return str(self.price)    class Meta:        managed = True        db_table = &#x27;goodsPrice&#x27;        verbose_name = &#x27;商品售价&#x27;        verbose_name_plural = verbose_name\n\n52、python Django通过User Agent判断请求来源是微信扫一扫或者是支付宝扫一扫class Footest(APIView): def get(self, request, *args, **kwargs):     # print(request.META)     if &#x27;MicroMessenger&#x27; in request.META[&#x27;HTTP_USER_AGENT&#x27;]:         return Response(data=&#123;&#x27;msg&#x27;: &#x27;访问来源是微信&#x27;&#125;)     elif &#x27;AlipayClient&#x27; in request.META[&#x27;HTTP_USER_AGENT&#x27;]:         return Response(data=&#123;&#x27;msg&#x27;: &#x27;访问来源是支付宝&#x27;&#125;)     else:         return Response(data=&#123;&#x27;msg&#x27;: &#x27;访问来源是其他&#x27;&#125;)\n\nUser Agent中文名为用户代理，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。\n浏览器的 UA 字串\n标准格式为： 浏览器标识 (操作系统标识; 加密等级标识; 浏览器语言) 渲染引擎标识 版本信息\n获取user-Agent 之后，通过识别MicroMessenger或者AlipayClient这样的关键字应该就可以判断是微信还是支付宝【参考文章】 https://blog.csdn.net/fly910905/article/details/82498813?utm_source=blogxgwz4\n53、xadmin后台集成’导入‘插件，导入excel文件效果图：\n\n1、添加\n在虚拟环境根目录\\Lib\\site-packages\\xadmin\\plugins中添加excel.py文件\n\nfrom xadmin.views import BaseAdminPlugin, ListAdminView\nfrom django.template import loader\nimport xadmin\n\nclass ListExcelImportPlugin(BaseAdminPlugin):\n    # 重写init_request\n    import_excel = False\n    def init_request(self, *args, **kwargs):\n        return self.import_excel\n\n    def block_top_toolbar(self, context, nodes):\n        # 这里 xadmin/excel/model_list.top_toolbar.import.html 是自己写的html文件\n      nodes.append(loader.render_to_string(&quot;xadmin/excel/model_list.top_toolbar.import.html&quot;))\n\nxadmin.site.register_plugin(ListExcelImportPlugin, ListAdminView)\n\n在虚拟环境根目录\\Lib\\site-packages\\xadmin\\plugins__init__.py中\nPLUGINS = (\n...\n    &#39;excel&#39;,\n...\n)\n\n2、添加html文件\n\n在虚拟环境根目录\\Lib\\site-packages\\xadmin\\templates\\xadmin\\中增加文件夹excel,在文件夹中添加model_list.top_toolbar.import.html文件\n    &#123;% load i18n %&#125;\n&lt;div class=&quot;btn-group export&quot;&gt;\n    &lt;a class=&quot;dropdown-toggle btn btn-default btn-sm&quot; data-toggle=&quot;dropdown&quot; href=&quot;#&quot;&gt;\n        &lt;i class=&quot;icon-share&quot;&gt;&lt;/i&gt; 导入数据 &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;\n    &lt;/a&gt;\n    &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;dLabel&quot;&gt;\n        &lt;li&gt;&lt;a data-toggle=&quot;modal&quot; data-target=&quot;#export-modal-import-excel&quot;&gt;&lt;i class=&quot;icon-circle-arrow-down&quot;&gt;&lt;/i&gt; 导入\n            Excel&lt;/a&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n\n    &lt;div id=&quot;export-modal-import-excel&quot; class=&quot;modal fade&quot;&gt;\n        &lt;div class=&quot;modal-dialog&quot;&gt;\n            &lt;div class=&quot;modal-content&quot;&gt;\n                &lt;form method=&quot;post&quot; action=&quot;&quot; enctype=&quot;multipart/form-data&quot;&gt;\n                    &lt;!--&#123;% csrf_token %&#125;--&gt;\n                    &lt;div class=&quot;modal-header&quot;&gt;\n                        &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-hidden=&quot;true&quot;&gt;×&lt;/button&gt;\n                        &lt;h4 class=&quot;modal-title&quot;&gt;导入 Excel&lt;/h4&gt;\n                    &lt;/div&gt;\n                    &lt;div class=&quot;modal-body&quot;&gt;\n                        &lt;input type=&quot;file&quot; onchange=&quot;fileChange(this)&quot; name=&quot;excel&quot; id=&quot;submit_upload&quot;&gt;\n                    &lt;/div&gt;\n                    &lt;div class=&quot;modal-footer&quot;&gt;\n                        &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;&#123;% trans \"Close\" %&#125;&lt;/button&gt;\n                        &lt;button class=&quot;btn btn-success&quot; type=&quot;button&quot; id=&quot;submit_upload_b&quot;&gt;&lt;i class=&quot;icon-share&quot;&gt;&lt;/i&gt; 导入\n                        &lt;/button&gt;\n                    &lt;/div&gt;\n                &lt;/form&gt;\n            &lt;/div&gt;&lt;!-- /.modal-content --&gt;\n        &lt;/div&gt;&lt;!-- /.modal-dalog --&gt;\n    &lt;/div&gt;&lt;!-- /.modal --&gt;\n\n&lt;/div&gt;\n\n&lt;script type=&quot;text/javascript&quot;&gt;\n    function fileChange(target) &#123;\n        //检测上传文件的类型\n        var imgName = document.all.submit_upload.value;\n        var ext, idx;\n        if (imgName == &#39;&#39;) &#123;\n            document.all.submit_upload_b.disabled = true;\n            alert(&quot;请选择需要上传的 xls 文件!&quot;);\n            return;\n        &#125; else &#123;\n            idx = imgName.lastIndexOf(&quot;.&quot;);\n            if (idx != -1) &#123;\n                ext = imgName.substr(idx + 1).toUpperCase();\n                ext = ext.toLowerCase();\n\n                if (ext != &#39;xls&#39; &amp;&amp; ext != &#39;xlsx&#39;) &#123;\n                    document.all.submit_upload_b.disabled = true;\n                    alert(&quot;只能上传 .xls 类型的文件!&quot;);\n                    return;\n                &#125;\n            &#125; else &#123;\n                document.all.submit_upload_b.disabled = true;\n                alert(&quot;只能上传 .xls 类型的文件!&quot;);\n                return;\n            &#125;\n        &#125;\n    &#125;\n\n    $(document).ready(function () &#123;\n\n        $(&#39;#submit_upload_b&#39;).click(function () &#123;\n            var form_data = new FormData();\n            var file_info = $(&#39;#submit_upload&#39;)[0].files[0];\n            form_data.append(&#39;file&#39;, file_info);\n            form_data.append(&#39;file_source&#39;, $(&#39;.breadcrumb li&#39;).eq(1).text().trim());\n            var url = window.location.protocol + &#39;//&#39; + window.location.host + &#39;/importkdorderno/&#39;\n            $.ajax(&#123;\n                url: url,\n                type: &#39;POST&#39;,\n                data: form_data,\n                dataType: &quot;json&quot;,\n                beforeSend: function (xhr) &#123;\n                    xhr.setRequestHeader(&quot;X-CSRFToken&quot;, $.getCookie(&quot;csrftoken&quot;))\n                &#125;,\n                processData: false,  // tell jquery not to process the data\n                contentType: false, // tell jquery not to set contentType\n                success: function (res) &#123;\n\n                    alert(res.msg);\n                    window.location.reload();\n                &#125;,\n                error: function (err) &#123;\n                &#125;\n            &#125;);\n        &#125;);\n    &#125;)\n&lt;/script&gt;\n\n​3、在views.py处理上传的excel文件\nimport pandas as pd\nfrom rest_framework.views import APIView\n\nclass ImportKDOrderNo(APIView):\n\n    def post(self, request, *args, **kwargs):\n        file = request.FILES.get(&#39;file&#39;)\n        # read = InMemoryUploadedFile().open()\n        data = pd.read_excel(file)  # 使用pandas处理excel文件\n\t\tfile_source = request.POST.get(&#39;file_source&#39;, &#39;&#39;)  # 文件来源\n\t\t\n        if &#39;订单号&#39; and &#39;物流单号&#39; not in data:\n            return Response(data=&#123;&#39;msg&#39;: &#39;文件格式有误，第一行第一列应该为【订单号】，第一行第二列应该为【物流单号】&#39;&#125;)\n        ordernos = data[&#39;订单号&#39;]\n        logistics = data[&#39;物流单号&#39;]\n        for i in range(len(ordernos)):\n            print(&#39;订单号&#39;, ordernos[i], &#39;物流单号&#39;, logistics[i])\n          \n        return Response(data=&#123;&#39;msg&#39;: &#39;上传成功&#39;&#125;)\n\n4、在urls.py中添加访问路由\nfrom django.urls import pathfrom 你的应用名称 import viewsapp_name = &#x27;你的应用名称&#x27;urlpatterns = [    # 其他路由    ...    # 导入物流单号    path(&#x27;importkdorderno/&#x27;, views.ImportKDOrderNo.as_view(), name=&#x27;importkdorderno&#x27;),]\n\n54、Django中查找今天进账金额views.py\nfrom datetime import datetime\nclass CountFee(APIView):\n\tdef get(self, request, *args, **kwargs):\n\t\t# 获取当前时间的年月日，然后使用聚合函数添加fee字段的值\n    \tyear = datetime.now().year\n        month = datetime.now().month\n        day = datetime.now().day\n        count_fees = FeeDetail.objects.filter(addtime__year=year, addtime__month=month, addtime__day=day).aggregate(Sum(&#39;fee&#39;))\n        all_fee = count_fees[&#39;fee__sum&#39;] if count_fees[&#39;fee__sum&#39;] else 0\n        print(all_fee)\n        return Response(&#123;&#39;code&#39;: 1, &#39;msg&#39;: &#39;success&#39;, &#39;data&#39;: &#123;&#39;all_fee&#39;: all_fee&#125;&#125;)\n\n55、判断是什么系统import platformPlATFORM = platform.system()if PlATFORM == &quot;Linux&quot;:    print(&#x27;linux&#x27;)else:    print(&#x27;其他&#x27;) \n\n56、sql查询# 联合更新update malluser set master_master_id=3 where master_id in (select a.id from (select id from  malluser where id like &#x27;15%&#x27;)a) # 统计某字段重复数据SELECT phone, COUNT(*) AS sumCount FROM malluser GROUP BY phone HAVING sumCount &gt; 1;\n\n57、 xadmin后台删除数据出现错误`get_deleted_objects() takes 3 positional arguments but 5 were given`\n\n这是由于Django2.1版本和xadmin不兼容导致的\n知道虚拟环境\\Lib\\site-packages\\xadmin\\plugins\\actions.py\n修改93行，\n把\ndeletable_objects, model_count, perms_needed, protected = get_deleted_objects(\n            queryset, self.opts, self.user, self.admin_site, using)\n\n改为\ndeletable_objects, model_count, perms_needed, protected = get_deleted_objects(\n            queryset, self.user, self.admin_site)\n\n然后在adminx.py文件中对应的模型类中允许删除\nclass MaterialAdmin(object):\n    &quot;&quot;&quot;素材库分类&quot;&quot;&quot;\n    list_display = [&#39;id&#39;, &#39;name&#39;, &#39;class_id&#39;, &#39;is_delete&#39;, &#39;addtime&#39;]\n  \n    def has_delete_permission(self, *args, **kwargs):\n        return True\n\n58、xdamin限制用户点击//如果登录z=xadmin后台的账号不是【root】的就不能点击更新操作    var master_name = $(&#x27;#top-nav&#x27;).find(&#x27;strong&#x27;).text();        master_name =  master_name.substring(4);    if(master_name != &#x27;root&#x27;)&#123;            $(&quot;.grid-item a&quot;).each(function(index, element) &#123;                $(this).attr(&#x27;href&#x27;,&#x27;#&#x27;);            &#125;);        &#125;\n\n59、获取公众号关注url在微信网页版，打开公众号，点击右上角“…”，在弹框中选择右下角中间的“查看历史记录”，然后在弹框中选择左上角倒数第一个，“用默认浏览器打开”，就可以在打开的浏览器中获取该公众号的关注url，当把这个url发给好友时，好友点开的就是去关注公众号的页面。\n60、xadmin后台用户操作表权限虚拟环境根目录\\Lib\\site-packages\\xadmin\\views\\base.py\n可以找到：\n\n在项目子应用下的adminx.py中使用\nimport xadminfrom machine.models import Machineclass MachineAdmin(object):    list_display = [&#x27;code&#x27;,]  # 显示的字段    search_fields = [&#x27;code&#x27;]  # 搜索的字段    list_filter = [&#x27;code&#x27;, &#x27;is_delete&#x27;] # 过滤的字段    ordering = (&#x27;-id&#x27;,) # 按id降序排序    list_editable = [&#x27;is_delete&#x27;, ]  # 数据即时编辑    list_per_page = 30  # 每页显示数据数量    model_icon = &#x27;fa fa-cog fa-spin&#x27;  # 左侧显示的小图标    def has_delete_permission(self, *args, **kwargs):         # 删除权限        if self.request.user.is_superuser:  # 管理员才能增加            return True        return False    def has_add_permission(self, *args, **kwargs):        if self.request.user.is_superuser:  # 管理员才能增加            return True        return False    def has_change_permission(self, *args, **kwargs):        if self.request.user.is_superuser: # 管理员才能修改            return True        return False    def queryset(self):        qs = super(MachineAdmin, self).queryset()        if self.request.user.is_superuser:  # 管理员可以查看所有            return qs        else:            # 登录用户只能看到自己修改的数据            return qs.filter(master_id=self.request.user.last_name)xadmin.site.register(MallMachine, MallMachineAdmin)\n\n61、使用nginx部署项目先在&#x2F;etc&#x2F;nginx&#x2F;sites-available中创建一个配置文件，文件名为test(注意没有后缀):\n#设定虚拟主机配置    server &#123;        #侦听80端口        listen 80;        listen 443 ssl;        #定义使用 www.nginx.cn访问\t\t#ssl on;        server_name  xxx.xxx.com;        #定义服务器的默认网站根目录位置        root /root/项目名称;\t\tssl_session_timeout 5m;         ssl_certificate   /etc/nginx/cert/xxx.pem;        ssl_certificate_key  /etc/nginx/cert/xxx.key;        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;        ssl_prefer_server_ciphers on;        #设定本虚拟主机的访问日志        #access_log  logs/nginx.access.log  main;         #默认请求        location / &#123;            #倒入了uwsgi的配置            include uwsgi_params; \t\t    client_max_body_size\t50m;            #连接uwsgi的超时时间           # uwsgi_connect_timeout 30;  \t    #设定了uwsig服务器位置 \t    \tuwsgi_pass 127.0.0.1:8002;        &#125;                location /static&#123;      \talias /root/项目名称/static;        &#125;\tlocation /media &#123;\talias /root/项目名称/media;\t&#125; &#125;\n\n其中xxx.xxx.com表示域名.如果没有https，就使用#把ssl注释掉就可以了。\n然后把test映射到&#x2F;etc&#x2F;nginx&#x2F;sites-enabled\n命令\nln -s /etc/nginx/sites-available/test /etc/nginx/sites-enabled/test\n\n即可注意：uwsgi中配置listen&#x3D;1024时，启动uwsgi时可能会报错：\ndjango + uwsgi + nginx 日志Listen queue size is greater than the system max net.core.somaxconn (128).\n\n解决方法:\n修改系统参数/proc/sys/net/ipv4/tcp_max_syn_backlog  原来2048    改为8192/proc/sys/net/core/somaxconn\t原来128     改为262144\n\n重启nginx\nnginx -s reload\n\n62、xadmin后台发送邮件找回密码\n输入你用户绑定的邮箱\n\n想要发送邮件，需要在settings.py中设置邮件发送器\nsettings.py最下面增加\n# ------------------------邮箱配置-----------------------------------------EMAIL_BACKEND = &#x27;django.core.mail.backends.smtp.EmailBackend&#x27; #把要发送的邮件显示再控制台上，方便调试EMAIL_USE_SSL = TrueEMAIL_HOST = &#x27;smtp.qq.com&#x27;  # 如果是 163 改成 smtp.163.comEMAIL_PORT = 465EMAIL_HOST_USER = &#x27;邮箱账号&#x27; # 帐号EMAIL_HOST_PASSWORD = &#x27;授权码&#x27;  # 到邮箱里开通DEFAULT_FROM_EMAIL = EMAIL_HOST_USER\n\n由于django2与xadmin有些地方不兼容，需要修改源码：\n找到虚拟环境根目录\\Lib\\site-packages\\xadmin\\plugins\\passwords.py\n在passwords.py文件中大概79行，修改为\nreturn password_reset_confirm(request=request, uidb36=uidb36, token=token,                                      template_name=self.password_reset_confirm_template,                                      token_generator=self.password_reset_token_generator,                                      set_password_form=self.password_reset_set_form,                                      post_reset_redirect=self.get_admin_url(&#x27;xadmin_password_reset_complete&#x27;),                                      current_app=self.admin_site.name, extra_context=context).dispatch(request=request,                                                                                                        uidb64=uidb36,token=token)             \n\n找到虚拟环境根目录Lib\\site-packages\\django\\contrib\\auth\\views.py\n在views.py文件中大概258行，增加：\n# 成功后跳转路由,根据自己实际来定self.success_url = self.request.build_absolute_uri(&#x27;/&#x27;) + &#x27;xadmin/&#x27;\n\n\n63、xadmin外键下拉框添加过滤class MallGoodsAdmin(object):    &quot;&quot;&quot;商品管理&quot;&quot;&quot;    list_display = [&#x27;id&#x27;, &#x27;show_photo&#x27;, &#x27;nickname&#x27;, &#x27;merchant&#x27;, &#x27;goods_class&#x27;, &#x27;label&#x27;,]    search_fields = [&#x27;nickname&#x27;]    list_filter = [&#x27;goods_class&#x27;, &#x27;label&#x27;,]    model_icon = &#x27;fa fa-bars&#x27;    list_editable = [&#x27;goods_class&#x27;, ]    #,重写虚拟环境根目录下\\Lib\\site-packages\\xadmin\\views\\edit.py中的formfield_for_dbfield    def formfield_for_dbfield(self, db_field, **kwargs):        # 对MallGoodsClass这个表项的下拉框选择进行过滤        # MallGoods中有一个goods_class商品分类外键MallGoodsClass，过滤掉外键MallGoodsClass中         # master_class为空的值        if db_field.name == &quot;goods_class&quot;:            kwargs[&quot;queryset&quot;] = MallGoodsClass.objects.filter(master_class__isnull=False)            # 对assigned_recipient这个表项的下拉选择进行过滤        \treturn db_field.formfield(**dict(**kwargs))        return super().formfield_for_dbfield(db_field, **kwargs)xadmin.site.register(models.MallGoods, MallGoodsAdmin)\n\n64、xadmin即时编辑器去掉空标签\n虚拟环境根目录下\\Lib\\site-packages\\xadmin\\plugins\\editable.py，在大概\n129行增加：\nform.fields[fields[0]].empty_label = None\n\n\n65、用户增加的小组件，让其他用户可见找到虚拟环境根目录\\Lib\\site-packages\\xadmin\\views\\dashboard.py\n在548行、554行\n\n改为：\n@filter_hook    def get_widgets(self):        if self.widget_customiz:            portal_pos = UserSettings.objects.filter(               key=self.get_portal_key())            if len(portal_pos):                portal_pos = portal_pos[0].value                widgets = []                if portal_pos:                    user_widgets = dict([(uw.id, uw) for uw in UserWidget.objects.filter(page_id=self.get_page_id())])                    for col in portal_pos.split(&#x27;|&#x27;):                        ws = []                        for wid in col.split(&#x27;,&#x27;):                            try:                                widget = user_widgets.get(int(wid))                                if widget:                                    ws.append(self.get_widget(widget))                            except Exception as e:                                import logging                                logging.error(e, exc_info=True)                        widgets.append(ws)                return widgets        return self.get_init_widget()\n\n66、pip install uwsgi出错plugins/python/uwsgi_python.h:2:20: fatal error: Python.h: No such file or directory\n\n首先安装python3环境\napt install python3-dev\n\n然后再虚拟环境中\npip install uwsgi\n\n66、xadmin后台加载数据慢，解决方案list_filter: 过滤器要慎用，不要使用类似id这些数据量大的字段\nclass MallUserAdmin(object):    &quot;&quot;&quot;用户管理&quot;&quot;&quot;    list_display = [&#x27;id&#x27;, &#x27;tp_icon&#x27;, &#x27;nickname&#x27;, &#x27;phone&#x27;, &#x27;level&#x27;, &#x27;balance&#x27;, &#x27;province&#x27;, &#x27;city&#x27;, &#x27;quxian&#x27;]  # 显示字段    search_fields = [&#x27;id&#x27;, &#x27;nickname&#x27;, &#x27;phone&#x27;]  # 搜索    list_filter = [&#x27;level&#x27;, &#x27;province&#x27;, &#x27;city&#x27;, &#x27;quxian&#x27;]  # 过滤器    # list_filter = [&#x27;id&#x27;, &#x27;level&#x27;, &#x27;province&#x27;, &#x27;city&#x27;, &#x27;quxian&#x27;]  # 如果加id，xadmin加载回来的数据就会很慢，所以不要在过滤器上使用id    list_per_page = 30  # 默认每页数量    model_icon = &#x27;fa fa-users&#x27;  # 左侧图标    ordering = [&#x27;-id&#x27;]  # 排序    readonly_fields = [&#x27;subscribe&#x27;, &#x27;wx_openid&#x27;, &#x27;phone&#x27;]  # 只读字段    is_addbalance = True   # 加载自定义的插件    relfield_style = &#x27;fk-ajax&#x27;  # 其他表如果外键到用户表就做ajax搜索查询，不一次性加载数据\n\n67 、xadmin导出插件处理，增加导出勾选数据项常规的导出只有两个选择【导出表头】、【导出全部数据】\n\n现在想要做的是增加一个选择，即【导出表头】、【导出全部数据】、【导出勾选数据】，如下图：\n\n需要修改xadmin源代码，具体如下\n1、加载js文件找到虚拟环境\\Lib\\site-packages\\xadmin\\views\\list.py，在607行增加’xadmin.plugin.importexport.js’，如下图所示\n\n2、修改export.py，后端处理下载文件找到虚拟环境\\Lib\\site-packages\\xadmin\\plugins\\export.py\n在84行把rows &#x3D; context[‘results’]修改成如下函数\n# 新增导出所选数据# rows = context[&#x27;results&#x27;]  rows = []select_across = self.request.GET.get(&#x27;_select_across&#x27;, False) == &#x27;1&#x27;selected = self.request.GET.get(&#x27;_selected_actions&#x27;, &#x27;&#x27;)if self.request.GET.get(&#x27;selected&#x27;, &#x27;off&#x27;) == &#x27;on&#x27;:    if not select_across:        selected_pk = selected.split(&#x27;,&#x27;)        for i in context[&#x27;results&#x27;]:            if str(i[&#x27;object&#x27;].id) in selected_pk:                rows.append(i)    else:        rows = context[&#x27;results&#x27;]else:    rows = context[&#x27;results&#x27;]\n\n\n3、 修改model_list.top_toolbar.exports.html找到虚拟环境\\Lib\\site-packages\\xadmin\\templates\\xadmin\\blocks\\model_list.top_toolbar.exports.html\n使用以下代码覆盖原文件\n&#123;% load i18n %&#125;&lt;div class=&quot;btn-group export&quot;&gt;    &lt;a id=&quot;export-menu&quot; class=&quot;dropdown-toggle btn btn-default btn-sm&quot; data-toggle=&quot;dropdown&quot; href=&quot;#&quot;&gt;        &lt;i class=&quot;fa fa-share&quot;&gt;&lt;/i&gt; &#123;% trans &quot;Export&quot; %&#125; &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;    &lt;/a&gt;    &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;dLabel&quot;&gt;        &#123;% for et in export_types %&#125;        &lt;li&gt;&lt;a data-toggle=&quot;modal&quot; data-target=&quot;#export-modal-&#123;&#123;et.type&#125;&#125;&quot;&gt;&lt;i class=&quot;fa fa-arrow-circle-down&quot;&gt;        &lt;/i&gt; &#123;% trans &quot;Export&quot; %&#125; &#123;&#123;et.name&#125;&#125;&lt;/a&gt;&lt;/li&gt;        &#123;% endfor %&#125;    &lt;/ul&gt;    &#123;% for et in export_types %&#125;    &lt;div id=&quot;export-modal-&#123;&#123;et.type&#125;&#125;&quot; class=&quot;modal fade&quot;&gt;        &lt;div class=&quot;modal-dialog&quot;&gt;            &lt;div class=&quot;modal-content&quot;&gt;                &lt;form method=&quot;get&quot; action=&quot;&quot;&gt;                    &lt;div class=&quot;modal-header&quot;&gt;                        &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/button&gt;                        &lt;h4 class=&quot;modal-title&quot;&gt;&#123;% trans &quot;Export&quot; %&#125; &#123;&#123;et.name&#125;&#125;&lt;/h4&gt;                    &lt;/div&gt;                    &lt;div class=&quot;modal-body&quot;&gt;                        &#123;&#123; form_params|safe &#125;&#125;                        &lt;input type=&quot;hidden&quot; name=&quot;export_type&quot; value=&quot;&#123;&#123;et.type&#125;&#125;&quot;&gt;                        &lt;!-- 增加 导出所选数据 一栏 --&gt;                        &lt;input type=&quot;hidden&quot; name=&quot;_selected_actions&quot; value=&quot;&quot;/&gt;                        &lt;input type=&quot;hidden&quot; name=&quot;_select_across&quot; value=&quot;&quot;/&gt;                        &lt;label class=&quot;checkbox&quot;&gt;                            &#123;% if et.type == &quot;xlsx&quot; %&#125;                            &lt;input type=&quot;checkbox&quot; name=&quot;export_xlsx_header&quot; checked=&quot;checked&quot; value=&quot;on&quot;&gt;                            &#123;% trans &quot;Export with table header.&quot; %&#125;                            &#123;% endif %&#125;                            &#123;% if et.type == &quot;xls&quot; %&#125;                            &lt;input type=&quot;checkbox&quot; name=&quot;export_xls_header&quot; checked=&quot;checked&quot; value=&quot;on&quot;&gt;                            &#123;% trans &quot;Export with table header.&quot; %&#125;                            &#123;% endif %&#125;                            &#123;% if et.type == &quot;csv&quot; %&#125;                            &lt;input type=&quot;checkbox&quot; name=&quot;export_csv_header&quot; checked=&quot;checked&quot; value=&quot;on&quot;&gt;                            &#123;% trans &quot;Export with table header.&quot; %&#125;                            &#123;% endif %&#125;                            &#123;% if et.type == &quot;xml&quot; %&#125;                            &lt;input type=&quot;checkbox&quot; name=&quot;export_xml_format&quot; checked=&quot;checked&quot; value=&quot;on&quot;&gt;                            &#123;% trans &quot;Export with format.&quot; %&#125;                            &#123;% endif %&#125;                            &#123;% if et.type == &quot;json&quot; %&#125;                            &lt;input type=&quot;checkbox&quot; name=&quot;export_json_format&quot; checked=&quot;checked&quot; value=&quot;on&quot;&gt;                            &#123;% trans &quot;Export with format.&quot; %&#125;                            &#123;% endif %&#125;                        &lt;/label&gt;                        &lt;label class=&quot;checkbox&quot;&gt;                            &lt;input type=&quot;checkbox&quot; name=&quot;all&quot; value=&quot;on&quot;&gt; &#123;% trans &quot;Export all data.&quot; %&#125;                        &lt;/label&gt;                        &lt;!-- 增加 导出所选数据 一栏 --&gt;                        &lt;label class=&quot;checkbox&quot;&gt;                            &lt;input type=&quot;checkbox&quot; name=&quot;selected&quot; value=&quot;on&quot;&gt; 导出勾选数据                        &lt;/label&gt;                    &lt;/div&gt;                    &lt;div class=&quot;modal-footer&quot;&gt;                        &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;&#123;% trans &quot;Close&quot; %&#125;&lt;/button&gt;                        &lt;button class=&quot;btn btn-success myexport  glyphicon glyphicon-export &quot; type=&quot;submit&quot;&gt;&lt;i                                class=&quot;fa fa-share&quot;&gt;&lt;/i&gt; &#123;% trans &quot;Export&quot; %&#125;                        &lt;/button&gt;                    &lt;/div&gt;                &lt;/form&gt;            &lt;/div&gt;&lt;!-- /.modal-content --&gt;        &lt;/div&gt;&lt;!-- /.modal-dalog --&gt;    &lt;/div&gt;&lt;!-- /.modal --&gt;    &#123;% endfor %&#125;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    // 如果是订单导出，把待出货订单设置成待收货订单    $(document).ready(function () &#123;        $(&#x27;.myexport&#x27;).click(function () &#123;            // 当把订单导出时，需要修改订单状态为待收货状态            var url = window.location.protocol + &#x27;//&#x27; + window.location.host + &quot;/exportorder/&quot;;            $(&quot;input[name=&#x27;_select_across&#x27;]&quot;).val($(&quot;input[name=&#x27;select_across&#x27;]&quot;).val());            if ($(&quot;input[name=&#x27;selected&#x27;]&quot;).is(&#x27;:checked&#x27;)) &#123;                var arr = [];                $.each($(&#x27;.action-select&#x27;), function () &#123;                    if (true == $(this).prop(&#x27;checked&#x27;)) &#123;                        arr.push($(this).val());                    &#125;                &#125;);                if(arr.length == 0)&#123;                    alert(&#x27;请先勾选导出数据&#x27;)                    return false                &#125;            &#125;else&#123;                var arr = []                var order_type = $(&#x27;.breadcrumb li&#x27;).eq(1).text().trim()                $(&#x27;.grid-item&#x27;).each(function (index, el) &#123;                    arr.push($(el).find(&#x27;td&#x27;).eq(1).text().trim())                &#125;)            &#125;            if (($(&#x27;.breadcrumb &gt; li&#x27;).eq(1).text()).indexOf(&#x27;订单&#x27;) != -1) &#123;                // 5秒后执行                setTimeout(function () &#123;                    $.ajax(&#123;                        type: &quot;POST&quot;,                        url: url,                        data: &#123;&#x27;orderlist&#x27;: JSON.stringify(arr), &#x27;order_type&#x27;: order_type,&#125;,                        beforeSend: function (xhr) &#123;                            xhr.setRequestHeader(&quot;X-CSRFToken&quot;, $.getCookie(&quot;csrftoken&quot;))                        &#125;,                        success: function (data) &#123;                            window.location.reload();                        &#125;,                        error: function (xhr) &#123;                            alert(&quot;出现未知错误&quot;);                            window.location.reload();                        &#125;                    &#125;);                &#125;, 5000);            &#125;        &#125;);    &#125;)&lt;/script&gt;\n\n68、使用F查询更新用户重要数据from django.db.models import F# 使用F查询更新用户余额balance = 5  MallUser.objects.filter(id=1).update(balance=F(&#x27;balance&#x27;) + balance)\n\n相当于sql的\nupdate Malluser set balance=balance + 5 where id=1;\n\n69、日志输出模块import loggingimport platform# 全局函数PlATFORM = platform.system()if (PlATFORM == &quot;Linux&quot;):    # linux系统,文件保存在var下    SERVER_LOG_PATH = &#x27;/var/mylog.log&#x27;else:    # windows系统,文件保存在D盘下    SERVER_LOG_PATH = &#x27;D:\\mylog.log&#x27;# 定义一个logging的对象，命名为mylogLOGGER = logging.getLogger(&#x27;mylog&#x27;)# 设置级别为WARNINGLOGGER.setLevel(logging.WARNING)# 创建一个handler，用于写入日志文件fh = logging.FileHandler(SERVER_LOG_PATH, encoding=&#x27;utf-8&#x27;)fh.setLevel(logging.WARNING)# 定义handler的输出格式formatter = logging.Formatter(&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;, datefmt=&#x27;%Y-%m-%d %H:%M:%S&#x27;)fh.setFormatter(formatter)# 给Logger添加handlerLOGGER.addHandler(fh)# 不在控制台显示LOGGER.propagate = False\n\n70、字典排序字典在内存中发布是无序的，当想对键值或者键名进行排序时可以先把字典转成元组，这可以达到排序的目的。\nscore = &#123;&#x27;小明&#x27;: &#123;&#x27;avg_score&#x27;: 90, &#x27;English&#x27;: 90, &#x27;Math&#x27;: 90, &#x27;Chniese&#x27;: 90, &#125;,     &#x27;小红&#x27;: &#123;&#x27;avg_score&#x27;: 60, &#x27;English&#x27;: 60, &#x27;Math&#x27;: 61, &#x27;Chniese&#x27;: 59, &#125;,     &#x27;小黑&#x27;: &#123;&#x27;avg_score&#x27;: 70, &#x27;English&#x27;: 75, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 70, &#125;,     &#x27;小白&#x27;: &#123;&#x27;avg_score&#x27;: 80, &#x27;English&#x27;: 95, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 80, &#125;,     &#125;# 对姓名进行排序，即对键名进行排序b = sorted(score.items(), key=lambda x: x[0], reverse=True)show_str = &#x27;&#x27;for info in b:    # print(info)    key, value = info[0], info[1]    show_str += &#x27;姓名：&#123;&#125;,平均分：&#123;&#125;，成绩：&#123;&#125;&#x27;.format(key,value[&#x27;avg_score&#x27;], value) + &#x27;\\r\\n&#x27;print(&#x27;对姓名进行排序&#x27;)print(show_str)# 对平均分进行排序b = sorted(score.items(), key=lambda x: x[1][&#x27;avg_score&#x27;], reverse=True)show_str = &#x27;&#x27;for info in b:    # print(info)    key, value = info[0], info[1]    show_str += &#x27;姓名：&#123;&#125;,平均分：&#123;&#125;，成绩：&#123;&#125;&#x27;.format(key,value[&#x27;avg_score&#x27;], value) + &#x27;\\r\\n&#x27;print(&#x27;对平均分进行排序&#x27;)print(show_str)# 对英语成绩进行排序b = sorted(score.items(), key=lambda x: x[1][&#x27;English&#x27;], reverse=True)show_str = &#x27;&#x27;for info in b:    # print(info)    key, value = info[0], info[1]    show_str += &#x27;姓名：&#123;&#125;,平均分：&#123;&#125;，成绩：&#123;&#125;&#x27;.format(key,value[&#x27;avg_score&#x27;], value) + &#x27;\\r\\n&#x27;print(&#x27;对英语成绩进行排序&#x27;)print(show_str)\n\n输出：\n对姓名进行排序姓名：小黑,平均分：70，成绩：&#123;&#x27;avg_score&#x27;: 70, &#x27;English&#x27;: 75, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 70&#125;姓名：小红,平均分：60，成绩：&#123;&#x27;avg_score&#x27;: 60, &#x27;English&#x27;: 60, &#x27;Math&#x27;: 61, &#x27;Chniese&#x27;: 59&#125;姓名：小白,平均分：80，成绩：&#123;&#x27;avg_score&#x27;: 80, &#x27;English&#x27;: 95, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 80&#125;姓名：小明,平均分：90，成绩：&#123;&#x27;avg_score&#x27;: 90, &#x27;English&#x27;: 90, &#x27;Math&#x27;: 90, &#x27;Chniese&#x27;: 90&#125;对平均分进行排序姓名：小明,平均分：90，成绩：&#123;&#x27;avg_score&#x27;: 90, &#x27;English&#x27;: 90, &#x27;Math&#x27;: 90, &#x27;Chniese&#x27;: 90&#125;姓名：小白,平均分：80，成绩：&#123;&#x27;avg_score&#x27;: 80, &#x27;English&#x27;: 95, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 80&#125;姓名：小黑,平均分：70，成绩：&#123;&#x27;avg_score&#x27;: 70, &#x27;English&#x27;: 75, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 70&#125;姓名：小红,平均分：60，成绩：&#123;&#x27;avg_score&#x27;: 60, &#x27;English&#x27;: 60, &#x27;Math&#x27;: 61, &#x27;Chniese&#x27;: 59&#125;对英语成绩进行排序姓名：小白,平均分：80，成绩：&#123;&#x27;avg_score&#x27;: 80, &#x27;English&#x27;: 95, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 80&#125;姓名：小明,平均分：90，成绩：&#123;&#x27;avg_score&#x27;: 90, &#x27;English&#x27;: 90, &#x27;Math&#x27;: 90, &#x27;Chniese&#x27;: 90&#125;姓名：小黑,平均分：70，成绩：&#123;&#x27;avg_score&#x27;: 70, &#x27;English&#x27;: 75, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 70&#125;姓名：小红,平均分：60，成绩：&#123;&#x27;avg_score&#x27;: 60, &#x27;English&#x27;: 60, &#x27;Math&#x27;: 61, &#x27;Chniese&#x27;: 59&#125;\n\n对列表中字典按多个键值排序from operator import itemgetterdata = [    &#123;&#x27;code&#x27;: 1, &#x27;position&#x27;: 300, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,    &#123;&#x27;code&#x27;: 2, &#x27;position&#x27;: 255, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,    &#123;&#x27;code&#x27;: 3, &#x27;position&#x27;: 256, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,    &#123;&#x27;code&#x27;: 1, &#x27;position&#x27;: 500, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,    &#123;&#x27;code&#x27;: 5, &#x27;position&#x27;: 455, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,    &#123;&#x27;code&#x27;: 1, &#x27;position&#x27;: 322, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,    &#123;&#x27;code&#x27;: 6, &#x27;position&#x27;: 676, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,]data = sorted(data, key=itemgetter(&#x27;code&#x27;, &#x27;position&#x27;))print(data)\n\n输出：\n[&#123;&#x27;code&#x27;: 1, &#x27;position&#x27;: 300, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;, &#123;&#x27;code&#x27;: 1, &#x27;position&#x27;: 322, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;, &#123;&#x27;code&#x27;: 1, &#x27;position&#x27;: 500, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;, &#123;&#x27;code&#x27;: 2, &#x27;position&#x27;: 255, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;, &#123;&#x27;code&#x27;: 3, &#x27;position&#x27;: 256, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;, &#123;&#x27;code&#x27;: 5, &#x27;position&#x27;: 455, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;, &#123;&#x27;code&#x27;: 6, &#x27;position&#x27;: 676, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;]\n\n71、时间格式与字符串互转、比较大小import datetime# 当前时间转字符串now = datetime.datetime.strftime(datetime.datetime.now(), &#x27;%Y-%m-%d %H:%M:%S&#x27;)# 字符串转时间格式now = datetime.datetime.strptime(now, &#x27;%Y-%m-%d %H:%M:%S&#x27;)a = now + datetime.timedelta(minutes=-15)# 时间比较大小if a &lt; now:    print(&#x27;yes&#x27;)\n\n72、python把’\\u’开头的字符串转中文str_data = &#x27;\\\\u7528\\\\u6237 ID \\\\u6216\\\\u5bc6\\\\u7801\\\\u9519\\\\u8bef&#x27;# 字符串.encode(&#x27;utf-8&#x27;).decode(&#x27;unicode_escape&#x27;)str_data_to_zh = str_data.encode(&#x27;utf-8&#x27;).decode(&#x27;unicode_escape&#x27;)print(str_data_to_zh)# 输出用户 ID 或密码错误\n\n73、django进行数据迁移时出现No changes detected解决方案原因：可能是由于app下面没有migrations文件夹所以需要创建这个文件夹，命令\npython manage.py makemigrations --empty 你的app名称\n\n74、ubuntu下载文件到windows桌面apt install lrzszsz 123.txt\n\n75、git查看提交日志git log --author=&quot;ldc&quot;\n\n76、python翻译模块可以把英文翻译成中文，也可以把中文翻译成英文\npip install  translatefrom translate import Translatorname = &#x27;giant panda, panda, panda bear, coon bear, Ailuropoda melanoleuca&#x27;translator = Translator(to_lang=&quot;chinese&quot;)translation = translator.translate(name)print(translation)translator= Translator(from_lang=&quot;chinese&quot;,to_lang=&quot;english&quot;)translation = translator.translate(&quot;我想你&quot;)print(translation)输出：大熊猫，熊猫，熊猫熊，浣熊，大熊猫I missed you.\n\n77、python实现字符串转字典import astimport jsontarget_str = &#x27;&#123;&quot;h&quot;: 1, &quot;e&quot;: 2, &quot;l&quot;: 3, &quot;l&quot;: 4, &quot;o&quot;: 5&#125;&#x27;target_str2 = &quot;&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 2, &#x27;l&#x27;: 3, &#x27;l&#x27;: 4, &#x27;o&#x27;: 5&#125;&quot;# 方式1：使用json，缺点，字符串中不能出现单引号# 由于 json 语法规定 数组或对象之中的字符串必须使用双引号，不能使用单引号# 官网https://www.json.org/json-en.html上有一段描述是# A string is a sequence of zero or more Unicode characters, wrapped in double quotes, using backslash escapesprint(json.loads(target_str))# print(json.loads(target_str2))   # 使用json转这个字符串会报错 Expecting property name enclosed in double quotes# 方式2：使用eval函数，缺点，不安全print(eval(target_str))print(eval(target_str2))# print(eval(&quot;__import__(&#x27;os&#x27;).system(&#x27;dir&#x27;)&quot;))  # 会列出当前的目录文件，如果字符串是一些删除命令，则可以把整个目录清空！# 方式3，使用ast.literal_eval，没有json与eval的缺点，推荐使用这个print(ast.literal_eval(target_str))print(ast.literal_eval(target_str2))\n\n输出：\n&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 2, &#x27;l&#x27;: 4, &#x27;o&#x27;: 5&#125;&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 2, &#x27;l&#x27;: 4, &#x27;o&#x27;: 5&#125;&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 2, &#x27;l&#x27;: 4, &#x27;o&#x27;: 5&#125;&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 2, &#x27;l&#x27;: 4, &#x27;o&#x27;: 5&#125;&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 2, &#x27;l&#x27;: 4, &#x27;o&#x27;: 5&#125;\n\n78、django app 如何在后台显示中文名1.在app (这里以user为例)下面的__init__.py文件中\n添加:\ndefault_app_config = &#x27;user.apps.UserConfig&#x27;\n\n2.在apps.py中\nfrom django.apps import AppConfigclass UserConfig(AppConfig):    name = &#x27;user&#x27;    verbose_name = &#x27;用户&#x27;\n\n79、使用python给Excel指定行添加数据import openpyxl, syswb = openpyxl.load_workbook(&#x27;b.xlsx&#x27;)sheet = wb[&#x27;Sheet1&#x27;]# 在excel表格第二行添加新数据addrow = 1   # 增加一行row = 2  # 在第二行新增一行name = &#x27;b-back.xlsx&#x27; # 新的表名wb1 = openpyxl.Workbook()sheet1 = wb1[&#x27;Sheet&#x27;]# 复制前row行for i in range(1, row):    for j in range(1, sheet.max_column + 1):        sheet1.cell(row=i, column=j).value = sheet.cell(row=i, column=j).value# 复制后row行for i in range(row, sheet.max_row + 1):    for j in range(1, sheet.max_column + 1):        if i == row:            # 给第row行添加新的数据            sheet1.cell(row=row, column=j).value = &#x27;新增&#x27;        sheet1.cell(row=i + addrow, column=j).value = sheet.cell(row=i, column=j).valuewb1.save(name)\n\n\n80、python中的format格式拼接字符串d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 5&#125;print(&#x27;&#123;a&#125;,&#123;b&#125;&#x27;.format(**d))print(&#x27;&#123;0&#125;,&#123;1&#125;,&#123;0&#125;&#x27;.format(&#x27;a&#x27;, &#x27;b&#x27;))print(f&quot;&#123;d[&#x27;a&#x27;]&#125;&quot;)\n\n输出：\n1,2a,b,a1\n\n81、数据库inner join、full join、left join、union、union all区别表a_test\n\n表b_test\n\nINNER JOIN\n是A和B的交集\nSELECT * FROM a_test INNER JOIN b_test ON a_test.name = b_test.namesaInner join 产生的结果集中，是A和B的交集。\n\n\nFULL OUTER JOIN\n产生A和B的并集\nSELECT * FROM a_test FULL OUTER JOIN b_test ON a_test.name = b_test.name Full outer join 产生A和B的并集。但是需要注意的是，对于没有匹配的记录，则会以null做为值。可以使用IF NULL判断。\n\n\nSELECT * FROM a_test FULL OUTER JOIN b_test ON a_test.name = b_test.nameWHERE a_test.id IS null OR b_test.id IS null产生A表和B表没有交集的数据集。\n\n\nLEFT [OUTER] JOIN\n产生表A的完全集，而B表中匹配的则有值，没有匹配的则以null值取代\nSELECT * FROM a_test LEFT OUTER JOIN b_test ON a_test.name = b_test.name有些数据库可以不要OUTERSELECT * FROM a_test LEFT  JOIN b_test ON a_test.name = b_test.nameLeft outer join 产生表A的完全集，而B表中匹配的则有值，没有匹配的则以null值取代。\n\n\nSELECT * FROM a_test LEFT OUTER JOIN b_test ON a_test.name = b_test.name WHERE b_test.id IS null产生在A表中有而在B表中没有的集合。\n\n\nRIGHT [OUTER] JOIN\nRIGHT OUTER JOIN 是后面的表为基础，与LEFT OUTER JOIN用法类似。\nUNION 与 UNION ALL\nUNION 操作符用于合并两个或多个 SELECT 语句的结果集。请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。UNION 只选取记录，而UNION ALL会列出所有记录。SELECT name FROM a_test UNION SELECT name FROM b_test选取不同值\n\n\nSELECT a_test.id,a_test.name  FROM a_test UNION SELECT b_test.id,b_test.name FROM b_test由于 id 51 xh   与 id 4 xh 并不相同，不合并\n\n\nSELECT name FROM a_test UNION ALL SELECT name FROM b_test全部列出来\n\n\n还需要注意的是我们还有一个是“交差集” cross join, 这种Join没有办法用文式图表示，因为其就是把表A和表B的数据进行一个N*M的组合，即笛卡尔积。\n表达式如下：SELECT * FROM a_test CROSS JOIN b_test\n这个笛卡尔乘积会产生 4 x 4 &#x3D; 16 条记录，一般来说，我们很少用到这个语法。但是我们得小心，如果不是使用嵌套的select语句，一般系统都会产生笛卡尔乘积然再做过滤。这是对于性能来说是非常危险的，尤其是表很大的时候。\n82、windows电脑查看端口使用情况找出8000端口对应的PID进程，命令为：\nnetstat -ano|findstr 8000\n\n进程信息如下：\nTCP    0.0.0.0:8000           0.0.0.0:0              LISTENING       1620UDP    0.0.0.0:8000           *:*                                    1620\n\n找出进程对应的详细信息：\ntasklist |findstr 1620KGService.exe                 1620 Console                    1     18,696 K\n\n关进程：\ntaskkill /pid 1620 /F\n\n查看程序占用内存比如查看python占用运行内存\ntasklist  /fi &quot;imagename eq python.exe&quot;\n\n\n83、Django生成表和反向生成Model正向生成：python manage.py makemigrationspython manage.py migrate反向：会根据设置的数据库中的表在自动生成对应的Model代码，并打印出来python manage.py inspectdb以直接将打印的代码直接导入到指定的Model文件中python manage.py inspectdb &gt; models.py\n\n84、windows的hosts文件位置C:\\Windows\\System32\\drivers\\etc\\hosts\n\n85、postgresql数据库# 如果表存在就先删除drop table if exists student;# 创建学生表# id      serial not null  表示id自增# id      integer not null  表示id不自增create table student(    id                    serial not null        constraint student_pk            primary key,    name                  varchar,    class_id              integer,    height                numeric,    weight                numeric,    write_date            timestamp    );comment on table student is &#x27;学生表&#x27;;comment on column student.name is &#x27;名称&#x27;;comment on column student.class_id is &#x27;班级ID&#x27;;comment on column student.height is &#x27;身高&#x27;;comment on column student.weight is &#x27;体重&#x27;;comment on column student.write_date is &#x27;修改时间&#x27;;alter table student    owner to odoo;# 更新update user set name=&#x27;张三&#x27; where id=111# 更新表a的字段为表b的值update account_invoice set sale_order_id=so.id from sale_order so where account_invoice.origin=so.name# 新增insert into &quot;user&quot; (name,sex) values (&#x27;小明&#x27;,1),(&#x27;小红&#x27;, 0)# 新增或更新如果id冲突就更新INSERT INTO  student(id, name)   VALUES(12, &#x27;小明&#x27;),(13, &#x27;小红&#x27;)   ON conflict(id) DO UPDATE   SET name =&#x27;未知&#x27;;如果id冲突就什么也不做INSERT INTO  student(id, name)   VALUES(12, &#x27;小明&#x27;),(13, &#x27;小红&#x27;)   ON conflict(id) DO NOTHING;# 把一个表中的数据插入到另一个表中insert into 目标表名 (column1,column2,columnn) select value1,value2,valuen from  源表名比如：insert into student (name, classs_name,create_date) select  student_name as name, class_name, now() from class_table;# 获取当前时间now()select now()# 删除DELETE FROM table_name [WHERE Clause]# 增加字段alter table 表名 add column 列名 类型;# 删除字段alter table 表名 dropcolumn 列名 ;# postgresql数据库查看表所有字段select * from information_schema.columns where table_schema=&#x27;public&#x27; and table_name=&#x27;表名&#x27;;# postgresql获取所有表名select tablename from pg_tables where schemaname=&#x27;public&#x27;# 对查询结果按id降序显示select * from table_name order by id desc# 对查询结果按id升序显示select * from table_name order by id asc# 转义字符, 查找name中包含单引号的记录select * from student where name like  E&#x27;%\\&#x27;%&#x27;;# 查看表记录总数select relname as TABLE_NAME, reltuples as rowCounts from pg_class where relkind = &#x27;r&#x27; and relnamespace = (select oid from pg_namespace where nspname=&#x27;public&#x27;) order by rowCounts desc;# 将结果转换为数组SELECT array(SELECT &quot;name&quot; FROM sale_order);# 将数组合并为字符串select array_to_string(array[1,2,3], &#x27;,&#x27;)# 联合子集更新，把sale_order_line的name连接换行符，然后按id更新到表a_test中对应的nameupdate a_test set name=array_to_string(array(select name from sale_order_line where order_id=a_test.id),&#x27;&lt;br/&gt;&#x27;);# PostgreSQL合并查询同一列的多条记录，针对一对多，多对多字段比如表：id   name                  1    小明                   1    小红                     id   name1    小亮        --&gt;          1    小明，小亮，小红2    小强                     2    小强，小王2    小王SELECT     id, array_to_string(ARRAY(SELECT unnest(array_agg(name order by name desc))),&#x27;,&#x27;) AS all_nameFROM      studentGROUP BY id;# case语句case var\twhen condition1 then statement1\twhen condition2 then statement2else statementnend as new_name比如：select case name\twhen &#x27;小明&#x27; then &#x27;xm&#x27;\twhen &#x27;小红&#x27; then &#x27;xh&#x27;\twhen &#x27;小刚&#x27; then &#x27;xg&#x27;else &#x27;xw&#x27;end as short_namefrom student# 临时表、字符串合并、类型转换、时间格式转换、当前时间WITH TEMP AS ( \tSELECT CAST ( concat ( bam.account_period_code, &#x27;-01&#x27; ) AS TIMESTAMP ) \t   AS account_period_time \t\t FROM bi_account_move AS bam ) SELECT\taccount_period_time,\tto_char(CURRENT_DATE,&#x27;yyyy-MM-dd hh24:MI:ss&#x27;) as current_date,\tto_char( account_period_time, &#x27;yyyy&#x27; ) as year,\tto_char( account_period_time, &#x27;MM&#x27; ) as month,\tto_char( account_period_time, &#x27;dd&#x27; ) as day FROM TEMP比如：account_period_time\tcurrent_date\t    year\tmonth\tday2019-06-01 0:00:00\t2020-06-24 00:00:00\t2019\t 06\t     012019-06-01 0:00:00\t2020-06-24 00:00:00\t2019\t 06\t     01# 多个字符串拼接select concat(&#x27;payment_&#x27;, CAST(ap.id as varchar)) as line_keyfrom ap# 将查询所得结果集的某一字段拼接成字符串，默认的是逗号select GROUP_CONCAT(id) from test where id&gt;5;结果为：1,2,3,4,5,6,7# 使用其他分隔符拼接select GROUP_CONCAT(id separator &#x27;-&#x27;) from test where id&gt;5;结果为：1-2-3-4-5-6-7# 多个临时表WITH temp_student AS ( SELECT ID, NAME, sex FROM student WHERE sex = TRUE ),temp_class AS (\tSELECT\t\tID,\t\tNAME,\t\tstudent_id,\t\tteacher_id\tFROM\t\tthe_class \t),\ttemp_teacher AS (\tSELECT \t  ID,\t\tNAME,\t\tage \tFROM\t\tteacher \t) \tSELECT\tts.NAME AS student_name,\ttc.NAME AS class_name,\tte.NAME AS teacher_name\tfrom temp_student as ts\tLEFT JOIN temp_class AS tc ON tc.student_id = ts.ID  \tLEFT JOIN teacher AS te ON te.id = tc.teacher_id  # null转成有意义的值select COALESCE(name, &#x27;&#x27;) as name from a_test意思就是如果name为null，就转为空字符串# 字符串截取select SUBSTRING(&#x27;abcd&#x27;,1,2); -- result:ab 表示从下标从1开始,截取2个字符# 使用 interval 时间相加减(+/-)当前时间 + 10秒，select to_char(now() + interval &#x27;10 second&#x27;, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;)  as reqDate from account_period;当前时间 - 10秒select to_char(now() + interval &#x27;-10 second&#x27;, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;)  as reqDate from account_period; 当前时间 + 10分，select to_char(now() + interval &#x27;10 minute&#x27;, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;)  as reqDate  from account_period; 当前时间 + 10时，select to_char(now() + interval &#x27;10 hour&#x27;, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;)  as reqDate from account_period; 当前时间 + 10天，select to_char(now() + interval &#x27;10 day&#x27;, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;)  as reqDate from account_period;当前时间 + 10年，select to_char(now() + interval &#x27;10 year&#x27;, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;)  as reqDate from account_period;# UNION types numeric and text cannot be matchedNULL::NUMERIC 这个问题，是因为几个sql组合在一起时，同一个字段的值，遇到null时，需要进行类型转换。# 对行记录定义行编号，使用函数ROW_NUMBER()# 按分数进行降序，然后给行记录标记行编号，可以作为排名来使用select           \tROW_NUMBER() OVER (ORDER BY score desc) AS sequence_number,\tname,scorefrom\tb_test# 数字转字符串  select cast(123 as VARCHAR); # 字符串转数字  select cast(&#x27;123&#x27; as INTEGER);\n\n86、python控制台输出带颜色的文字方法#格式：　　设置颜色开始 ：\\033[显示方式;前景色;背景色m#说明：前景色            背景色           颜色---------------------------------------30                40              黑色31                41              红色32                42              绿色33                43              黃色34                44              蓝色35                45              紫红色36                46              青蓝色37                47              白色显示方式           意义-------------------------0                终端默认设置1                高亮显示4                使用下划线5                闪烁7                反白显示8                不可见 #例子：\\033[1;31;40m    &lt;!--1-高亮显示 31-前景色红色  40-背景色黑色--&gt;\\033[0m          &lt;!--采用终端默认设置，即取消颜色设置--&gt;\n\n例子print(&#x27;紫红字体 \\033[1;35m hello world \\033[0m!&#x27;)print(&#x27;褐色背景绿色字体 \\033[1;32;43m hello world \\033[0m!&#x27;)print(&#x27;\\033[1;33;44mhello world\\033[0m&#x27;)\n\n\n87、控制台输出白色方框print(&#x27;█&#x27;)\n\n88、xadmin后台编辑多对多字段在models.py定义了多对多字段，想要在编辑时可以灵活使用这个字段的话，可以按以下方法设置：modes.py\nclass Book(models.Model):    title = models.CharField(verbose_name=&quot;书名&quot;, max_length=32)    second_title = models.CharField(verbose_name=&quot;副标题&quot;, max_length=32, blank=True, null=True)    author = models.CharField(verbose_name=&quot;作者&quot;, max_length=32)    translator = models.CharField(verbose_name=&quot;译者&quot;, max_length=32, blank=True, null=True)    intro = models.TextField(verbose_name=&quot;描述&quot;)    pic = models.FileField(verbose_name=&quot;封面图片&quot;, max_length=64, upload_to=&#x27;book_cover&#x27;, null=True, blank=True)    tags = models.ManyToManyField(Tags, verbose_name=&#x27;书籍标签&#x27;, blank=True)    prizes = models.ManyToManyField(Prizes, verbose_name=&#x27;获奖详情&#x27;, blank=True)    sump = models.IntegerField(verbose_name=&quot;收藏人数&quot;, default=0)    rate_num = models.IntegerField(verbose_name=&quot;评分人数&quot;, default=0)    num = models.IntegerField(verbose_name=&quot;浏览量&quot;, default=0)    published_time = models.DateField(blank=True, null=True, verbose_name=&#x27;出版时间&#x27;)    create_time = models.DateTimeField(auto_now_add=True, verbose_name=&#x27;创建时间&#x27;)    class Meta:        db_table = &#x27;book&#x27;        verbose_name = &quot;图书&quot;        verbose_name_plural = &quot;图书&quot;    def __str__(self):        return self.title\n\nadminx.py\n# 书籍管理class BookAdmin(object):    search_fields = [&#x27;title&#x27;, &#x27;author&#x27;, &#x27;intro&#x27;]  # 检索字段    list_display = [&#x27;id&#x27;, &#x27;show_pic&#x27;, &#x27;title&#x27;, &#x27;second_title&#x27;, &#x27;author&#x27;, &#x27;translator&#x27;, &#x27;published_time&#x27;, &#x27;intro&#x27;,                    &#x27;tags&#x27;, &#x27;prizes&#x27;, &#x27;num&#x27;, &#x27;sump&#x27;, &#x27;rate_num&#x27;]  # 要显示的字段    list_filter = [&#x27;published_time&#x27;, &#x27;tags&#x27;, &#x27;prizes&#x27;]  # 分组过滤的字段    ordering = (&#x27;id&#x27;,)  # 设置默认排序字段，负号表示降序排序    list_per_page = 30  # 默认每页显示多少条记录，默认是100条    model_icon = &#x27;fa fa-book&#x27;  # 左侧小图标    list_editable = [&#x27;title&#x27;, &#x27;author&#x27;, &#x27;intro&#x27;, &#x27;published_time&#x27;]  # 可编辑字段    style_fields = &#123;&#x27;tags&#x27;: &#x27;m2m_transfer&#x27;, &#x27;prizes&#x27;: &#x27;m2m_transfer&#x27;&#125;  # 控制字段的显示样式    filter_horizontal = (&#x27;tags&#x27;, &#x27;prizes&#x27;)  # 水平选择编辑多对多字段\n\n重点是设置style_fields 和filter_horizontal ，效果：\n\n89、Django后台通过按钮显示TextField字段内容由于TextField字段类型内容可能很长，在后台显示时很占屏幕位置，可以通过按钮来控制显示，代码如下：models.py中定义了一个TextField字段类型：\nclass Prizes(models.Model):    name = models.CharField(max_length=32, verbose_name=&quot;奖项&quot;)    intro = models.TextField(blank=True, null=True, verbose_name=&#x27;简介&#x27;)    class Meta:        db_table = &#x27;prizes&#x27;        verbose_name = &quot;奖项&quot;        verbose_name_plural = &quot;奖项&quot;    def __str__(self):        return self.name\n\n这里使用xadmin作为后台管理框架，在adminx.py中代码如下：\nimport xadminfrom django.utils.safestring import mark_safefrom xadmin import viewsfrom .models import *# 奖项管理class PrizesAdmin(object):    search_fields = [&#x27;name&#x27;]  # 检索字段    list_display = [&#x27;id&#x27;, &#x27;name&#x27;, &#x27;show_intro&#x27;]    list_filter = [&#x27;name&#x27;]    ordering = (&#x27;id&#x27;,)    def show_intro(self, obj):        # 显示简介        if not obj.intro:            return mark_safe(&#x27;&#x27;)        if len(obj.intro) &lt; 20:            return mark_safe(obj.intro)        short_id = f&#x27;&#123;obj._meta.db_table&#125;_short_text_&#123;obj.id&#125;&#x27;        short_text_len = len(obj.intro) // 4        short_text = obj.intro[:short_text_len] + &#x27;......&#x27;        detail_id = f&#x27;&#123;obj._meta.db_table&#125;_detail_text_&#123;obj.id&#125;&#x27;        detail_text = obj.intro        text = &quot;&quot;&quot;&lt;style type=&quot;text/css&quot;&gt;                        #%s,%s &#123;padding:10px;border:1px solid green;&#125;                   &lt;/style&gt;                    &lt;script type=&quot;text/javascript&quot;&gt;                    function openShutManager(oSourceObj,oTargetObj,shutAble,oOpenTip,oShutTip,oShortObj)&#123;                        var sourceObj = typeof oSourceObj == &quot;string&quot; ? document.getElementById(oSourceObj) : oSourceObj;                        var targetObj = typeof oTargetObj == &quot;string&quot; ? document.getElementById(oTargetObj) : oTargetObj;                        var shortObj = typeof oShortObj == &quot;string&quot; ? document.getElementById(oShortObj) : oShortObj;                        var openTip = oOpenTip || &quot;&quot;;                        var shutTip = oShutTip || &quot;&quot;;                        if(targetObj.style.display!=&quot;none&quot;)&#123;                           if(shutAble) return;                           targetObj.style.display=&quot;none&quot;;                           shortObj.style.display=&quot;block&quot;;                           if(openTip  &amp;&amp;  shutTip)&#123;                            sourceObj.innerHTML = shutTip;                            &#125;                        &#125; else &#123;                           targetObj.style.display=&quot;block&quot;;                           shortObj.style.display=&quot;none&quot;;                           if(openTip  &amp;&amp;  shutTip)&#123;                            sourceObj.innerHTML = openTip;                            &#125;                        &#125;                        &#125;                    &lt;/script&gt;                    &lt;p id=&quot;%s&quot;&gt;%s&lt;/p&gt;                    &lt;p&gt;&lt;a href=&quot;###&quot; οnclick=&quot;openShutManager(this,&#x27;%s&#x27;,false,&#x27;点击关闭&#x27;,&#x27;点击展开&#x27;,&#x27;%s&#x27;)&quot;&gt;点击展开&lt;/a&gt;&lt;/p&gt;                    &lt;p id=&quot;%s&quot; style=&quot;display:none&quot;&gt;                       %s                    &lt;/p&gt;                    &quot;&quot;&quot; % (short_id, detail_id, short_id, short_text, detail_id, short_id, detail_id, detail_text)        return mark_safe(text)    show_intro.short_description = &#x27;描述&#x27;\n\n注意：复制代码后需要做如下修改：\n\n一开始效果\n\n点击展开效果：\n90、前端判断上传的文件是否为图片且限制大小为300kB&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en-us&quot;&gt;&lt;body class=&quot;login&quot;&gt;&lt;input class=&quot;form-control input-lg&quot; id=&quot;id_icon&quot; name=&quot;icon&quot; type=&quot;file&quot; onchange=&quot;imgTypeSize(&#x27;id_icon&#x27;,300)&quot;&lt;script type=&quot;text/javascript&quot;&gt;    //判断是否为图片，若为图片，判断其大小是否大于0.3M    function imgTypeSize(FileId, maxsize) &#123;        /*获取图片内容对象*/        var imgFile = document.getElementById(FileId).files[0];        if (imgFile.name == &quot;&quot;) &#123;            alert(&quot;请上传头像哦&quot;);            return false;        &#125; else &#123;            /*图片类型正则验证*/            var imgStr = /\\.(jpg|jpeg|png|bmp|BMP|JPG|PNG|JPEG)$/;            if (!imgStr.test(imgFile.name)) &#123;                alert(&quot;文件不是图片类型&quot;);                return false;            &#125; else &#123;                /*图片大小*/                var imagSize = imgFile.size;                if (imagSize &lt; (1024 * maxsize)) &#123;                    return true;                &#125; else &#123;                    alert(imgFile.name + &quot;大小不能超过&quot; + maxsize + &quot;kB&quot;);                    document.getElementById(FileId).value = &quot;&quot;                    return false;                &#125;            &#125;        &#125;    &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n91、form表单提交前验证&lt;form action=&quot;&quot; method=&quot;post&quot; id=&quot;login-form&quot; onsubmit=&quot;return toVaild()&quot;&gt;\t&lt;input class=&quot;form-control&quot; id=&quot;id_account&quot; name=&quot;account&quot; type=&quot;text&quot; placeholder=&quot;账号&quot;/&gt;\t&lt;input class=&quot;form-control&quot; id=&quot;id_password&quot; name=&quot;password&quot; type=&quot;password&quot; placeholder=&quot;密码&quot;&gt;&lt;form&gt;&lt;script type=&quot;text/javascript&quot;&gt;    document.getElementById(&#x27;id_username&#x27;).focus()    function toVaild() &#123;        var account = document.getElementById(&quot;id_account&quot;).value;        var password = document.getElementById(&quot;id_password&quot;).value;        if (account == &quot;&quot; || password == &quot;&quot;) &#123;            alert(&quot;请输入账号和密码&quot;);            return false;        &#125; else &#123;            return true;        &#125;    &#125;&lt;/script&gt;\n\n92、有序字典import collectionsd1 = collections.OrderedDict()  # 创建一个有序字典d1[&#x27;a&#x27;] = &#x27;A&#x27;d1[&#x27;b&#x27;] = &#x27;B&#x27;d1[&#x27;c&#x27;] = &#x27;C&#x27;d1[&#x27;d&#x27;] = &#x27;D&#x27;for k, v in d1.items():    print(k, v)\n\n93、Python在Windows系统下实现TTS（文字转语音）导入包：\npip install pypiwin32import win32com.clientspk = win32com.client.Dispatch(&quot;SAPI.SpVoice&quot;)spk.Speak(u&quot;my name is ldc,what is your name&quot;)spk.Speak(u&quot;大家好&quot;)\n\n94、定义一个简单闹钟# pip install pypiwin32 -i https://pypi.python.org/simpleimport win32com.clientimport time import winsoundspk = win32com.client.Dispatch(&quot;SAPI.SpVoice&quot;)# 定义闹钟时间clocktime = [[19, 19], [11, 10], [12, 10], [18, 47]]  runinghour = 1  # 定义运行时间times = runinghour * 3600  # 次数print(times)for i in range(1, times):    time_now = [time.localtime(time.time()).tm_hour, time.localtime(time.time()).tm_min]    if time_now in clocktime:        print(time_now)        winsound.Beep(1000, 1000)        spk.Speak(u&quot;快去看下饭好了没有？&quot;)    time.sleep(60)  # 每分钟对比一次时间\n\n95、根据年月获取当月天数def get_month_days(year, month):    &quot;&quot;&quot;    根据年份，月份信息显示此月份天数    :param year: 年份：    :param month: 月份（1～12）：    :return: 当月天数    &quot;&quot;&quot;    if month &gt;12 or month &lt;= 0:        return -1    if month == 2:        return 29 if year % 4 == 0 and year % 100 != 0 or year % 400 == 0 else 28    if month in (4, 6, 9, 11):        return 30    else:        return 31a = &#x27;2020-04&#x27;.split(&#x27;-&#x27;)year = int(a[0])month = int(a[1])print(get_month_days(year,month))输出：30\n\n96、Django获取favicon.ico图标制作一个ico文件，使用PS或者某些在线生成ico的网站\n将此文件命名为“favicon.ico”后放在static&#x2F;下\n\n在urls.py中定义路由：\nfrom django.urls import pathfrom django.views.generic import RedirectViewurlpatterns = [\t# 访问favicon.ico 网站图标    path(&quot;favicon.ico&quot;,RedirectView.as_view(url=&#x27;static/favicon.ico&#x27;)),]\n\n97、django 静态文件配置settings.py\nSTATIC_URL = &#x27;/static/&#x27;# 添加静态资源路由地址STATICFILES_DIRS = [    os.path.join(BASE_DIR, &#x27;static&#x27;),]# 使用python manage.py collectstatic收集静态文件时时使用STATIC_ROOT# STATIC_ROOT = os.path.join(BASE_DIR, &#x27;static&#x27;)\n\nurls.py\nfrom django.urls import path, re_path\nfrom django.views.generic import RedirectView\nfrom django.views.static import serve\n\nfrom &#39;你的项目名称&#39; import settings\nurlpatterns = [\n   \n    path(&quot;favicon.ico&quot;,RedirectView.as_view(url=&#39;static/favicon.ico&#39;)),\n    re_path(&#39;static/(?P&lt;path&gt;.*)$&#39;, serve, &#123;&#39;document_root&#39;: settings.STATICFILES_DIRS[0]&#125;),\n    \n]\n\n98、django JsonResponse返回中文时显示unicode编码（\\u67e5\\u8be2）原因这个unicode编码，是python3默认返回的编码。\n解决方案JsonResponse里面有个参数json_dumps_params，设置为json_dumps_params&#x3D;{‘ensure_ascii’:False}即可。\ndata = &#123;&#x27;msg&#x27;: &#x27;创建成功&#x27;,&#125;return JsonResponse(data=data, json_dumps_params=&#123;&#x27;ensure_ascii&#x27;: False&#125;)\n\n99、获取当前时间月份的首日与最后一天import calendardef get_month_start_and_end(date=datetime.datetime.now()):    &quot;&quot;&quot;    获取当前时间的月份首日与最后一天    :param date:    :return: (首日，最后一天)    &quot;&quot;&quot;    year, month = str(date).split(&#x27;-&#x27;)[0], str(date).split(&#x27;-&#x27;)[1]    end = calendar.monthrange(int(year), int(month))[1]    return f&#x27;&#123;year&#125;-&#123;month&#125;-01&#x27;, f&#x27;&#123;year&#125;-&#123;month&#125;-&#123;end&#125;&#x27;\n\n100、xadmin后台批量操作adminx.py\nimport xadminfrom django.db.models import  Sumfrom xadmin.plugins.actions import BaseActionViewclass MyCountFeeAction(BaseActionView):    &quot;&quot;&quot;        用户余额统计        &quot;&quot;&quot;    action_name = &quot;countuserfee&quot;  #: 相当于这个 Action 的唯一标示, 尽量用比较针对性的名字    description = u&#x27;统计用户总余额&#x27;  #: 描述, 出现在 Action 菜单中, 可以使用 ``%(verbose_name_plural)s`` 代替 Model 的名字.    model_perm = &#x27;view&#x27;  # 权限    def do_action(self, queryset):        all_balance = MallUser.objects.all().aggregate(Sum(&#x27;balance&#x27;))        return HttpResponse(f&#x27;用户总余额&#123;all_balance&#125;&#x27;)class UserAdmin(object):    &quot;&quot;&quot;用户信息管理&quot;&quot;&quot;    list_display = [&#x27;username&#x27;, &#x27;balance&#x27;, &#x27;status&#x27;, &#x27;addtime&#x27;]    search_fields = [&#x27;username&#x27;, ]    list_filter = [&#x27;status&#x27;, &#x27;addtime&#x27;]    list_per_page = 30  # 默认每页数量    model_icon = &#x27;fa fa-user&#x27;    list_editable = [&#x27;status&#x27;]    ordering = [&#x27;-addtime&#x27;]    actions = [ MyCountFeeAction]  # 添加批量选择操作\n\n\n101、xadmin过滤器外键显示特定值（比如只能过滤自己与超级管理员定义的数据）首先，修改xadmin源码，修改xadmin&#x2F;filters.py,在401行，做如下修改，\n把self.lookup_choices = field.get_choices(include_blank=False)\n改为：\n\n# 调用自定义的方法\nif hasattr(model_admin, &#39;&#123;field&#125;_choices&#39;.format(field=field.name)):\n        self.lookup_choices = getattr(model_admin, &#39;&#123;field&#125;_choices&#39;.format(field=field.name))(field, request,params, model,model_admin,field_path)\n    else:\n        self.lookup_choices = field.get_choices(include_blank=False)\n\n如图:\n\n然后，在adminx.py中定义过滤的方法：\nimport xadminfrom django.db.models import  Q, Sumfrom xadmin.plugins.actions import BaseActionViewclass MeasurePointAdmin(object):    # search_fields = [&#x27;user__name&#x27;, &#x27;user__account&#x27;]  # 检索字段    list_display = [&#x27;num&#x27;, &#x27;elevation&#x27;, &#x27;correct_num&#x27;, &#x27;cumulative_amount&#x27;]    list_filter = [&#x27;user&#x27;, &#x27;is_default&#x27;, &#x27;create_time&#x27;]  # 分组过滤的字段    list_editable = [&#x27;num&#x27;, &#x27;elevation&#x27;, &#x27;correct_num&#x27;, &#x27;cumulative_amount&#x27;]    ordering = (&#x27;id&#x27;,)  # 设置默认排序字段，负号表示降序排序    list_per_page = 30  # 默认每页显示多少条记录，默认是100条    model_icon = &#x27;fa fa-users&#x27;  # 左侧小图标    readonly_fields = [&#x27;user&#x27;, &#x27;is_default&#x27;]    import_excel = True    actions = [MyCountFeeAction]\t\t# 定义的函数名必须是  字段名_choices    def user_choices(self, field, request, params, model, model_admin, field_path):        # 超级用户不做控制        if self.request.user.is_superuser:            return field.get_choices(include_blank=False)        # 过滤器只显示自己与超级管理员        user_lst = field.related_model._default_manager.filter(Q(id=self.request.user.id) | Q(is_superuser=True))        # 返回格式 [(&#x27;pk&#x27;,&#x27;标题&#x27;),]        return [(user.id, user.username) for user in user_lst]\n\n效果:\n\n102、Django中的CSRF局部禁用为了避免没有csrf token而产生的403的forbidden错误，可以使用csrf_exempt装饰器来处理POST、GET请求的View, 这种方式是CSRF局部禁用。\nfrom django.utils.decorators import method_decoratorfrom django.views.decorators.csrf import csrf_exempt@method_decorator(csrf_exempt)def update_data(request):    if request.method == &#x27;POST&#x27;:    \tpass\telif request.method == &#x27;GET&#x27;:    \tpass\n\n103、使用python命令创建django项目创建django项目方式一：直接打开pycharm创建，选择file-&gt;new project-&gt;django方式二：通过命令创建先创建虚拟环境：python -m venv django_venv然后导入django库：pip install django -i https://pypi.tuna.tsinghua.edu.cn/simple最后使用命令创建：django-admin startproject my_django_project\n104、 二维列表、二维数组行求和与列求和import pandas as pdfrom functools import reduce# 二维数组，对列和行求和a = [    [&#x27;&#x27;, 0, &#x27;&#x27;, 1, 4.1],    [&#x27;&#x27;, 0, &#x27;&#x27;, &#x27;&#x27;, 4],    [&#x27;123&#x27;, 0, &#x27;&#x27;, 3, 4, 6,7],]def aa(x, y):    x = 0 if isinstance(x, str) else x    y = 0 if isinstance(y, str) else y    return x + y# 对行求和row_sum = [reduce(aa, i) for i in a]# 对列求和，只能处理相同长度的子元素column_sum_1 = [reduce(aa, i) for i in zip(*a)]# 对列求和，可以处理不同长度的子元素column_sum_2 = list(dict(pd.DataFrame(a).fillna(0).apply(lambda x: &#x27;&#x27; if any(isinstance(d, str) for d in x) else round(x.sum(), 2))).values())print(&#x27;行求和：&#123;&#125;\\r\\n列求和(相同长度)：&#123;&#125;\\r\\n列求和：&#123;&#125;&#x27;.format(row_sum, column_sum_1, column_sum_2))\n\n输出：\n行求和：[5.1, 4, 20]列求和(相同长度)：[0, 0, 0, 4, 12.1]列求和：[&#x27;&#x27;, 0, &#x27;&#x27;, &#x27;&#x27;, 12.1, 6.0, 7.0]\n\n105、获取时间字符串的月份数from datetime import datetime    def get_months(start_month_str, end_month_str):    &#x27;&#x27;&#x27;    # 获取时间字符串中的月份数    :param start_month_str: 开始字符串    :param end_month_str: 结束字符串    :return: 月份数    &#x27;&#x27;&#x27;    end_month_date = datetime.strptime(end_month_str, &#x27;%Y-%m&#x27;)    start_month_date = datetime.strptime(start_month_str, &#x27;%Y-%m&#x27;)    end_year, end_month = end_month_date.year, end_month_date.month    start_year, start_month = start_month_date.year, start_month_date.month    return (end_year - start_year) *12 + (end_month - start_month) + 1end_month_str = &#x27;2021-02&#x27;start_month_str = &#x27;2020-07&#x27;print(get_months(start_month_str, end_month_str))输出：8\n\n106、字符串不足补零print(&#x27;hello world&#x27;.zfill(15)) # 补0print(&#x27;hello world&#x27;.rjust(15)) # 右对齐，补空格print(&#x27;hello world&#x27;.ljust(15)) # 左对齐，补空格输出：0000hello world    hello worldhello world  \n\n107、时间戳转字符串日期import timet1 = time.time()print(t1)print(time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime(t1)))输出：1621741567.0821922021-05-23 11:46:07\n\n使用函数：\n# !/usr/bin/python# -*- coding: utf-8 -*-&quot;&quot;&quot;@contact: 微信 1257309054@file: 时间戳转日期.py@time: 2022/6/27 17:16@author: LDC&quot;&quot;&quot;import timeimport datetime# 正确10位长度的时间戳可精确到秒，11-14位长度则是包含了毫秒def int_to_datetime(intValue):    if len(str(intValue)) == 10:        # 精确到秒        timeValue = time.localtime(intValue)        tempDate = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, timeValue)        datetimeValue = datetime.datetime.strptime(tempDate, &quot;%Y-%m-%d %H:%M:%S&quot;)    elif 10 &lt; len(str(intValue)) and len(str(intValue)) &lt; 15:        # 精确到毫秒        k = len(str(intValue)) - 10        timetamp = datetime.datetime.fromtimestamp(intValue / (1 * 10 ** k))        datetimeValue = timetamp.strftime(&quot;%Y-%m-%d %H:%M:%S.%f&quot;)    else:        return -1    return datetimeValuetime1 = 1656321420time2 = 1656321086560print(int_to_datetime(time1))print(int_to_datetime(time2))&#x27;&#x27;&#x27;输出：2022-06-27 17:17:002022-06-27 17:11:26.560000&#x27;&#x27;&#x27;\n\n108、列表转字符串a = [1,2,3]print(&#x27;,&#x27;.join(map(str,a)))输出：`1,2,3`\n\n109、pip国内镜像源pip install 库名 -i https://pypi.tuna.tsinghua.edu.cn/simple清华：-i https://pypi.tuna.tsinghua.edu.cn/simple阿里云：-i http://mirrors.aliyun.com/pypi/simple/中国科技大学 -i https://pypi.mirrors.ustc.edu.cn/simple/华中理工大学：-i http://pypi.hustunique.com/山东理工大学：-i http://pypi.sdutlinux.org/ 豆瓣：-i http://pypi.douban.com/simple/\n\n110、python把时间字符串转换成刚刚、1天前、3个月前、1年前import datetimeimport timedef date_interval(date_str):    &#x27;&#x27;&#x27;    获取时间间隔    1分钟前，2分钟前，10分钟前，1小时前，2小时前，1天前，2天前，3天前，1个月前，3个月前，1年前，3年前    :param date_str: 时间字符串    :return: 字符串    &#x27;&#x27;&#x27;    date_str = time.strptime(date_str, &#x27;%Y-%m-%d %H:%M:%S&#x27;)    # 将时间元组转换为时间戳    t = time.mktime(date_str)    # 当前时间    seconds = time.time() - t    years = int(seconds // (60 * 60 * 24 * 365))    if years:        return &#x27;&#123;&#125;年前&#x27;.format(years)    months = int(seconds // (60 * 60 * 24 * 30))    if months:        return &#x27;&#123;&#125;月前&#x27;.format(months)    days = int(seconds // (60 * 60 * 24))    if days:        return &#x27;&#123;&#125;天前&#x27;.format(days)    hours = int(seconds // (60 * 60))    if hours:        return &#x27;&#123;&#125;小时前&#x27;.format(hours)    minutes = int(seconds // (60))    if minutes:        return &#x27;&#123;&#125;分钟前&#x27;.format(minutes)    return &#x27;刚刚&#x27;if __name__ == &#x27;__main__&#x27;:    date1 = &#x27;2019-07-10 15:27:51&#x27;    date2 = &#x27;2021-07-10 15:27:51&#x27;    date3 = &#x27;2021-08-10 15:27:51&#x27;    date4 = &#x27;2021-08-12 11:01:51&#x27;    date5 = datetime.datetime.now() + datetime.timedelta(seconds=-3)    date5 = date5.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;)    print(date_interval(date1))    print(date_interval(date2))    print(date_interval(date3))    print(date_interval(date4))    print(date_interval(date5))\n\n111、Django使用ORM执行sql语句通过raw函数执行\nalarm_datas = gsm.AlertMessage.objects.raw(&#x27;&#x27;&#x27;                select am_all.id, am_all.sensor_number                    FROM alert_message as am_all                    where                         am_all.real=&#x27;1&#x27;                        and am_all.is_show=1                    order by am_all.alarm_level desc                &#x27;&#x27;&#x27;)for ad in alarm_datas:\tprint(ad.sensor_number)\n\n112、Django通过变量字段获取数据通过方法__getattribute__来获取\nalert_messages = AlertMessage.objects.filter(real=0)am_fields = [&#x27;id&#x27;, &#x27;real&#x27;, &#x27;name&#x27;]for am in alert_messages:\tfor i in range(len(am_fields)):\t\tprint(am_fields[i], am.__getattribute__(am_fields[i]))\n\n113、Django查询变量字段、更新变量字段通过**&#123;变量名:值&#125;来操作\nfield = &#x27;device_code&#x27;# 查询device_infos = gsm.DeviceInfo.objects.filter(**&#123;field: &#x27;012&#x27;&#125;)# 更新gsm.DeviceInfo.objects.filter(device_code=&#x27;012&#x27;).update(**&#123;field : &#x27;0&#x27;&#125;)\n\n114、vue生成dist文件安装npm，到官网下载在vue项目下打开cmd，输入命令\nnpm run build\n\n如果报错，npm ERR! missing script: build，则使用以下命令\nnpm run build:prod\n\n具体看package.json\n\n115、python获取电脑磁盘、CPU、内存使用情况import psutil#  pip install psutil# 获取本机磁盘使用率和剩余空间G信息def get_disk_info():    # 循环磁盘分区    content = &quot;&quot;    for disk in psutil.disk_partitions():        # 读写方式 光盘 or 有效磁盘类型        if &#x27;cdrom&#x27; in disk.opts or disk.fstype == &#x27;&#x27;:            continue        disk_name_arr = disk.device.split(&#x27;:&#x27;)        disk_name = disk_name_arr[0]        disk_info = psutil.disk_usage(disk.device)        # 磁盘剩余空间，单位G        free_disk_size = disk_info.free//1024//1024//1024        # 当前磁盘使用率和剩余空间G信息        info = &quot;&#123;&#125;盘使用率：&#123;&#125;%%， 剩余空间：&#123;&#125;G &quot;.format(disk_name, str(disk_info.percent), free_disk_size)        # 拼接多个磁盘的信息        content = content + info    print(content)# cpu信息def get_cpu_info():    cpu_percent = psutil.cpu_percent(interval=1)    cpu_info = &quot;CPU使用率：%i%%&quot; % cpu_percent    print(cpu_info)# 内存信息def get_memory_info():    virtual_memory = psutil.virtual_memory()    used_memory = virtual_memory.used/1024/1024/1024    free_memory = virtual_memory.free/1024/1024/1024    memory_percent = virtual_memory.percent    memory_info = &quot;内存使用：%0.2fG，使用率%0.1f%%，剩余内存：%0.2fG&quot; % (used_memory, memory_percent, free_memory)    print(memory_info)if __name__ == &#x27;__main__&#x27;:    get_disk_info()    get_cpu_info()    get_memory_info()\n\n116、max比较字典列表&#x27;&#x27;&#x27;使用max函数比较字典列表对象需求：找出用户组最大id的字典&#x27;&#x27;&#x27;def com_id(f):    &#x27;&#x27;&#x27;    比较用用户ids列表    :param f: 字典    :return: 返回最大的用户id    &#x27;&#x27;&#x27;    return max(f[&#x27;user_ids&#x27;])friends_added = [        &#123;&#x27;user_ids&#x27;: [1, 2], &#x27;create_at&#x27;: &#x27;2020-01-01&#x27;&#125;,        &#123;&#x27;user_ids&#x27;: [3, 6], &#x27;create_at&#x27;: &#x27;2020-01-02&#x27;&#125;,        &#123;&#x27;user_ids&#x27;: [2, 1], &#x27;create_at&#x27;: &#x27;2020-02-02&#x27;&#125;,        &#123;&#x27;user_ids&#x27;: [4, 1], &#x27;create_at&#x27;: &#x27;2020-02-02&#x27;&#125;,    ]# max函数中使用key参数，指定自定义函数来比较item = max(friends_added, key=com_id)item_1 = max(friends_added, key=lambda f: max(f[&#x27;user_ids&#x27;])) # com_id可以转成lambda函数print(item)print(item_1)输出：&#123;&#x27;user_ids&#x27;: [3, 6], &#x27;create_at&#x27;: &#x27;2020-01-02&#x27;&#125;&#123;&#x27;user_ids&#x27;: [3, 6], &#x27;create_at&#x27;: &#x27;2020-01-02&#x27;&#125;\n\n117、django查询表的具体字段ExampleModel.objects.values(&#x27;id&#x27;, &#x27;username&#x27;)# 返回的结果是QuerySet， 里面的元素是dict格式# [&#123;&#x27;id&#x27;:1, &#x27;username&#x27;: &#x27;Austin&#x27;&#125;, &#123;&#x27;id&#x27;:2, &#x27;username&#x27;:&#x27;Sam&#x27;&#125;, ...]# 相当于SQL中的SELECT id, username FROM ......, # 只返回对应属性（字段）的值\n\n118、MySQL查询数据添加自增序号set @i = 0;select waveform, &#x27;沿桥风吹&#x27; as label ,(@i:=@i+1) xh from alert_message where is_real=1 and node_id=138\n\n119、MySQL 时间截取年月日select id,\t\t\taddtime, \t\t\tdate_format(addtime,&#x27;%Y-%m-%d&#x27;) as short_time \tfrom alert_message \twhere date_format(addtime,&#x27;%Y-%m-%d&#x27;) = &#x27;2022-03-13&#x27;\n\n\n120、 列表取奇数下标值list1=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;]print(&#x27;奇数下标值&#x27;,list1[1::2])输出：奇数下标值 [&#x27;b&#x27;, &#x27;d&#x27;]\n\n121、列表取偶数下标值list1=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;]print(&#x27;偶数下标值&#x27;,list1[::2])偶数下标值 [&#x27;a&#x27;, &#x27;c&#x27;, &#x27;e&#x27;]\n\n122、列表相同元素分类、分组import itertoolsdata = [1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 1, &#x27;a&#x27;, &#x27;a&#x27;]a =[list(group) for key, group in itertools.groupby(data)]print(a)输出：[[1], [2, 2, 2, 2], [3, 3, 3], [4, 4, 4, 4], [1], [&#x27;a&#x27;, &#x27;a&#x27;]]\n\n123、ubuntu切换用户1）从user用户切换到root用户sudo su2）从root用户切回user用户su user (user是你自己安装时候的用户名)，或是直接输入exit，也可Ctrl+D组合键推出\n124、numpy二维数组获取某一列import numpy as npa = [    [1, 2, 3, 4, 5, 6],    [7, 8, 9, 10, 11, 12],    [13.2, 14.8, 15.9, 16.10, 16.11, 17.12],]a_np = np.array(a)  # 把二维列表转成numpy数组print(&#x27;第一行&#x27;, a_np[0].tolist())  # 获取第一行print(&#x27;第一列&#x27;, a_np[:, 0].tolist())  # 获取第一列输出：第一行 [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]第一列 [1.0, 7.0, 13.2]\n\n\n","categories":["编程"],"tags":["编程","Python"]},{"title":"YOLOv10原理浅学","url":"/2025/10/09/YOLOv10%E5%8E%9F%E7%90%86%E6%B5%85%E5%AD%A6/","content":"神经网络常用\nYOLO（You Only Look Once）：\nYOLO 是一种实时目标检测系统，通过单个神经网络预测目标边界框和类别。\n网络结构借鉴了 GoogLeNet，包含 24 个卷积层和 2 个全连接层。\nYOLO 将输入图片分割成 S×S 网格，每个单元格负责检测中心点落在该格子内的目标。\n预测过程是 end-to-end 的，将图片 resize 到 448x448 大小，送入 CNN 网络，最后进行非极大值抑制处理得到结果12。\n\n\n其他神经网络\n多层感知器 (MLP)：拥有一个或多个隐藏层，可以学习非线性函数。\n前馈神经网络：信息从输入层传递到输出层，只有前向传播，没有反向传播或循环。\n反馈神经网络：具有循环连接，例如循环神经网络 (RNN) 和长短时记忆网络 (LSTM)3456.\n\n\n\n制作神经网路：\n从零开始手写神经网络\n如果你想深入了解神经网络的底层原理，可以从零开始手写一个简单的多层感知机（Multilayer Perceptron，MLP）。\n这个过程涉及到定义神经网络的结构、实现前向传播和反向传播，以及使用梯度下降算法进行训练。\n你可以使用Python和NumPy库来实现这个过程，从而更好地理解神经网络的工作原理1.\n\n\n使用深度学习框架：\n如果你想更快地构建神经网络，可以使用流行的深度学习框架，例如TensorFlow或PyTorch。\n这些框架提供了高级API，可以简化神经网络的搭建、训练和评估过程。\n例如，你可以使用TensorFlow的tf.keras模块来加载MNIST手写数字数据集，并构建一个数字识别神经网络2.\n\n\n\n全向神经网路全连接神经网络（Fully Connected Neural Network，简称FCNN）是一种基础的人工神经网络结构，其中每个神经元与前一层和后一层的所有神经元相连接。本文将详细介绍全连接神经网络的基本原理、网络结构以及实际应用场景，帮助读者深入理解全连接神经网络。\n一、什么是全连接神经网络（FCNN）全连接神经网络（Fully Connected Neural Network，简称FCNN）是一种最基础的人工神经网络结构，也称为多层感知器（Multilayer Perceptron，MLP）。在全连接神经网络中，每个神经元都与前一层和后一层的所有神经元相连接，形成一个密集的连接结构。全连接神经网络能够学习输入数据的复杂特征，并进行分类、回归等任务。\n二、全连接神经网络的结构\n输入层：输入层负责接收原始数据，并将其传递给下一层。输入层的神经元数量取决于输入数据的维度。\n隐藏层：隐藏层是全连接神经网络中的中间层，可以有多个。隐藏层的神经元数量可以自由设定，每个神经元都与前一层和后一层的所有神经元相连接。\n输出层：输出层是全连接神经网络的最后一层，负责输出网络的预测结果。输出层的神经元数量取决于任务的类型，例如二分类任务的输出层通常有一个神经元，多分类任务的输出层有多个神经元。\n激活函数：激活函数用于引入非线性因素，使得神经网络能够拟合复杂的非线性关系。常见的激活函数有ReLU、Sigmoid、Tanh等。\n\n三、全连接神经网络的应用场景\n图像分类：全连接神经网络可以用于图像分类任务，通过学习图像的特征进行类别判断。\n文本分类：全连接神经网络也可以应用于自然语言处理任务，例如文本分类、情感分析等。\n回归预测：全连接神经网络可以用于回归任务，例如房价预测、股票价格预测等。\n\n四、总结全连接神经网络是人工神经网络中的一种基础结构，具有灵活的网络结构和广泛的应用场景。虽然全连接神经网络在某些复杂数字信号处理任务上可能不如卷积神经网络（CNN）和循环神经网络（RNN）表现出色，但它仍然是深度学习领域的基础知识之一，值得深入学习和掌握。\n​      \nYolo概述1. YOLOv10项目:\n论文：YOLOv10\n代码：GitHub - THU-MIG&#x2F;yolov10\n\n2. 改进和优化:\n无NMS训练：YOLOv10采用了持续双重分配，避免了后处理的非最大抑制（NMS），从而降低了推理延迟。\n效率驱动的模型设计：YOLOv10对组件进行了全面优化，包括轻量级分类头、空间-通道解耦下采样和基于rank引导的模块设计。\n基于精度的模型设计：使用大核卷积和部分自注意力（PSA）来提高感受野和模型能力。\n\n3. 性能和效率:\n在COCO数据集上，YOLOv10在各种模型规模上实现了最先进的性能和效率。\n例如，YOLOV10-S相比RT-DETR-R18快1.8倍，同时具有2.8倍更少的参数和FLOPS。\n\nYolo原理1. 网络结构：\nYOLOv10 的网络结构与 YOLOv8 相似，但在一些细节模块上有所改进。它包括以下部分：\nBackbone：用于特征提取的骨干网络。\nHead：负责预测目标框和类别得分。\n\n\nYOLOv10m 模型的结构稍有不同，不同尺度的模型在结构上也有所区别。\n\n2. 预测后处理：\nYOLOv10 在预测阶段不需要使用非极大值抑制（NMS）来去除重叠的框。这一功能是通过训练来实现的。\n网络实际上包含两个 Head：One-to-many Head 和 One-to-one Head。在训练时，两个 Head 同时参与，而在推理预测时只需要 One-to-one Head。\n后处理流程如下：\n首先，根据每个 Anchor 最高的分类得分，对 Anchor 进行排序，取前 max_det&#x3D;300 个 Anchor。\n然后，对这 300 个 Anchor 的 80 类分类得分再做一次排序，取前 max_det&#x3D;300 个。\n这个过程相当于直接将所有得分较高的 300 个结果作为检测结果，但由于使用 Sigmoid 而非 Softmax 计算得分，可能会得到两个 Anchor 相同位置大小但类别不同的框。\n\n\n\n3. 训练策略：\nYOLOv10 在训练中对 One-to-many Head 和 One-to-one Head 两个头的输出都计算损失，损失函数与 YOLOv8 相同。\n通过消除 NMS 并优化模型组件，YOLOv10 在降低计算开销的同时实现了最先进的性能12。\n\nYolo简易理论理解YOLO（You Only Look Once）是一种用于实时物体检测的算法，它可以在单次前向传播中完成物体检测任务。为了通俗易懂地解释YOLO的算法原理，可以将其分解为以下几个关键步骤：\n1. 输入图像YOLO从一张输入图像开始，假设这是一张包含多个物体的图片。\n2. 划分网格YOLO将输入图像划分为一个SxS的网格。例如，如果S&#x3D;7，那么图像会被划分成49个小方格。\n3. 每个网格预测对于每个网格单元，YOLO会预测：\n\nB个边界框（Bounding Boxes），每个边界框包含：\n位置（x, y）：框的中心相对于网格单元的位置\n宽度和高度（w, h）：框的尺寸，相对于整张图像的比例\n置信度（Confidence）：表示该框中是否包含物体以及框的准确程度\n\n\nC个类别概率（Class Probabilities），表示该网格单元包含的物体属于每个类别的概率。\n\n4. 计算最终预测每个网格单元的预测结果组合起来，形成最终的物体检测结果。YOLO会根据置信度和类别概率，筛选出最可能的物体边界框。\n5. 非极大值抑制（NMS）为了避免多个边界框重叠检测同一个物体，YOLO使用非极大值抑制来过滤掉置信度较低的重复检测框，只保留最有可能的边界框。\n6. 输出结果最终，YOLO输出的是图像中所有检测到的物体的边界框及其类别标签。\n例子：假设有一张图片，其中有一只猫和一只狗。YOLO会将这张图片划分成多个小网格。每个网格会预测多个边界框以及这些边界框中是否包含物体和物体的类别。经过置信度筛选和非极大值抑制，YOLO最终可能会输出两个边界框，一个框住猫并标记为“猫”，另一个框住狗并标记为“狗”。\n通过这种方式，YOLO能够高效地进行实时物体检测。由于它只需要一次前向传播就能完成整个检测过程，所以被称为“只看一次”（You Only Look Once）。\n","categories":["深度学习"],"tags":["目标检测","YOLO"]},{"title":"【解决办法】树莓派系统使用PIP安装ultralytics失败","url":"/2025/10/09/%E3%80%90%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E3%80%91%E6%A0%91%E8%8E%93%E6%B4%BE%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8PIP%E5%AE%89%E8%A3%85ultralytics%E5%A4%B1%E8%B4%A5/","content":"树莓派系统使用PIP安装ultralytics失败，解决办法：虚拟环境smp4bu@raspberrypi:~ $ pip install ultralytics[export]error: externally-managed-environment× This environment is externally managed╰─&gt; To install Python packages system-wide, try apt install    python3-xyz, where xyz is the package you are trying to    install.    If you wish to install a non-Debian-packaged Python package,    create a virtual environment using python3 -m venv path/to/venv.    Then use path/to/venv/bin/python and path/to/venv/bin/pip. Make    sure you have python3-full installed.    For more information visit http://rptl.io/venvnote: If you believe this is a mistake, please contact your Python installation or OS distribution provider. You can override this, at the risk of breaking your Python installation or OS, by passing --break-system-packages.hint: See PEP 668 for the detailed specification.\n\n\n\n你遇到的错误信息表明你正在一个“外部管理的环境”中尝试安装 ultralytics 包。这是因为你的 Python 安装是通过操作系统的包管理工具（如 apt）进行管理的。\n解决方法1. 创建虚拟环境最推荐的解决方法是创建一个虚拟环境，这样你可以在其中自由安装和管理 Python 包，而不会影响系统级的 Python 安装。以下是具体步骤：\n\n安装 python3-venv（如果还没有安装）：\nsudo apt install python3-venv\n\n创建一个虚拟环境：\npython3 -m venv myenv\n这里 myenv 是你虚拟环境的名称，可以根据需要更改。\n\n激活虚拟环境：\nsource myenv/bin/activate\n\n安装 ultralytics 包：在虚拟环境激活后，你可以使用 pip 安装 ultralytics：\npip install ultralytics[export]\n\n使用虚拟环境：每次需要使用这个环境时，记得先激活它。使用完成后，可以通过 deactivate 命令退出虚拟环境。\n\n\n2. 使用系统包管理器（不推荐）如果你希望使用系统包管理器来安装某个特定的 Python 包，虽然不推荐，但你可以尝试使用 apt：\nsudo apt install python3-ultralytics\n请注意，这可能没有最新版本。\n3. 直接覆盖（不推荐）如果你非常确定要在系统环境中安装，可以使用 --break-system-packages 选项，但这样做风险较高，可能会导致系统不稳定：\npip install ultralytics[export] --break-system-packages\n\n总结创建虚拟环境是最安全和推荐的方式，它可以帮助你避免对系统环境造成影响，同时允许你自由地管理和安装 Python 包。\n","categories":["Linux"],"tags":["Linux","树莓派"]},{"title":"单链表(Singly Linked List)的完整实现与详解~","url":"/2025/10/24/%E5%8D%95%E9%93%BE%E8%A1%A8-Singly-Linked-List-%E7%9A%84%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0%E4%B8%8E%E8%AF%A6%E8%A7%A3/","content":"一、概述本文将详细解析一个完整的单链表实现程序，该程序包含了单链表的所有基本操作和一些高级操作。代码结构清晰，功能完善，适合数据结构学习和实践。\n二、基础定义模块2.1 宏定义与类型定义#define MAXSIZE 100 // 最大容量#define ERROR 0#define OK 1#define OVERFLOW (-1)#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;typedef int Status;\n\n功能说明：\n\n定义了程序中使用的常量和状态码\nStatus 类型用于表示操作是否成功\n\n2.2 链表节点结构typedef struct LNode&#123;    int data;           // 数据域    struct LNode *next; // 指针域&#125; LNode, *LinkList;\n\n结构说明：\n\ndata：存储节点数据\nnext：指向下一个节点的指针\nLNode：节点类型\nLinkList：链表指针类型（指向头节点）\n\n三、基础操作模块3.1 初始化链表Status InitList(LinkList &amp;L)&#123;    L = new LNode;      // 创建头节点    if (!L)        return OVERFLOW;    L-&gt;next = NULL;     // 头节点指针域置空    return OK;&#125;\n\n功能： 创建一个带头节点的空链表时间复杂度： O(1)\n3.2 创建链表（尾插法）void CreateList_Tail(LinkList &amp;L, int n)&#123;    if (L-&gt;next != NULL)    &#123;        cout &lt;&lt; &quot;链表已存在，请先清空或销毁链表！&quot; &lt;&lt; endl;        return;    &#125;        LinkList r = L;  // r指向尾节点    cout &lt;&lt; &quot;请依次输入&quot; &lt;&lt; n &lt;&lt; &quot;个数据：&quot; &lt;&lt; endl;    for (int i = 1; i &lt;= n; i++)    &#123;        LinkList p = new LNode;        cout &lt;&lt; &quot;第&quot; &lt;&lt; i &lt;&lt; &quot;个数据: &quot;;        cin &gt;&gt; p-&gt;data;        p-&gt;next = NULL;        r-&gt;next = p;     // 插入到尾部        r = p;           // r指向新的尾节点    &#125;    cout &lt;&lt; &quot;链表创建成功！&quot; &lt;&lt; endl;&#125;\n\n功能： 使用尾插法创建包含n个节点的链表优点： 保持输入顺序时间复杂度： O(n)\n3.3 获取链表长度int ListLength(LinkList L)&#123;    int length = 0;    LinkList p = L-&gt;next;  // 从第一个数据节点开始    while (p != NULL)    &#123;        length++;        p = p-&gt;next;    &#125;    return length;&#125;\n\n功能： 遍历链表统计节点个数时间复杂度： O(n)\n四、查找操作模块4.1 按位置获取元素Status GetElem(LinkList L, int i, int &amp;e)&#123;    LinkList p = L-&gt;next;    int j = 1;    while (p &amp;&amp; j &lt; i)  // 查找第i个节点    &#123;        p = p-&gt;next;        j++;    &#125;    if (!p || j &gt; i)    // 位置不合法        return ERROR;    e = p-&gt;data;        // 获取数据    return OK;&#125;\n\n功能： 获取第i个位置的元素值参数： i为位置（从1开始），e用于返回元素值时间复杂度： O(n)\n4.2 按值查找位置int LocateElem(LinkList L, int e)&#123;    LinkList p = L-&gt;next;    int position = 1;    while (p != NULL)    &#123;        if (p-&gt;data == e)            return position;        p = p-&gt;next;        position++;    &#125;    return 0;  // 未找到返回0&#125;\n\n功能： 查找值为e的元素在链表中的位置返回值： 找到返回位置，未找到返回0时间复杂度： O(n)\n五、修改操作模块5.1 插入元素Status ListInsert(LinkList &amp;L, int i, int e)&#123;    LinkList p = L;    int j = 0;    while (p &amp;&amp; j &lt; i - 1)  // 找到第i-1个节点    &#123;        p = p-&gt;next;        j++;    &#125;    if (!p || j &gt; i - 1)        return ERROR;        LinkList s = new LNode;  // 创建新节点    s-&gt;data = e;    s-&gt;next = p-&gt;next;       // 新节点指向后继    p-&gt;next = s;             // 前驱指向新节点    return OK;&#125;\n\n功能： 在第i个位置插入元素e步骤：\n\n找到第i-1个节点\n创建新节点\n修改指针完成插入\n\n时间复杂度： O(n)\n5.2 删除元素Status ListDelete(LinkList &amp;L, int i, int &amp;e)&#123;    LinkList p = L;    int j = 0;    while (p-&gt;next &amp;&amp; j &lt; i - 1)  // 找到第i-1个节点    &#123;        p = p-&gt;next;        j++;    &#125;    if (!(p-&gt;next) || j &gt; i - 1)        return ERROR;        LinkList q = p-&gt;next;    // q指向待删除节点    e = q-&gt;data;             // 保存数据    p-&gt;next = q-&gt;next;       // 修改指针    delete q;                // 释放内存    return OK;&#125;\n\n功能： 删除第i个位置的元素，并返回其值时间复杂度： O(n)\n5.3 清空链表void ClearList(LinkList &amp;L)&#123;    LinkList p, q;    p = L-&gt;next;    while (p != NULL)    &#123;        q = p;        p = p-&gt;next;        delete q;  // 释放节点    &#125;    L-&gt;next = NULL;  // 头节点指针置空&#125;\n\n功能： 删除所有数据节点，保留头节点时间复杂度： O(n)\n5.4 判断链表是否为空bool ListEmpty(LinkList L)&#123;    return L-&gt;next == NULL;&#125;\n\n功能： 判断链表是否为空时间复杂度： O(1)\n六、高级操作模块6.1 链表排序（选择排序）void Sort(LinkList &amp;L)&#123;    LinkList p, q, min;    for (p = L-&gt;next; p != NULL; p = p-&gt;next)    &#123;        min = p;  // 假设当前节点最小        for (q = p-&gt;next; q != NULL; q = q-&gt;next)        &#123;            if (q-&gt;data &lt; min-&gt;data)            &#123;                min = q;  // 更新最小节点            &#125;        &#125;        if (min != p)  // 交换数据        &#123;            int temp = p-&gt;data;            p-&gt;data = min-&gt;data;            min-&gt;data = temp;        &#125;    &#125;&#125;\n\n功能： 使用选择排序算法对链表升序排序时间复杂度： O(n²)空间复杂度： O(1)\n6.2 链表逆置void ReverseList(LinkList &amp;L)&#123;    if (L-&gt;next == NULL || L-&gt;next-&gt;next == NULL)        return;  // 空表或单节点无需逆置        LinkList pre = NULL;    LinkList cur = L-&gt;next;    LinkList next = NULL;        while (cur != NULL)    &#123;        next = cur-&gt;next;  // 保存后继        cur-&gt;next = pre;   // 反转指针        pre = cur;         // pre前移        cur = next;        // cur前移    &#125;    L-&gt;next = pre;  // 头节点指向新的第一个节点&#125;\n\n功能： 将链表节点顺序反转方法： 三指针法时间复杂度： O(n)空间复杂度： O(1)\n6.3 打印链表void PrintList(LinkList L)&#123;    if (L-&gt;next == NULL)    &#123;        cout &lt;&lt; &quot;链表为空！&quot; &lt;&lt; endl;        return;    &#125;    LinkList p = L-&gt;next;    cout &lt;&lt; &quot;链表内容: &quot;;    while (p != NULL)    &#123;        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;        p = p-&gt;next;    &#125;    cout &lt;&lt; endl;&#125;\n\n功能： 遍历并打印链表所有元素时间复杂度： O(n)\n七、用户交互模块7.1 菜单显示void ShowMenu()&#123;    cout &lt;&lt; &quot;\\n========== 单链表操作菜单 ==========&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;1. 创建链表&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;2. 插入元素&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;3. 删除元素&quot; &lt;&lt; endl;    // ... 其他菜单项    cout &lt;&lt; &quot;0. 退出程序&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;====================================&quot; &lt;&lt; endl;&#125;\n\n7.2 主函数主函数实现了一个交互式菜单系统，通过switch语句处理用户的各种操作请求：\nint main()&#123;    LinkList Head;    InitList(Head);  // 初始化链表        int choice, n, position, elem;    Status result;    ShowMenu();        while (true)    &#123;        cout &lt;&lt; &quot;请选择操作: &quot;;        cin &gt;&gt; choice;        switch (choice)        &#123;            case 1: // 创建链表            case 2: // 插入元素            // ... 处理各种操作            case 0: // 退出程序                ClearList(Head);                delete Head;                return 0;        &#125;    &#125;&#125;\n\n八、总结8.1 程序特点\n结构完整：包含单链表的所有基本操作\n用户友好：提供交互式菜单界面\n错误处理：对非法操作进行检查和提示\n内存管理：正确处理动态内存的分配和释放\n\n8.2 时间复杂度总结\n\n\n操作\n时间复杂度\n\n\n\n初始化\nO(1)\n\n\n插入&#x2F;删除\nO(n)\n\n\n查找\nO(n)\n\n\n获取长度\nO(n)\n\n\n排序\nO(n²)\n\n\n逆置\nO(n)\n\n\n\n完整代码，可直接编译运行体验各项功能！\n#define MAXSIZE 100 // 最大容量#define ERROR 0#define OK 1#define OVERFLOW (-1)#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;typedef int Status;typedef struct LNode&#123;    int data;    struct LNode *next;&#125; LNode, *LinkList;// 初始化单链表Status InitList(LinkList &amp;L)&#123;    L = new LNode;    if (!L)        return OVERFLOW;    L-&gt;next = NULL;    return OK;&#125;// 创建单链表（尾插法）void CreateList_Tail(LinkList &amp;L, int n)&#123;    if (L-&gt;next != NULL)    &#123;        cout &lt;&lt; &quot;链表已存在，请先清空或销毁链表！&quot; &lt;&lt; endl;        return;    &#125;        LinkList r = L;    cout &lt;&lt; &quot;请依次输入&quot; &lt;&lt; n &lt;&lt; &quot;个数据：&quot; &lt;&lt; endl;    for (int i = 1; i &lt;= n; i++)    &#123;        LinkList p = new LNode;        cout &lt;&lt; &quot;第&quot; &lt;&lt; i &lt;&lt; &quot;个数据: &quot;;        cin &gt;&gt; p-&gt;data;        p-&gt;next = NULL;        r-&gt;next = p;        r = p;    &#125;    cout &lt;&lt; &quot;链表创建成功！&quot; &lt;&lt; endl;&#125;// 获取链表长度int ListLength(LinkList L)&#123;    int length = 0;    LinkList p = L-&gt;next;    while (p != NULL)    &#123;        length++;        p = p-&gt;next;    &#125;    return length;&#125;// 按位置获取元素Status GetElem(LinkList L, int i, int &amp;e)&#123;    LinkList p = L-&gt;next;    int j = 1;    while (p &amp;&amp; j &lt; i)    &#123;        p = p-&gt;next;        j++;    &#125;    if (!p || j &gt; i)        return ERROR;    e = p-&gt;data;    return OK;&#125;// 按值查找位置int LocateElem(LinkList L, int e)&#123;    LinkList p = L-&gt;next;    int position = 1;    while (p != NULL)    &#123;        if (p-&gt;data == e)            return position;        p = p-&gt;next;        position++;    &#125;    return 0; // 未找到返回0&#125;// 在指定位置插入元素Status ListInsert(LinkList &amp;L, int i, int e)&#123;    LinkList p = L;    int j = 0;    while (p &amp;&amp; j &lt; i - 1)    &#123;        p = p-&gt;next;        j++;    &#125;    if (!p || j &gt; i - 1)        return ERROR;    LinkList s = new LNode;    s-&gt;data = e;    s-&gt;next = p-&gt;next;    p-&gt;next = s;    return OK;&#125;// 删除指定位置元素Status ListDelete(LinkList &amp;L, int i, int &amp;e)&#123;    LinkList p = L;    int j = 0;    while (p-&gt;next &amp;&amp; j &lt; i - 1)    &#123;        p = p-&gt;next;        j++;    &#125;    if (!(p-&gt;next) || j &gt; i - 1)        return ERROR;    LinkList q = p-&gt;next;    e = q-&gt;data;    p-&gt;next = q-&gt;next;    delete q;    return OK;&#125;// 清空链表void ClearList(LinkList &amp;L)&#123;    LinkList p, q;    p = L-&gt;next;    while (p != NULL)    &#123;        q = p;        p = p-&gt;next;        delete q;    &#125;    L-&gt;next = NULL;&#125;// 判断链表是否为空bool ListEmpty(LinkList L)&#123;    return L-&gt;next == NULL;&#125;// 单链表的简单选择排序void Sort(LinkList &amp;L)&#123;    LinkList p, q, min;    for (p = L-&gt;next; p != NULL; p = p-&gt;next)    &#123;        min = p;        for (q = p-&gt;next; q != NULL; q = q-&gt;next)        &#123;            if (q-&gt;data &lt; min-&gt;data)            &#123;                min = q;            &#125;        &#125;        if (min != p)        &#123;            int temp = p-&gt;data;            p-&gt;data = min-&gt;data;            min-&gt;data = temp;        &#125;    &#125;&#125;// 链表逆置void ReverseList(LinkList &amp;L)&#123;    if (L-&gt;next == NULL || L-&gt;next-&gt;next == NULL)        return;        LinkList pre = NULL;    LinkList cur = L-&gt;next;    LinkList next = NULL;        while (cur != NULL)    &#123;        next = cur-&gt;next;        cur-&gt;next = pre;        pre = cur;        cur = next;    &#125;    L-&gt;next = pre;&#125;// 打印链表void PrintList(LinkList L)&#123;    if (L-&gt;next == NULL)    &#123;        cout &lt;&lt; &quot;链表为空！&quot; &lt;&lt; endl;        return;    &#125;    LinkList p = L-&gt;next;    cout &lt;&lt; &quot;链表内容: &quot;;    while (p != NULL)    &#123;        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;        p = p-&gt;next;    &#125;    cout &lt;&lt; endl;&#125;// 显示菜单void ShowMenu()&#123;    cout &lt;&lt; &quot;\\n========== 单链表操作菜单 ==========&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;1. 创建链表&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;2. 插入元素&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;3. 删除元素&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;4. 查找元素（按值）&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;5. 获取元素（按位置）&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;6. 获取链表长度&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;7. 打印链表&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;8. 排序链表&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;9. 逆置链表&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;10. 清空链表&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;11. 判断链表是否为空&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;0. 退出程序&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;====================================&quot; &lt;&lt; endl;&#125;int main()&#123;    LinkList Head;    InitList(Head);        int choice, n, position, elem;    Status result;    ShowMenu(); //显示菜单    while (true)    &#123;        cout &lt;&lt; &quot;请选择操作: &quot;;        cin &gt;&gt; choice;        switch (choice)        &#123;        case 1: // 创建链表            cout &lt;&lt; &quot;请输入要创建的链表长度: &quot;;            cin &gt;&gt; n;            if (n &lt;= 0)            &#123;                cout &lt;&lt; &quot;长度必须大于0！&quot; &lt;&lt; endl;                break;            &#125;            CreateList_Tail(Head, n);            break;                    case 2: // 插入元素            cout &lt;&lt; &quot;请输入插入位置: &quot;;            cin &gt;&gt; position;            cout &lt;&lt; &quot;请输入插入的元素值: &quot;;            cin &gt;&gt; elem;            result = ListInsert(Head, position, elem);            if (result == OK)                cout &lt;&lt; &quot;插入成功！&quot; &lt;&lt; endl;            else                cout &lt;&lt; &quot;插入失败！位置不合法。&quot; &lt;&lt; endl;            break;                    case 3: // 删除元素            cout &lt;&lt; &quot;请输入要删除的位置: &quot;;            cin &gt;&gt; position;            result = ListDelete(Head, position, elem);            if (result == OK)                cout &lt;&lt; &quot;删除成功！删除的元素为: &quot; &lt;&lt; elem &lt;&lt; endl;            else                cout &lt;&lt; &quot;删除失败！位置不合法。&quot; &lt;&lt; endl;            break;                    case 4: // 查找元素            cout &lt;&lt; &quot;请输入要查找的元素值: &quot;;            cin &gt;&gt; elem;            position = LocateElem(Head, elem);            if (position != 0)                cout &lt;&lt; &quot;元素 &quot; &lt;&lt; elem &lt;&lt; &quot; 在第 &quot; &lt;&lt; position &lt;&lt; &quot; 个位置&quot; &lt;&lt; endl;            else                cout &lt;&lt; &quot;未找到元素 &quot; &lt;&lt; elem &lt;&lt; endl;            break;                    case 5: // 获取元素            cout &lt;&lt; &quot;请输入要获取的位置: &quot;;            cin &gt;&gt; position;            result = GetElem(Head, position, elem);            if (result == OK)                cout &lt;&lt; &quot;第 &quot; &lt;&lt; position &lt;&lt; &quot; 个位置的元素为: &quot; &lt;&lt; elem &lt;&lt; endl;            else                cout &lt;&lt; &quot;获取失败！位置不合法。&quot; &lt;&lt; endl;            break;                    case 6: // 获取长度            cout &lt;&lt; &quot;链表长度为: &quot; &lt;&lt; ListLength(Head) &lt;&lt; endl;            break;                    case 7: // 打印链表            PrintList(Head);            break;                    case 8: // 排序            if (ListEmpty(Head))            &#123;                cout &lt;&lt; &quot;链表为空，无法排序！&quot; &lt;&lt; endl;            &#125;            else            &#123;                Sort(Head);                cout &lt;&lt; &quot;排序完成！&quot; &lt;&lt; endl;                PrintList(Head);            &#125;            break;                    case 9: // 逆置            if (ListEmpty(Head))            &#123;                cout &lt;&lt; &quot;链表为空，无法逆置！&quot; &lt;&lt; endl;            &#125;            else            &#123;                ReverseList(Head);                cout &lt;&lt; &quot;逆置完成！&quot; &lt;&lt; endl;                PrintList(Head);            &#125;            break;                    case 10: // 清空链表            ClearList(Head);            cout &lt;&lt; &quot;链表已清空！&quot; &lt;&lt; endl;            break;                    case 11: // 判断是否为空            if (ListEmpty(Head))                cout &lt;&lt; &quot;链表为空&quot; &lt;&lt; endl;            else                cout &lt;&lt; &quot;链表不为空，长度为: &quot; &lt;&lt; ListLength(Head) &lt;&lt; endl;            break;                    case 0: // 退出            ClearList(Head);            delete Head;            cout &lt;&lt; &quot;程序已退出，感谢使用！&quot; &lt;&lt; endl;            return 0;                    default:            cout &lt;&lt; &quot;无效的选择，请重新输入！&quot; &lt;&lt; endl;            break;        &#125;    &#125;        return 0;&#125;","categories":["数据结构"],"tags":["编程","数据结构"]},{"title":"我的第一个GitHub仓库","url":"/2025/10/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAGitHub%E4%BB%93%E5%BA%93/","content":"Code Circus 🎪我的代码马戏团 - 记录学习CS每一步的代码仓库\n🎯 项目徽章\n🎪 马戏团大帐🎩 核心内容├── 📖 教材实践│   ├── 🎒 课堂练习│   └── 🏡 课后习题├── 🔬 实验报告│   └── 📦 各学期实验存档  \n🎭 专项训练├── 🏆 算法竞技场│   ├── 🥇 蓝桥杯真题│   └── 🥈 LeetCode精选  \n🎨 创意工坊├── ✨ 代码片段│   ├── 💡 灵感实现│   └── 🎁 实用工具  \n🚀 技术飞轮\n🌟 马戏团特色\n🎯 多语言学习路径：C&#x2F;C++ → Java → Python → ASM 的渐进式学习\n🧠 知识图谱：语法基础 → 数据结构 → 算法实战 → 系统设计\n📝 注释规范：每个案例含「实现思路」「复杂度分析」「应用场景」注释\n🚴 持续更新：代码练习 + 学习笔记\n\nStar History\n \n  \n\n“The magic of myth and legend has come true in our generation.With the right spell on the keyboard, the display comes alive,full of things that couldn’t have existed or happened before.”  \n—— Frederick Brooks《人月神话》\n","categories":["Git"],"tags":["编程","日常","Github"]},{"title":"数据结构英文术语对照","url":"/2025/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%8B%B1%E6%96%87%E6%9C%AF%E8%AF%AD%E5%AF%B9%E7%85%A7/","content":"概述 (Overview)\n数据结构 - Data Structure (DS)\n算法 - Algorithm (Algo)\n抽象数据类型 - Abstract Data Type (ADT)\n存储结构 - Storage Structure (SS)\n空间复杂度 - Space Complexity (SC)\n时间复杂度 - Time Complexity (TC)\n渐进符号 - Asymptotic Notation (Big-O, Θ, Ω)\n最好情况 - Best Case (BC)\n最坏情况 - Worst Case (WC)\n平均情况 - Average Case (AC)\n\n线性表 (Linear List)\n线性表 - Linear List (LL)\n顺序表 - Sequential List (SeqList)\n单链表 - Singly Linked List (SLL)\n双链表 - Doubly Linked List (DLL)\n循环链表 - Circular Linked List (CLL)\n静态链表 - Static Linked List (StaticLL)\n线性表的顺序存储结构 - Sequential Storage Structure of Linear List (SeqStorage)\n线性表的链式存储结构 - Linked Storage Structure of Linear List (LinkedStorage)\n线性表的基本操作 - Basic Operations of Linear List (Insert, Delete, Search, Update)\n头节点 - Head Node (head)\n尾节点 - Tail Node (tail)\n前驱节点 - Predecessor Node (prev)\n后继节点 - Successor Node (next)\n\n栈、队列、数组 (Stack, Queue, Array)\n栈 - Stack (stk)\n队列 - Queue (que&#x2F;q)\n数组 - Array (arr)\n顺序栈 - Sequential Stack (SeqStack)\n链栈 - Linked Stack (LinkedStack&#x2F;LStack)\n顺序队列 - Sequential Queue (SeqQueue)\n循环队列 - Circular Queue (CircQueue&#x2F;CQ)\n链队列 - Linked Queue (LinkedQueue&#x2F;LQueue)\n双端队列 - Double-Ended Queue (Deque)\n优先队列 - Priority Queue (PQ)\n稀疏矩阵 - Sparse Matrix (SpMatrix)\n矩阵的压缩存储 - Compressed Storage of Matrix (CompMatrix)\n栈顶指针 - Top Pointer (top)\n队头指针 - Front Pointer (front)\n队尾指针 - Rear Pointer (rear)\n多维数组 - Multi-Dimensional Array (MDArray)\n\n串 (String)\n串 - String (str&#x2F;s)\n子串 - Substring (substr)\n串的存储结构 - Storage Structure of String (StrStorage)\n串的模式匹配 - String Pattern Matching (PatternMatch)\nKMP算法 - Knuth-Morris-Pratt Algorithm (KMP)\nBM算法 - Boyer-Moore Algorithm (BM)\nSunday算法 - Sunday Algorithm\nTrie树 - Trie Tree &#x2F; Prefix Tree (Trie)\n字典树 - Dictionary Tree (DictTree)\n后缀数组 - Suffix Array (SA)\n后缀树 - Suffix Tree (ST)\nnext数组 - Next Array (next[])\n主串 - Main String (mainStr)\n模式串 - Pattern String (pattern&#x2F;pat)\n\n树 (Tree)\n树 - Tree (T)\n二叉树 - Binary Tree (BT)\n满二叉树 - Full Binary Tree (FBT)\n完全二叉树 - Complete Binary Tree (CBT)\n平衡二叉树 - Balanced Binary Tree &#x2F; AVL Tree (AVL)\n二叉搜索树 - Binary Search Tree (BST)\n二叉树的存储结构 - Storage Structure of Binary Tree (BTStorage)\n二叉树的遍历 - Traversal of Binary Tree (Traversal)\n前序遍历 - Preorder Traversal (PreOrder)\n中序遍历 - Inorder Traversal (InOrder)\n后序遍历 - Postorder Traversal (PostOrder)\n层序遍历 - Level Order Traversal (LevelOrder)\n线索二叉树 - Threaded Binary Tree (TBT)\n哈夫曼树 - Huffman Tree &#x2F; Optimal Binary Tree (HuffmanTree)\n哈夫曼编码 - Huffman Coding (HuffmanCode)\n红黑树 - Red-Black Tree (RBT)\n根节点 - Root Node (root)\n叶节点 - Leaf Node (leaf)\n左子树 - Left Subtree (lchild&#x2F;left)\n右子树 - Right Subtree (rchild&#x2F;right)\n树的高度 - Height of Tree (height&#x2F;h)\n树的深度 - Depth of Tree (depth&#x2F;d)\n\n图 (Graph)\n图 - Graph (G)\n有向图 - Directed Graph (Digraph&#x2F;DG)\n无向图 - Undirected Graph (UG)\n加权图 - Weighted Graph (WG)\n邻接矩阵 - Adjacency Matrix (AdjMatrix&#x2F;AM)\n邻接表 - Adjacency List (AdjList&#x2F;AL)\n图的存储结构 - Storage Structure of Graph (GraphStorage)\n图的遍历 - Traversal of Graph (GraphTraversal)\n深度优先搜索 - Depth-First Search (DFS)\n广度优先搜索 - Breadth-First Search (BFS)\n最小生成树 - Minimum Spanning Tree (MST)\nPrim算法 - Prim’s Algorithm (Prim)\nKruskal算法 - Kruskal’s Algorithm (Kruskal)\n最短路径 - Shortest Path (SP)\nDijkstra算法 - Dijkstra’s Algorithm (Dijkstra)\nFloyd算法 - Floyd-Warshall Algorithm (Floyd)\nBellman-Ford算法 - Bellman-Ford Algorithm (BF)\n拓扑排序 - Topological Sorting (TopSort)\n关键路径 - Critical Path (CP)\n顶点 - Vertex (V&#x2F;v)\n边 - Edge (E&#x2F;e)\n度 - Degree (deg)\n入度 - In-Degree (indeg)\n出度 - Out-Degree (outdeg)\n连通图 - Connected Graph (CG)\n强连通图 - Strongly Connected Graph (SCG)\n\n搜索 (Search)\n搜索&#x2F;查找 - Search (search)\n顺序查找 - Sequential Search &#x2F; Linear Search (SeqSearch)\n二分查找 - Binary Search (BinSearch&#x2F;BS)\n插值查找 - Interpolation Search (InterpSearch)\n斐波那契查找 - Fibonacci Search (FibSearch)\n哈希查找 - Hash Search (HashSearch)\n哈希表 - Hash Table (HashTable&#x2F;HT)\n哈希函数 - Hash Function (HashFunc)\n冲突解决 - Collision Resolution (CR)\n链地址法 - Chaining &#x2F; Separate Chaining (Chain)\n开放定址法 - Open Addressing (OA)\n平衡二叉树 - Balanced Binary Tree &#x2F; AVL Tree (AVL)\nB树 - B-Tree (BTree)\nB+树 - B+ Tree (BPlusTree)\nB*树 - B* Tree (BStarTree)\nAVL树 - AVL Tree (AVL)\n红黑树 - Red-Black Tree (RBT)\n跳表 - Skip List (SkipList)\n布隆过滤器 - Bloom Filter (BF)\n\n排序 (Sorting)\n排序 - Sorting (sort)\n冒泡排序 - Bubble Sort (BubbleSort)\n选择排序 - Selection Sort (SelectSort)\n插入排序 - Insertion Sort (InsertSort)\n希尔排序 - Shell Sort (ShellSort)\n归并排序 - Merge Sort (MergeSort)\n快速排序 - Quick Sort (QuickSort&#x2F;QSort)\n堆排序 - Heap Sort (HeapSort)\n计数排序 - Counting Sort (CountSort)\n基数排序 - Radix Sort (RadixSort)\n桶排序 - Bucket Sort (BucketSort)\n内部排序 - Internal Sorting (InternalSort)\n外部排序 - External Sorting (ExternalSort)\n稳定排序 - Stable Sorting (StableSort)\n不稳定排序 - Unstable Sorting (UnstableSort)\n比较排序 - Comparison Sort (CompSort)\n非比较排序 - Non-Comparison Sort (NonCompSort)\n堆 - Heap (heap)\n最大堆 - Max Heap (MaxHeap)\n最小堆 - Min Heap (MinHeap)\n分治法 - Divide and Conquer (D&amp;C)\n枢轴元素 - Pivot Element (pivot)\n\n","categories":["数据结构"],"tags":["编程","数据结构"]},{"title":"第十四届蓝桥杯第二期模拟赛题解","url":"/2025/10/12/%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AC%AC%E4%BA%8C%E6%9C%9F%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/","content":"第十四届蓝桥杯第二期模拟赛题解A题(填空题)题面请找到一个大于 2022 的最小数，这个数转换成二进制之后，最低的 6 个二进制为全为 0 。请将这个数的十进制形式作为答案提交。\n算法(枚举)直接枚举即可。更新：本题应该是只需要低六位都为0即可，一开始在做的时候以为第7位应该不能为0。\n代码(C++)答案：2112（正解：2048）\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;string get(int x)&#123;string s;while(x)&#123;s += x % 2 + &#x27;0&#x27;;x /= 2;&#125;if(s[0] == s[1] &amp;&amp; s[1] == s[2] &amp;&amp; s[2] == s[3]&amp;&amp; s[3] == s[4] &amp;&amp; s[4] == s[5] &amp;&amp; s[0] == &#x27;0&#x27;)&#123;cout &lt;&lt; &quot;res&quot;;&#125;reverse(s.begin(), s.end());return s;&#125;int get_res(string s)&#123;int res = 0;for(int i = 0; i &lt; s.size(); i ++) res = res * 2 + s[i] - &#x27;0&#x27;;cout &lt;&lt; res &lt;&lt; endl;return res;&#125;int main()&#123;// string s;//// int x = 2022;// while(x)// &#123;// s += x % 2 + &#x27;0&#x27;;// x /= 2;// &#125;//// for(int i = 2023; i &lt;= 10000; i ++)// cout &lt;&lt; get(i) &lt;&lt; endl;// 100001000000get_res(&quot;100000000000&quot;);// reverse(s.begin(), s.end());// cout &lt;&lt; s &lt;&lt; endl;return 0;&#125;\nB题(填空题)题面我们计从 1949 年 10 月 1 日至 1949 年 10 月 2 日为经过了 1 天。请问从 1949 年 10 月 1 日至 2022 年 1 月 1 日经过了多少天？\n算法(模拟)模拟即可。\n代码(c++)答案：26390\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int months[12] = &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30&#125;;bool is_leapYear(int y)&#123;return y % 400 == 0 || (y % 100 != 0 &amp;&amp; y % 4 == 0);&#125;int get(int y, int m, int d)&#123;int res = d;for(int i = 1949; i &lt; y; i ++)if(is_leapYear(i)) res += 366;else res += 365;for(int i = 0; i &lt; m; i ++)res += months[i];if(m &gt; 2 &amp;&amp; is_leapYear(y)) res ++;return res;&#125;int main()&#123;cout &lt;&lt; get(2022, 1, 1) - get(1949, 10, 1) &lt;&lt; endl;return 0;&#125;\nC题(填空题)题面8518 是一个非常特殊的数，如果把这个数看成 16 进制数，它的值为 (8518)16&#x3D;8161616+51616+116+8&#x3D;34072，而 34072 正好是 8518 的整数倍。9558 也是这样一个数，当看成 16 进制时是 38232。其实长度为 1 的数 0 到 9 都满足看成 16 进制后是自己的整数倍（1倍）。请问，除开长度为 1 的数，最小的满足这样条件的数是多少？\n算法(枚举)枚举即可。\n代码(c++)答案：1038\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;bool check(int x)&#123;string s = to_string(x);int res = 0;for(int i = 0; i &lt; s.size(); i ++) res = res * 16 + s[i] - &#x27;0&#x27;;return res % x == 0;&#125;int main()&#123;int x = 10;while(true)&#123;if(check(x))&#123;cout &lt;&lt; x &lt;&lt; endl;break;&#125;x ++;&#125;return 0;&#125;\nD题(填空题)题面小蓝有一个 30 行 60 列的数字矩阵，矩阵中的每个数都是 0 到 9 之间的数字。现在小蓝想从这个矩阵的第一行第一列画一条折线到第 30 行 60 列，线只能沿水平向右走或竖直向下走，只能在有数字的地方拐弯。小蓝想知道，这样一条线经过的数字的和最大是多少。\n\n本题的输入在文章底部。\n\n算法(线性DP)线性DP，状态计算为：$f[i,j]&#x3D;max(max(f[i - 1][j], f[i][j - 1])) + v$，$v$是该点的权值。答案为$f[30][60]$。\n代码(c++)答案：592\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 35, M = 65;int n = 30, m = 60;char g[N][M];int f[N][M];int main()&#123;for(int i = 1; i &lt;= n; i ++) scanf(&quot;%s&quot;, g[i] + 1);// cout &lt;&lt; &quot;?&quot; &lt;&lt; endl;for(int i = 1; i &lt;= n; i ++)for(int j = 1; j &lt;= m; j ++)&#123;f[i][j] = max(f[i - 1][j], f[i][j - 1]) + g[i][j] - &#x27;0&#x27;;&#125;cout &lt;&lt; f[n][m] &lt;&lt; endl;return 0;&#125;\nE题(填空题)题面将 2022 拆分成不同的质数的和，请问最多拆分成几个？\n算法(判断质数,01背包求方案数)可以通过枚举$2$到$2022$间的数，对于每个数判断一下是否是质数(共307个)，也可以用线性筛求解质数，接下来本题的意思就是在一堆质数中选取最多的质数个数来凑成2022，并且每一个质数只能选一次，直接上01背包的板子即可，但是需要注意，最终还需求解方案数，01背包的方案数求解就是最终的状态是通过哪一步得来的，一直往前找，一直到最开始的状态，这期间所经历得到状态个数就是答案。\n代码(C++)答案：32\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 2100;int n = 307, m = 2022;int cnt = 0;int primes[N];bool st[N];int f[310][N];void get_primes(int n)&#123;for(int i = 2; i &lt;= n; i ++)&#123;if(!st[i])&#123;primes[++ cnt] = i;for(int j = i + i; j &lt;= n; j += i) st[j] = true;&#125;&#125;&#125;int main()&#123;get_primes(2022);for(int i = 1; i &lt;= n; i ++)for(int j = 2; j &lt;= m; j ++)&#123;if(primes[i] &lt;= j)&#123;f[i][j] = max(f[i - 1][j], f[i - 1][j - primes[i]] + primes[i]);&#125;else f[i][j] = f[i - 1][j];&#125;int j = m, res = 0;for(int i = n; i; i --)if(f[i][j] != f[i - 1][j]) &#123;j -= primes[i];res ++;cout &lt;&lt; primes[i] &lt;&lt; &#x27; &#x27;;&#125;puts(&quot;&quot;);// cout &lt;&lt; f[n][m] &lt;&lt; endl;cout &lt;&lt; res &lt;&lt; endl;return 0;&#125;\nF题题面小蓝正在拷贝一份文件，他现在已经拷贝了 t 秒时间，已经拷贝了 c 字节，文件总共有 s 字节，如果拷贝是匀速进行的，请问小蓝大概还需要拷贝多少秒？\n输入格式输入一行包含三个整数 t, c, s，相邻两个整数之间用一个空格分隔。\n输出格式输出一个整数，表示答案。数据保证答案正好是整数。\n数据范围对于 50% 的评测用例，1 &lt;&#x3D; t, c, s &lt;&#x3D; 10000。对于所有评测用例，1 &lt;&#x3D; t, c, s &lt;&#x3D; 1000000000。\n算法(模拟)模拟即可，对于通过求解速度$v&#x3D;c&#x2F;t$的方式来解答本题会在样例$2$就RE了，具体就是$c&#x2F;t$的计算方式会导致其值为0，导致程序中出现除0的代码行，不妨将整个式子写下来，即$answer&#x3D;(s-c)&#x2F;(c&#x2F;t)&#x3D;(s-c)\\times t&#x2F;c$，题目保证答案一定为整数，只需注意数据范围最大为$1e9$，分子相乘会爆$int$，需要用$long\\ long$来表示答案。\n代码(C++)#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int t, c, s;// (s - c) * t / c// 1000000000 big dataint main()&#123;scanf(&quot;%d%d%d&quot;, &amp;t, &amp;c, &amp;s);printf(&quot;%lld\\n&quot;, (s - c) * 1ll * t / c);return 0;&#125;\nG题题面小蓝有 n 个单词，但是单词中有一些是重复的，请帮小蓝去除重复的单词。\n输入格式输入第一行包含一个正整数 n ，表示小蓝的单词数量。接下来 n 行，每行包含一个由小写字母组成的单词。\n输出格式请输出去除重复后的那些单词。如果一个单词出现了多遍，请保留第一次出现的单词，去除之后出现的单词，按输入的顺序输出。\n数据范围对于所有评测用例，1 &lt;&#x3D; n &lt;&#x3D; 100，每个单词的长度不超过 100。\n算法(哈希表)读取数据后，按顺序输出，在输出判断当前字符串是否输出过，没有出现过则输出一行后换行，否则跳过，再在哈希表中存下当前的字符串，在C++中可用$unordered\\underline{~}map$来当作哈希表使用。\n代码(C++)#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;using namespace std;const int N = 110;int n;string words[N];unordered_map&lt;string, int&gt; mp;int main()&#123;cin &gt;&gt; n;for(int i = 0; i &lt; n; i ++)&#123;cin &gt;&gt; words[i];// mp[words[i]] ++ ;&#125;for(int i = 0; i &lt; n; i ++)&#123;string s = words[i];if(!mp.count(s)) cout &lt;&lt; s &lt;&lt; endl;mp[s] ++ ;&#125;return 0;&#125;\nH题题面一个字符串如果从左向右读和从右向左读相同，则称为一个回文串，例如 lanqiaoaiqnal 是一个回文串。小蓝有一个字符串，请将这个字符串右边加上一些字符，使其成为一个回文串。如果有多种方案，请输出最短的回文串。\n输入格式输入一行包含一个字符串，由小写英文字母组成。\n输出格式输出一行包含答案。\n数据范围对于所有评测用例，1 &lt;&#x3D; 字符串长度 &lt;&#x3D; 100。\n算法(贪心,双指针)枚举字符串中最长的回文后缀即可，枚举出来后，此时的前缀（可能为空）进行反转后就是应当加在最开始字符串的后面，输出答案即可。\n代码(C++)#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int n;string s;bool check(string s)&#123;int i = 0, j = s.size() - 1;while(i &lt; j)if(s[i ++] != s[j --])return false;return true;&#125;int main()&#123;cin &gt;&gt; s;n = s.size();for(int i = 0, len = n; i &lt; n; i ++, len --)&#123;string t = s.substr(i, len);if(check(t))&#123;string prev = s.substr(0, i);string post = prev;if(prev.size())&#123;reverse(post.begin(), post.end());cout &lt;&lt; prev + t + post &lt;&lt; endl;return 0;&#125;else&#123;cout &lt;&lt; t &lt;&lt; endl;return 0;&#125;&#125;&#125;return 0;&#125;\nI题题面给定一个字母矩阵。一个 X 图形由中心点和由中心点向四个45度斜线方向引出的直线段组成，四条线段的长度相同，而且四条线段上的字母和中心点的字母相同。　　一个 X图形可以使用三个整数 r, c, L 来描述，其中 r, c 表示中心点位于第 r 行第 c 列，正整数 L 表示引出的直线段的长度。 对于 1 到 L 之间的每个整数 i，X图形满足：第 r-i 行第 c-i 列与第 r 行第 c 列相同，第 r-i 行第 c+i 列与第 r 行第 c 列相同，第 r+i 行第 c-i 列与第 r 行第 c 列相同，第 r+i 行第 c+i 列与第 r 行第 c 列相同。　　例如，对于下面的字母矩阵中，所有的字母 L 组成一个 X图形，其中中间的 5 个 L 也组成一个 X图形。所有字母 Q 组成了一个 X图形。　　LAAALA　　ALQLQA　　AALQAA　　ALQLQA　　LAAALA　　给定一个字母矩阵，请求其中有多少个 X图形。\n输入格式输入第一行包含两个整数 n, m，分别表示字母矩阵的行数和列数。接下来 n 行，每行 m 个大写字母，为给定的矩阵。\n输出格式输出一行，包含一个整数，表示答案。\n数据范围对于 50% 的评测用例，1 &lt;&#x3D; n, m &lt;&#x3D; 10。对于所有评测用例，1 &lt;&#x3D; n, m &lt;&#x3D; 100。\n算法(枚举)由于本题的数据量较小，暴力枚举即可，细节见代码。\n代码(C++)#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110;int n, m;char g[N][N];inline bool isInner(int x, int y)&#123;return x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m;&#125;inline bool check(char c, int x, int y, int d)&#123;int ax = x - d, ay = y - d;int bx = x - d, by = y + d;int cx = x + d, cy = y - d;int dx = x + d, dy = y + d;if(isInner(ax, ay) &amp;&amp; isInner(bx, by)&amp;&amp; isInner(cx, cy) &amp;&amp; isInner(dx, dy)) &#123;return c == g[ax][ay] &amp;&amp; g[ax][ay] == g[bx][by]&amp;&amp; g[bx][by] == g[cx][cy] &amp;&amp; g[cx][cy] == g[dx][dy];&#125;return false;&#125;inline int get(int x, int y)&#123;char c = g[x][y];int d = 1;while(check(c, x, y, d)) d ++;return d - 1;&#125;int main()&#123;scanf(&quot;%d%d&quot;, &amp;n, &amp;m);for(int i = 1; i &lt;= n; i ++) scanf(&quot;%s&quot;, g[i] + 1);int res = 0;for(int i = 2; i &lt; n; i ++)for(int j = 2; j &lt; m; j ++)res += get(i, j);printf(&quot;%d\\n&quot;, res);return 0;&#125;\nJ题题面小蓝有一个序列 a[1], a[2], …, a[n]，每次可以交换相邻的两个元素，代价为两个元素中较大的那个。请问，要通过交换将序列变为从小到大递增的序列，总代价最少为多少？\n输入格式输入一行包含一个整数 n ，表示序列长度。第二行包含 n 个整数，表示给定的序列。\n输出格式输出一行包含一个整数，表示最少代价的值。\n数据范围对于 30% 的评测用例，1 &lt;&#x3D; n &lt;&#x3D; 1000, 1 &lt;&#x3D; a[i] &lt;&#x3D; 1000。对于 60% 的评测用例，1 &lt;&#x3D; n &lt;&#x3D; 50000, 1 &lt;&#x3D; a[i] &lt;&#x3D; 50000。对于所有评测用例，1 &lt;&#x3D; n &lt;&#x3D; 1000000, 1 &lt;&#x3D; a[i] &lt;&#x3D; 1000000。\n算法(贪心,逆序对,树状数组)我们考虑每一个后缀中的第一个元素$x$应该被交换几次才应该满足最后的升序排列，情况一：如果后缀已经是升序，那么最小代价为0，不需要进行任何交换，情况二：后缀中小于$x$的所有数都应当于x进行交换，并且最小代价为$cnt(&lt;x) \\times x$，因为我们从后往前枚举完每一个后缀时，它应该变为了升序的序列。\n\n证明：对应着情况一、二，情况一：升序，计算下一个后缀，情况二：我们花费了最小代价将其变为升序。\n\n需要说明的是我们并不用手动的将其变为升序，因为只要不存在逆序对，那么这个序列就一定是升序的，我们会花费代价将有逆序对的后缀变为逆序对数量为0的后缀，即升序。计算逆序对的方式有很多，在本题中最适合使用的是支持单点修改和区间查询的树状数组。注意某点的代价极限为$1e6 \\times 1e6$，会爆$int$，记得开$long\\ long$。\n代码(C++)#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1000010;typedef long long LL;int n;int a[N];int tr[N];int lowbit(int x)&#123;return x &amp; -x;&#125;void add(int x, int v)&#123;for(int i = x; i &lt; N; i += lowbit(i)) tr[i] += v;&#125;int query(int x)&#123;int res = 0;for(int i = x; i; i -= lowbit(i)) res += tr[i];return res;&#125;int main()&#123;scanf(&quot;%d&quot;, &amp;n);for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);LL res = 0;for(int i = n; i &gt;= 1; i --)&#123;int v = a[i];res += query(v - 1) * 1ll * v;add(v, 1);&#125;printf(&quot;%lld\\n&quot;, res);return 0;&#125;\n附录D题输入（30 $\\times$ 60）174094882455171152761423221685761892795431233411387427793198650286024865090061389344606618496378829135984076361542097372601657541200146071777733599818266038012509478351201640618984143988087783837107349651099683484992553337438088068198972282890781586124258626539246182119762952003918195325258677229419698255491250839396799769357665825441616335532825361862146291503649293440596342887581257444442930778730382520372975343211325351222640703400531067500454956482168314849207060705673849265774579830223671554026061117300483012903885770893074783710083450145620356667677191627276513995926532444279237315785832411595106453089134746365281031552217482363035280722591085079053410485925413958279617719034175332412908745680774313630190429314820559328748143552689295945058801322270313370955837837939182801848609300876356583948397645861551964542532682663945625356614462682551015176002433628234343684739800880514363921982340231989891351425389287014819359798014755509282450440511590838726938103384801541373585690893606978941566666714061214952341523168827712604946036245881214982452998386986623826275782780208928205527678781609589000725521486468983551558405472149903035076783644195574734088152324666290493119955560594634905391288186024902215444250421277955403412298227858394469856607272647132163832860126054679347881638761723785858733108109249157334220127702410373959720286708183036202841837581704881367895556630088230650972282944827258473951902831431040790814079538232104075905120989173307660289899942087873076421916033622143260549608274076012938515668898707915863945382394851328164677964192631597026176253407553188801750590935427267220117591817866992665840378311257621611574856498432538327068011953631534031790352912617015229051836886166704989498756486878095690013558017746707412183571476823027885971347137127534455141","categories":["编程"],"tags":["C","编程","C++","蓝桥杯"]},{"title":"顺序表（Sequential List）的完整实现与详解~","url":"/2025/10/24/%E9%A1%BA%E5%BA%8F%E8%A1%A8(Sequential-List)%E7%9A%84%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0%E4%B8%8E%E8%AF%A6%E8%A7%A3/","content":"一、引言顺序表是线性表的顺序存储实现，是数据结构中最基础也是最重要的线性结构之一。本文将详细解析一个完整的顺序表实现，包括基本操作、扩展功能以及交互式菜单系统。\n二、基础定义与结构设计2.1 常量与类型定义#define MAXSIZE 100 // 最大容量#define ERROR 0#define OK 1#define OVERFLOW (-1)#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;typedef int Status;\n\n设计说明：\n\nMAXSIZE：定义顺序表的最大容量为100个元素\nStatus：函数返回状态类型，用于表示操作成功或失败\n返回值约定：OK表示成功，ERROR表示失败，OVERFLOW表示内存溢出\n\n2.2 顺序表结构体typedef struct&#123;    int *elem;     // 存储空间基址    int length;    // 当前长度    int listsize;  // 当前分配的存储容量&#125; SqList;\n\n结构成员解析：\n\nelem：指向动态分配的数组首地址\nlength：当前顺序表中元素的个数\nlistsize：当前分配的存储容量（最大可存储元素数）\n\n三、核心基础操作3.1 初始化顺序表Status InitList(SqList &amp;L)&#123;    L.elem = new int[MAXSIZE];    if (!L.elem)        return OVERFLOW;    L.length = 0;    L.listsize = MAXSIZE;    cout &lt;&lt; &quot;顺序表初始化成功！&quot; &lt;&lt; endl;    return OK;&#125;\n\n功能说明：\n\n动态分配MAXSIZE大小的内存空间\n检查内存分配是否成功\n初始化长度为0，容量为MAXSIZE\n\n3.2 销毁顺序表void DestroyList(SqList &amp;L)&#123;    if (L.elem)    &#123;        delete[] L.elem;        L.elem = NULL;        L.length = 0;        L.listsize = 0;    &#125;&#125;\n\n功能说明：\n\n释放动态分配的内存\n将指针置空，防止野指针\n重置长度和容量为0\n\n3.3 清空顺序表void ClearList(SqList &amp;L)&#123;    L.length = 0;    cout &lt;&lt; &quot;顺序表已清空！&quot; &lt;&lt; endl;&#125;\n\n功能说明：\n\n仅将长度置0，不释放内存空间\n逻辑清空，物理空间保留\n\n3.4 判断空表bool ListEmpty(SqList L)&#123;    return L.length == 0;&#125;\n\n3.5 获取长度int ListLength(SqList L)&#123;    return L.length;&#125;\n\n四、数据访问操作4.1 按位置获取元素Status GetElem(SqList L, int i, int &amp;e)&#123;    if (i &lt; 1 || i &gt; L.length)        return ERROR;    e = L.elem[i - 1];    return OK;&#125;\n\n算法分析：\n\n时间复杂度：O(1)\n注意：位序从1开始，数组下标从0开始\n边界检查：确保i在合法范围内\n\n4.2 按值查找元素int LocateElem(SqList L, int e)&#123;    for (int i = 0; i &lt; L.length; i++)    &#123;        if (L.elem[i] == e)            return i + 1; // 返回位序（从1开始）    &#125;    return 0; // 未找到&#125;\n\n算法分析：\n\n时间复杂度：O(n)\n返回值：找到返回位序（1～length），未找到返回0\n查找策略：顺序查找，返回第一个匹配元素\n\n五、插入与删除操作5.1 插入元素Status ListInsert(SqList &amp;L, int i, int e)&#123;    if (i &lt; 1 || i &gt; L.length + 1)        return ERROR;    if (L.length &gt;= L.listsize)    &#123;        cout &lt;&lt; &quot;顺序表已满，无法插入！&quot; &lt;&lt; endl;        return ERROR;    &#125;        // 将第i个位置及之后的元素后移    for (int j = L.length - 1; j &gt;= i - 1; j--)    &#123;        L.elem[j + 1] = L.elem[j];    &#125;    L.elem[i - 1] = e;    L.length++;    return OK;&#125;\n\n算法分析：\n\n时间复杂度：O(n)\n插入位置：可以在1到length+1之间（包括尾部插入）\n关键步骤：从后往前移动元素，避免数据覆盖\n\n5.2 删除元素Status ListDelete(SqList &amp;L, int i, int &amp;e)&#123;    if (i &lt; 1 || i &gt; L.length)        return ERROR;        e = L.elem[i - 1];        // 将第i个位置之后的元素前移    for (int j = i; j &lt; L.length; j++)    &#123;        L.elem[j - 1] = L.elem[j];    &#125;    L.length--;    return OK;&#125;\n\n算法分析：\n\n时间复杂度：O(n)\n返回值：通过引用参数e返回被删除的元素\n关键步骤：从前往后移动元素\n\n六、扩展功能实现6.1 创建顺序表void CreateList(SqList &amp;L, int n)&#123;    if (n &lt;= 0 || n &gt; MAXSIZE)    &#123;        cout &lt;&lt; &quot;输入的长度不合法！&quot; &lt;&lt; endl;        return;    &#125;        cout &lt;&lt; &quot;请依次输入&quot; &lt;&lt; n &lt;&lt; &quot;个数据：&quot; &lt;&lt; endl;    for (int i = 0; i &lt; n; i++)    &#123;        cout &lt;&lt; &quot;第&quot; &lt;&lt; (i + 1) &lt;&lt; &quot;个数据: &quot;;        cin &gt;&gt; L.elem[i];    &#125;    L.length = n;    cout &lt;&lt; &quot;顺序表创建成功！&quot; &lt;&lt; endl;&#125;\n\n6.2 打印顺序表void PrintList(SqList L)&#123;    if (L.length == 0)    &#123;        cout &lt;&lt; &quot;顺序表为空！&quot; &lt;&lt; endl;        return;    &#125;        cout &lt;&lt; &quot;顺序表内容: &quot;;    for (int i = 0; i &lt; L.length; i++)    &#123;        cout &lt;&lt; L.elem[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;\n\n6.3 排序（冒泡排序）void SortList(SqList &amp;L)&#123;    if (L.length &lt;= 1)        return;        for (int i = 0; i &lt; L.length - 1; i++)    &#123;        for (int j = 0; j &lt; L.length - 1 - i; j++)        &#123;            if (L.elem[j] &gt; L.elem[j + 1])            &#123;                int temp = L.elem[j];                L.elem[j] = L.elem[j + 1];                L.elem[j + 1] = temp;            &#125;        &#125;    &#125;&#125;\n\n算法分析：\n\n时间复杂度：O(n²)\n空间复杂度：O(1)\n排序方式：升序排列\n\n6.4 逆置顺序表void ReverseList(SqList &amp;L)&#123;    if (L.length &lt;= 1)        return;        for (int i = 0; i &lt; L.length / 2; i++)    &#123;        int temp = L.elem[i];        L.elem[i] = L.elem[L.length - 1 - i];        L.elem[L.length - 1 - i] = temp;    &#125;&#125;\n\n算法分析：\n\n时间复杂度：O(n)\n方法：首尾对称交换\n\n6.5 查找最大值和最小值Status FindMax(SqList L, int &amp;max)&#123;    if (L.length == 0)        return ERROR;        max = L.elem[0];    for (int i = 1; i &lt; L.length; i++)    &#123;        if (L.elem[i] &gt; max)            max = L.elem[i];    &#125;    return OK;&#125;Status FindMin(SqList L, int &amp;min)&#123;    if (L.length == 0)        return ERROR;        min = L.elem[0];    for (int i = 1; i &lt; L.length; i++)    &#123;        if (L.elem[i] &lt; min)            min = L.elem[i];    &#125;    return OK;&#125;\n\n算法分析：\n\n时间复杂度：O(n)\n方法：遍历一次找出最值\n\n6.6 合并两个有序顺序表SqList MergeList(SqList La, SqList Lb)&#123;    SqList Lc;    InitList(Lc);        int i = 0, j = 0, k = 0;        while (i &lt; La.length &amp;&amp; j &lt; Lb.length)    &#123;        if (La.elem[i] &lt;= Lb.elem[j])        &#123;            Lc.elem[k++] = La.elem[i++];        &#125;        else        &#123;            Lc.elem[k++] = Lb.elem[j++];        &#125;    &#125;        while (i &lt; La.length)    &#123;        Lc.elem[k++] = La.elem[i++];    &#125;        while (j &lt; Lb.length)    &#123;        Lc.elem[k++] = Lb.elem[j++];    &#125;        Lc.length = k;    return Lc;&#125;\n\n算法分析：\n\n时间复杂度：O(m+n)\n前提条件：两个顺序表都已排序\n归并策略：双指针法\n\n6.7 去除重复元素void RemoveDuplicate(SqList &amp;L)&#123;    if (L.length &lt;= 1)        return;        int newLength = 1;    for (int i = 1; i &lt; L.length; i++)    &#123;        bool isDuplicate = false;        for (int j = 0; j &lt; newLength; j++)        &#123;            if (L.elem[i] == L.elem[j])            &#123;                isDuplicate = true;                break;            &#125;        &#125;        if (!isDuplicate)        &#123;            L.elem[newLength++] = L.elem[i];        &#125;    &#125;    L.length = newLength;&#125;\n\n算法分析：\n\n时间复杂度：O(n²)\n策略：保留第一次出现的元素\n优化建议：可以先排序再去重，时间复杂度降为O(nlogn)\n\n七、交互式菜单系统7.1 菜单显示void ShowMenu()&#123;    cout &lt;&lt; &quot;\\n========== 顺序表操作菜单 ==========&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;1.  创建顺序表&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;2.  插入元素&quot; &lt;&lt; endl;    // ... 其他菜单项    cout &lt;&lt; &quot;0.  退出程序&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;====================================&quot; &lt;&lt; endl;&#125;\n\n7.2 主函数框架主函数实现了一个完整的交互式界面，通过switch语句处理用户的各种操作选择，提供了15种不同的功能操作。\n八、总结8.1 顺序表的优缺点优点：\n\n随机访问，时间复杂度O(1)\n存储密度高，无需额外空间存储指针\n实现简单，易于理解\n\n缺点：\n\n插入删除效率低，平均时间复杂度O(n)\n需要预先分配固定大小的空间\n空间利用率可能不高\n\n8.2 时间复杂度总结\n\n\n操作\n时间复杂度\n\n\n\n初始化\nO(1)\n\n\n销毁\nO(1)\n\n\n按位置访问\nO(1)\n\n\n按值查找\nO(n)\n\n\n插入\nO(n)\n\n\n删除\nO(n)\n\n\n排序\nO(n²)\n\n\n逆置\nO(n)\n\n\n合并\nO(m+n)\n\n\n8.3 实际应用场景\n需要频繁随机访问的场景\n数据规模相对固定\n插入删除操作较少\n例如：成绩管理、数组处理等\n\n\n完整代码，可直接编译运行体验各项功能！\n#define MAXSIZE 100 // 最大容量#define ERROR 0#define OK 1#define OVERFLOW (-1)#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;typedef int Status;// 顺序表结构定义typedef struct&#123;    int *elem;     // 存储空间基址    int length;    // 当前长度    int listsize;  // 当前分配的存储容量&#125; SqList;// 初始化顺序表Status InitList(SqList &amp;L)&#123;    L.elem = new int[MAXSIZE];    if (!L.elem)        return OVERFLOW;    L.length = 0;    L.listsize = MAXSIZE;    cout &lt;&lt; &quot;顺序表初始化成功！&quot; &lt;&lt; endl;    return OK;&#125;// 销毁顺序表void DestroyList(SqList &amp;L)&#123;    if (L.elem)    &#123;        delete[] L.elem;        L.elem = NULL;        L.length = 0;        L.listsize = 0;    &#125;&#125;// 清空顺序表void ClearList(SqList &amp;L)&#123;    L.length = 0;    cout &lt;&lt; &quot;顺序表已清空！&quot; &lt;&lt; endl;&#125;// 判断顺序表是否为空bool ListEmpty(SqList L)&#123;    return L.length == 0;&#125;// 获取顺序表长度int ListLength(SqList L)&#123;    return L.length;&#125;// 获取指定位置的元素Status GetElem(SqList L, int i, int &amp;e)&#123;    if (i &lt; 1 || i &gt; L.length)        return ERROR;    e = L.elem[i - 1];    return OK;&#125;// 查找元素（返回第一个匹配的位置）int LocateElem(SqList L, int e)&#123;    for (int i = 0; i &lt; L.length; i++)    &#123;        if (L.elem[i] == e)            return i + 1; // 返回位序（从1开始）    &#125;    return 0; // 未找到&#125;// 在指定位置插入元素Status ListInsert(SqList &amp;L, int i, int e)&#123;    if (i &lt; 1 || i &gt; L.length + 1)        return ERROR;    if (L.length &gt;= L.listsize)    &#123;        cout &lt;&lt; &quot;顺序表已满，无法插入！&quot; &lt;&lt; endl;        return ERROR;    &#125;        // 将第i个位置及之后的元素后移    for (int j = L.length - 1; j &gt;= i - 1; j--)    &#123;        L.elem[j + 1] = L.elem[j];    &#125;    L.elem[i - 1] = e;    L.length++;    return OK;&#125;// 删除指定位置的元素Status ListDelete(SqList &amp;L, int i, int &amp;e)&#123;    if (i &lt; 1 || i &gt; L.length)        return ERROR;        e = L.elem[i - 1];        // 将第i个位置之后的元素前移    for (int j = i; j &lt; L.length; j++)    &#123;        L.elem[j - 1] = L.elem[j];    &#125;    L.length--;    return OK;&#125;// 创建顺序表void CreateList(SqList &amp;L, int n)&#123;    if (n &lt;= 0 || n &gt; MAXSIZE)    &#123;        cout &lt;&lt; &quot;输入的长度不合法！&quot; &lt;&lt; endl;        return;    &#125;        cout &lt;&lt; &quot;请依次输入&quot; &lt;&lt; n &lt;&lt; &quot;个数据：&quot; &lt;&lt; endl;    for (int i = 0; i &lt; n; i++)    &#123;        cout &lt;&lt; &quot;第&quot; &lt;&lt; (i + 1) &lt;&lt; &quot;个数据: &quot;;        cin &gt;&gt; L.elem[i];    &#125;    L.length = n;    cout &lt;&lt; &quot;顺序表创建成功！&quot; &lt;&lt; endl;&#125;// 打印顺序表void PrintList(SqList L)&#123;    if (L.length == 0)    &#123;        cout &lt;&lt; &quot;顺序表为空！&quot; &lt;&lt; endl;        return;    &#125;        cout &lt;&lt; &quot;顺序表内容: &quot;;    for (int i = 0; i &lt; L.length; i++)    &#123;        cout &lt;&lt; L.elem[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;// 顺序表排序（冒泡排序）void SortList(SqList &amp;L)&#123;    if (L.length &lt;= 1)        return;        for (int i = 0; i &lt; L.length - 1; i++)    &#123;        for (int j = 0; j &lt; L.length - 1 - i; j++)        &#123;            if (L.elem[j] &gt; L.elem[j + 1])            &#123;                int temp = L.elem[j];                L.elem[j] = L.elem[j + 1];                L.elem[j + 1] = temp;            &#125;        &#125;    &#125;&#125;// 逆置顺序表void ReverseList(SqList &amp;L)&#123;    if (L.length &lt;= 1)        return;        for (int i = 0; i &lt; L.length / 2; i++)    &#123;        int temp = L.elem[i];        L.elem[i] = L.elem[L.length - 1 - i];        L.elem[L.length - 1 - i] = temp;    &#125;&#125;// 查找最大值Status FindMax(SqList L, int &amp;max)&#123;    if (L.length == 0)        return ERROR;        max = L.elem[0];    for (int i = 1; i &lt; L.length; i++)    &#123;        if (L.elem[i] &gt; max)            max = L.elem[i];    &#125;    return OK;&#125;// 查找最小值Status FindMin(SqList L, int &amp;min)&#123;    if (L.length == 0)        return ERROR;        min = L.elem[0];    for (int i = 1; i &lt; L.length; i++)    &#123;        if (L.elem[i] &lt; min)            min = L.elem[i];    &#125;    return OK;&#125;// 合并两个有序顺序表SqList MergeList(SqList La, SqList Lb)&#123;    SqList Lc;    InitList(Lc);        int i = 0, j = 0, k = 0;        while (i &lt; La.length &amp;&amp; j &lt; Lb.length)    &#123;        if (La.elem[i] &lt;= Lb.elem[j])        &#123;            Lc.elem[k++] = La.elem[i++];        &#125;        else        &#123;            Lc.elem[k++] = Lb.elem[j++];        &#125;    &#125;        while (i &lt; La.length)    &#123;        Lc.elem[k++] = La.elem[i++];    &#125;        while (j &lt; Lb.length)    &#123;        Lc.elem[k++] = Lb.elem[j++];    &#125;        Lc.length = k;    return Lc;&#125;// 去重（保留第一次出现的元素）void RemoveDuplicate(SqList &amp;L)&#123;    if (L.length &lt;= 1)        return;        int newLength = 1;    for (int i = 1; i &lt; L.length; i++)    &#123;        bool isDuplicate = false;        for (int j = 0; j &lt; newLength; j++)        &#123;            if (L.elem[i] == L.elem[j])            &#123;                isDuplicate = true;                break;            &#125;        &#125;        if (!isDuplicate)        &#123;            L.elem[newLength++] = L.elem[i];        &#125;    &#125;    L.length = newLength;&#125;// 显示菜单void ShowMenu()&#123;    cout &lt;&lt; &quot;\\n========== 顺序表操作菜单 ==========&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;1.  创建顺序表&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;2.  插入元素&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;3.  删除元素&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;4.  查找元素（按值）&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;5.  获取元素（按位置）&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;6.  获取顺序表长度&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;7.  打印顺序表&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;8.  排序顺序表&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;9.  逆置顺序表&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;10. 清空顺序表&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;11. 判断顺序表是否为空&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;12. 查找最大值&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;13. 查找最小值&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;14. 去除重复元素&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;15. 合并两个有序顺序表&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;0.  退出程序&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;====================================&quot; &lt;&lt; endl;&#125;int main()&#123;    SqList L;    InitList(L);        int choice, n, position, elem;    Status result;    ShowMenu();    while (true)    &#123;        cout &lt;&lt; &quot;请选择操作: &quot;;        cin &gt;&gt; choice;                switch (choice)        &#123;        case 1: // 创建顺序表            cout &lt;&lt; &quot;请输入要创建的顺序表长度: &quot;;            cin &gt;&gt; n;            CreateList(L, n);            break;                    case 2: // 插入元素            cout &lt;&lt; &quot;请输入插入位置（1-&quot; &lt;&lt; (L.length + 1) &lt;&lt; &quot;）: &quot;;            cin &gt;&gt; position;            cout &lt;&lt; &quot;请输入插入的元素值: &quot;;            cin &gt;&gt; elem;            result = ListInsert(L, position, elem);            if (result == OK)                cout &lt;&lt; &quot;插入成功！&quot; &lt;&lt; endl;            else                cout &lt;&lt; &quot;插入失败！位置不合法。&quot; &lt;&lt; endl;            break;                    case 3: // 删除元素            cout &lt;&lt; &quot;请输入要删除的位置（1-&quot; &lt;&lt; L.length &lt;&lt; &quot;）: &quot;;            cin &gt;&gt; position;            result = ListDelete(L, position, elem);            if (result == OK)                cout &lt;&lt; &quot;删除成功！删除的元素为: &quot; &lt;&lt; elem &lt;&lt; endl;            else                cout &lt;&lt; &quot;删除失败！位置不合法。&quot; &lt;&lt; endl;            break;                    case 4: // 查找元素            cout &lt;&lt; &quot;请输入要查找的元素值: &quot;;            cin &gt;&gt; elem;            position = LocateElem(L, elem);            if (position != 0)                cout &lt;&lt; &quot;元素 &quot; &lt;&lt; elem &lt;&lt; &quot; 在第 &quot; &lt;&lt; position &lt;&lt; &quot; 个位置&quot; &lt;&lt; endl;            else                cout &lt;&lt; &quot;未找到元素 &quot; &lt;&lt; elem &lt;&lt; endl;            break;                    case 5: // 获取元素            cout &lt;&lt; &quot;请输入要获取的位置（1-&quot; &lt;&lt; L.length &lt;&lt; &quot;）: &quot;;            cin &gt;&gt; position;            result = GetElem(L, position, elem);            if (result == OK)                cout &lt;&lt; &quot;第 &quot; &lt;&lt; position &lt;&lt; &quot; 个位置的元素为: &quot; &lt;&lt; elem &lt;&lt; endl;            else                cout &lt;&lt; &quot;获取失败！位置不合法。&quot; &lt;&lt; endl;            break;                    case 6: // 获取长度            cout &lt;&lt; &quot;顺序表长度为: &quot; &lt;&lt; ListLength(L) &lt;&lt; endl;            break;                    case 7: // 打印顺序表            PrintList(L);            break;                    case 8: // 排序            if (ListEmpty(L))            &#123;                cout &lt;&lt; &quot;顺序表为空，无法排序！&quot; &lt;&lt; endl;            &#125;            else            &#123;                SortList(L);                cout &lt;&lt; &quot;排序完成！&quot; &lt;&lt; endl;                PrintList(L);            &#125;            break;                    case 9: // 逆置            if (ListEmpty(L))            &#123;                cout &lt;&lt; &quot;顺序表为空，无法逆置！&quot; &lt;&lt; endl;            &#125;            else            &#123;                ReverseList(L);                cout &lt;&lt; &quot;逆置完成！&quot; &lt;&lt; endl;                PrintList(L);            &#125;            break;                    case 10: // 清空顺序表            ClearList(L);            break;                    case 11: // 判断是否为空            if (ListEmpty(L))                cout &lt;&lt; &quot;顺序表为空&quot; &lt;&lt; endl;            else                cout &lt;&lt; &quot;顺序表不为空，长度为: &quot; &lt;&lt; ListLength(L) &lt;&lt; endl;            break;                    case 12: // 查找最大值            result = FindMax(L, elem);            if (result == OK)                cout &lt;&lt; &quot;顺序表的最大值为: &quot; &lt;&lt; elem &lt;&lt; endl;            else                cout &lt;&lt; &quot;顺序表为空！&quot; &lt;&lt; endl;            break;                    case 13: // 查找最小值            result = FindMin(L, elem);            if (result == OK)                cout &lt;&lt; &quot;顺序表的最小值为: &quot; &lt;&lt; elem &lt;&lt; endl;            else                cout &lt;&lt; &quot;顺序表为空！&quot; &lt;&lt; endl;            break;                    case 14: // 去重            if (ListEmpty(L))            &#123;                cout &lt;&lt; &quot;顺序表为空！&quot; &lt;&lt; endl;            &#125;            else            &#123;                RemoveDuplicate(L);                cout &lt;&lt; &quot;去重完成！&quot; &lt;&lt; endl;                PrintList(L);            &#125;            break;                    case 15: // 合并两个有序顺序表        &#123;            SqList L2;            InitList(L2);            cout &lt;&lt; &quot;请输入第二个顺序表的长度: &quot;;            cin &gt;&gt; n;            CreateList(L2, n);                        cout &lt;&lt; &quot;对两个顺序表进行排序...&quot; &lt;&lt; endl;            SortList(L);            SortList(L2);                        SqList L3 = MergeList(L, L2);            cout &lt;&lt; &quot;合并后的顺序表: &quot;;            PrintList(L3);                        DestroyList(L2);            DestroyList(L3);            break;        &#125;                    case 0: // 退出            DestroyList(L);            cout &lt;&lt; &quot;程序已退出，感谢使用！&quot; &lt;&lt; endl;            return 0;                    default:            cout &lt;&lt; &quot;无效的选择，请重新输入！&quot; &lt;&lt; endl;            break;        &#125;    &#125;        return 0;&#125;\n\n","categories":["数据结构"],"tags":["编程","数据结构"]}]